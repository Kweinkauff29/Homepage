<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>BER Wrap Sheet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      /* Matrix.org / Kayak Club Theme (Black & White) */
      --ink: #000000;
      --ink-soft: #555555;
      --bg-main: #ffffff;

      --panel: #ffffff;
      --panel-elevated: #ffffff;
      --panel-border: #000000;

      /* High Contrast Accents */
      --accent: #000000;
      /* black replaces teal */
      --accent-soft: #e5e5e5;
      /* light gray */
      --accent-muted: #9ca3af;

      --danger: #e11d48;
      --success: #16a34a;

      --radius-lg: 24px;
      /* Larger card rounding */
      --radius-md: 16px;
      --radius-sm: 8px;
      --radius-btn: 999px;
      /* Pill buttons */

      --shadow-xl: none;
      /* Remove shadows for flat, high-contrast look */
      --shadow-md: none;

      --font-sans: "Helvetica Neue", Helvetica, Arial, sans-serif;

      /* Board Ideas Pillar Colors - Keep distinct but maybe mute/bold them? keeping as is for functionality */
      --elevate: #f59e0b;
      --engage: #3b82f6;
      --evolve: #10b981;
      --excite: #ec4899;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: var(--bg-main);
      background-attachment: fixed;
      background-size: cover;
      color: var(--ink);
      font-family: var(--font-sans);
      min-height: 100vh;
    }

    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* High Contrast Dark Mode (Matrix Dark) */
    /* High Contrast Dark Mode (Matrix Dark - Grey variant) */
    body[data-theme="dark"] {
      --ink: #ffffff;
      --ink-soft: #a0a0a0;
      /* Dark Grey Background as requested */
      --bg-main: #121212;

      --panel: #1e1e1e;
      --panel-elevated: #1e1e1e;
      --panel-border: #404040;

      --shadow-xl: none;
      --shadow-md: none;
    }

    /* ... (rest of html rule) ... */



    /* NUCLEAR OPTION: Force full page background on the WP Parent Site */
    html {
      background: var(--bg-main) !important;
      background-size: cover !important;
      min-height: 100vh !important;
    }

    /* Make standard WP/Elementor containers transparent so background shows through */
    body,
    #page,
    .site-content,
    .app-main,
    header.ber-header,
    footer.elementor-location-footer,
    .elementor-section,
    .elementor-column {
      background: transparent !important;
      box-shadow: none !important;
    }

    /* Ensure footer text is visible if it relies on black bg */
    footer.elementor-location-footer h1,
    footer.elementor-location-footer h2,
    footer.elementor-location-footer h3,
    footer.elementor-location-footer p,
    footer.elementor-location-footer li,
    footer.elementor-location-footer a {
      color: rgba(255, 255, 255, 0.8) !important;
    }

    /* Hide the Parent Header to give Wrap Sheet full real estate */
    header.ber-header,
    .elementor-location-header,
    #masthead,
    .site-header {
      display: none !important;
    }

    .app-shell {
      width: 100%;
      max-width: 1600px;
      /* Optional constraint for readability on huge screens */
      margin: 0 auto;
      padding: 16px;
      /* Reduced from 24px */
      display: flex;
      flex-direction: column;
      gap: 12px;
      /* Reduced from 24px */
    }

    header.app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      /* Reduced from 16px 24px */
      border-radius: var(--radius-lg);
      background: var(--panel-elevated);
      /* No shadow, just border */
      box-shadow: none;
      border: 1px solid var(--panel-border);
    }

    .branding {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .branding-mark {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #fbbf24, var(--accent) 60%, #0f172a 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #f9fafb;
      font-weight: 800;
      font-size: 18px;
      letter-spacing: 0.08em;
    }

    .branding-text h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .branding-text span {
      display: block;
      margin-top: 2px;
      font-size: 11px;
      color: var(--ink-soft);
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .user-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(3, 170, 225, 0.06);
      /* light, on white */
      border: 1px solid var(--panel-border);
      font-size: 12px;
      color: var(--ink-soft);
    }

    body[data-theme="dark"] .user-pill {
      background: rgba(15, 23, 42, 0.9);
      border-color: rgba(148, 163, 184, 0.4);
    }

    .user-pill button {
      border: none;
      background: rgba(248, 250, 252, 0.06);
      color: var(--ink);
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
    }

    .user-pill button:hover {
      background: rgba(248, 250, 252, 0.18);
    }

    main.app-main {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .panel {
      background: var(--panel);
      border-radius: var(--radius-lg);
      border: 1px solid var(--panel-border);
      box-shadow: none;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--ink);
      /* Thicker, bolder separators */
      margin-bottom: 8px;
    }

    .panel-title {
      font-size: 14px;
      font-weight: 700;
      letter-spacing: -0.01em;
      /* Tight typography like Matrix */
      text-transform: none;
      /* Matrix uses sentence case often, but let's stick to clean sans */
      color: var(--ink);
    }

    .chip {
      font-size: 11px;
      padding: 4px 12px;
      border-radius: var(--radius-btn);
      border: 1px solid var(--ink);
      text-transform: uppercase;
      font-weight: 700;
      letter-spacing: 0.05em;
      color: var(--ink);
      background: transparent;
    }

    .chip-accent {
      background: var(--ink);
      color: var(--bg-main);
      border-color: var(--ink);
    }

    /* Calendar */

    .calendar-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--ink);
    }

    .calendar-controls button {
      border-radius: var(--radius-btn);
      border: 1px solid var(--ink);
      background: transparent;
      color: var(--ink);
      padding: 6px 16px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .calendar-controls button:hover {
      background: var(--ink);
      color: var(--bg-main);
    }

    .calendar-controls span.month-label {
      font-size: 13px;
      font-weight: 600;
      color: #f9fafb;
    }

    .calendar-controls select {
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.95);
      color: var(--ink);
      padding: 3px 8px;
      font-size: 11px;
    }

    .calendar-legend {
      margin-left: auto;
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 11px;
    }

    .legend-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      margin-right: 4px;
      display: inline-block;
    }

    .legend-pending {
      background: rgba(248, 250, 252, 0.26);
    }

    .legend-inprogress {
      background: var(--accent-soft);
    }

    .legend-done {
      background: var(--success);
    }

    .legend-blocked {
      background: var(--danger);
    }

    .calendar-grid {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 4px;
      margin-top: 6px;
    }

    .calendar-weekdays {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 4px;
      font-size: 11px;
      color: var(--ink-soft);
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .calendar-weekdays div {
      text-align: center;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
    }

    .calendar-days {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 4px;
      font-size: 11px;
    }

    .day-cell {
      position: relative;
      min-height: 86px;
      background: var(--bg-main);
      border-radius: var(--radius-md);
      border: 1px solid var(--panel-border);
      padding: 4px 4px 20px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .day-cell.is-today {
      border: 2px solid var(--ink);
      box-shadow: none;
    }

    .day-cell-empty {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .day-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
    }

    .day-number {
      font-size: 12px;
      font-weight: 600;
    }

    .add-task-btn {
      border: none;
      background: transparent;
      color: var(--ink-soft);
      font-size: 14px;
      cursor: pointer;
      padding: 0 3px;
    }

    .add-task-btn:hover {
      color: var(--accent-soft);
    }

    .tasks-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
      overflow-y: auto;
      scrollbar-width: thin;
    }

    .task-pill {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 6px 8px;
      border-radius: var(--radius-sm);
      background: var(--panel);
      border: 1px solid var(--panel-border);
      cursor: pointer;
      white-space: normal;
      word-wrap: break-word;
      min-height: fit-content;
      transition: all 0.2s;
    }

    .task-pill:hover {
      box-shadow: 2px 2px 0 var(--ink);
      transform: translateY(-1px);
    }

    .task-quick-actions {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: auto;
      flex-shrink: 0;
    }

    .task-quick-actions input[type="checkbox"] {
      cursor: pointer;
    }

    .task-quick-actions button {
      border: none;
      border-radius: 999px;
      padding: 0 6px;
      font-size: 10px;
      background: rgba(127, 29, 29, 0.9);
      color: #fee2e2;
      cursor: pointer;
    }

    .task-quick-actions button.active {
      background: #b91c1c;
    }


    .task-status-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      flex-shrink: 0;
    }

    .task-status-pending {
      background: rgba(248, 250, 252, 0.3);
    }

    .task-status-in_progress {
      background: var(--accent-soft);
    }

    .task-status-done {
      background: var(--success);
    }

    .task-status-could_not_complete {
      background: var(--danger);
    }

    /* ADD THIS */

    .task-title {
      flex: 1;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .task-assignee {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .calendar-metrics {
      margin-top: 8px;
      display: flex;
      justify-content: flex-end;
    }

    #status-pie {
      max-width: 180px;
      max-height: 180px;
    }

    /* Goals */

    /* Goals */

    .goals-tabs {
      display: inline-flex;
      background: transparent;
      border-radius: var(--radius-btn);
      padding: 0;
      gap: 8px;
      border: none;
    }

    .goals-tab {
      padding: 8px 24px;
      border-radius: var(--radius-btn);
      border: 1px solid var(--ink);
      background: transparent;
      color: var(--ink);
      cursor: pointer;
      text-transform: none;
      font-weight: 700;
      font-size: 13px;
      letter-spacing: -0.01em;
      transition: all 0.2s;
    }

    .goals-tab.active {
      background: var(--ink);
      color: var(--bg-main);
      box-shadow: none;
    }

    .goals-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: var(--ink);
      align-items: center;
    }

    .goals-controls label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-weight: 600;
    }

    .goals-controls input[type="month"],
    .goals-controls select,
    .goals-controls input[type="number"] {
      background: transparent;
      border-radius: var(--radius-btn);
      border: 1px solid var(--ink);
      color: var(--ink);
      padding: 6px 16px;
      font-size: 12px;
      font-weight: 600;
    }

    .goals-grid {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }

    @media (max-width: 1200px) {
      .goals-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 780px) {
      .goals-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .goal-column {
      border-radius: var(--radius-md);
      border: 1px solid var(--panel-border);
      background: transparent;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .goal-column-title {
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--ink);
      border-bottom: 2px solid var(--ink);
      padding-bottom: 8px;
      margin-bottom: 4px;
    }

    .goal-card {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-sm);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: all 0.2s;
      box-shadow: none;
    }

    .goal-card:hover {
      transform: translateY(-2px);
      box-shadow: 4px 4px 0 var(--ink);
      /* Brutalist hover effect */
    }

    .goal-card.completed {
      opacity: 0.6;
      background: #f3f4f6;
      text-decoration: line-through;
    }

    /* Assignee Grid Styling */
    .assignee-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 4px;
    }

    .assignee-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: transparent;
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-btn);
      cursor: pointer;
      transition: all 0.2s;
      font-size: 11px;
      font-weight: 600;
      user-select: none;
      color: var(--ink) !important;
    }

    .assignee-option:hover {
      background: var(--ink);
      color: var(--bg-main) !important;
    }

    .assignee-option input[type="checkbox"] {
      accent-color: var(--ink);
      cursor: pointer;
    }

    .assignee-option.selected {
      background: var(--ink);
      border-color: var(--ink);
      color: var(--bg-main) !important;
    }

    /* Subtask creation list */
    .transient-subtasks {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 8px;
    }

    .subtask-row-new {
      display: flex;
      gap: 4px;
    }

    .goal-card.completed {
      border-color: var(--success);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.4);
    }

    .goal-row-top {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      align-items: center;
    }

    .goal-title-input {
      width: 100%;
      background: transparent;
      border: none;
      color: var(--ink);
      font-size: 11px;
      font-weight: 500;
      padding: 0;
      outline: none;
    }

    .goal-owner-tag {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .goal-row-middle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-top: 2px;
    }

    .goal-progress {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      font-size: 10px;
      color: var(--ink-soft);
    }

    .goal-progress input[type="number"] {
      width: 48px;
      padding: 1px 4px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      font-size: 10px;
    }

    .goal-done-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      cursor: pointer;
    }

    .goal-row-note {
      margin-top: 2px;
    }

    .goal-row-note textarea {
      width: 100%;
      min-height: 36px;
      resize: vertical;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 2px 4px;
      outline: none;
    }

    .goal-add-form {
      margin-top: 4px;
      padding-top: 4px;
      border-top: 1px dashed rgba(55, 65, 81, 0.8);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .goal-add-form input,
    .goal-add-form select {
      width: 100%;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 2px 4px;
    }

    .goal-add-form button {
      align-self: flex-end;
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #f9fafb;
      cursor: pointer;
    }

    /* Editable category header input */
    .goal-column-title-input {
      background: transparent;
      border: none;
      border-bottom: 1px dashed transparent;
      color: var(--ink-soft);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      padding: 0;
      padding-bottom: 4px;
      outline: none;
      width: 100%;
      cursor: text;
    }

    .goal-column-title-input:hover,
    .goal-column-title-input:focus {
      border-bottom-color: var(--accent);
    }

    /* Goal subtasks section */
    .goal-subtasks {
      margin-top: 4px;
      padding-top: 4px;
      border-top: 1px dashed rgba(55, 65, 81, 0.6);
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .goal-subtask {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 0;
      font-size: 10px;
    }

    .goal-subtask input[type="checkbox"] {
      cursor: pointer;
      flex-shrink: 0;
    }

    .goal-subtask-title {
      flex: 1;
      color: var(--ink);
    }

    .goal-subtask.completed .goal-subtask-title {
      text-decoration: line-through;
      opacity: 0.6;
    }

    .goal-subtask-calendar-btn {
      border: none;
      background: transparent;
      color: var(--ink-soft);
      cursor: pointer;
      padding: 0 2px;
      font-size: 12px;
      opacity: 0.7;
      transition: opacity 0.1s;
    }

    .goal-subtask-calendar-btn:hover {
      opacity: 1;
      color: var(--accent);
    }

    .goal-subtask-calendar-btn.linked {
      color: var(--success);
      opacity: 1;
    }

    .goal-subtask-delete-btn {
      border: none;
      background: transparent;
      color: var(--danger);
      cursor: pointer;
      padding: 0 2px;
      font-size: 10px;
      opacity: 0.6;
    }

    .goal-subtask-delete-btn:hover {
      opacity: 1;
    }

    .add-subtask-form {
      display: flex;
      gap: 4px;
      margin-top: 2px;
    }

    .add-subtask-form input {
      flex: 1;
      font-size: 10px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 2px 4px;
    }

    .add-subtask-form button {
      border: none;
      background: rgba(55, 65, 81, 0.8);
      color: var(--ink);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      cursor: pointer;
    }

    .add-subtask-form button:hover {
      background: var(--accent);
    }

    /* Goal subtasks toggle */
    .goal-subtasks-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 9px;
      color: var(--ink-soft);
      cursor: pointer;
      margin-top: 3px;
      padding: 2px 0;
    }

    .goal-subtasks-toggle:hover {
      color: var(--accent);
    }

    /* View Options Toolbar Drag Feedback */
    .view-option-btn.drag-over {
      transform: scale(1.05);
      border-color: var(--theme-primary);
      box-shadow: 0 0 0 2px rgba(var(--theme-primary-rgb), 0.2);
      background: var(--bg-secondary);
      transition: all 0.2s ease;
    }

    /* Section Help UI */
    .section-header-help {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      margin-left: 8px;
      border-radius: 50%;
      background: var(--bg-secondary);
      color: var(--ink-soft);
      font-size: 10px;
      font-weight: bold;
      cursor: help;
      border: 1px solid var(--panel-border);
      transition: all 0.2s ease;
      opacity: 0.6;
    }

    .section-header-help:hover {
      background: var(--theme-primary);
      color: white;
      border-color: var(--theme-primary);
      opacity: 1;
    }

    .section-help-box {
      margin-top: 8px;
      margin-bottom: 12px;
      padding: 10px 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--panel-border);
      border-left: 3px solid var(--theme-primary);
      border-radius: 6px;
      font-size: 13px;
      color: var(--ink-base);
      line-height: 1.4;
      animation: fadeIn 0.3s ease-out;
      display: block;
      /* Visible by default */
    }

    .section-help-box.hidden {
      display: none;
    }

    .section-help-box strong {
      color: var(--theme-primary);
    }

    /* ===== JOINT PROJECTS ===== */
    .projects-section {
      margin-top: 16px;
      padding-top: 14px;
      border-top: 1px dashed rgba(55, 65, 81, 0.45);
    }

    .projects-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .projects-title {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .add-project-btn {
      font-size: 10px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: transparent;
      color: var(--ink);
      cursor: pointer;
    }

    .add-project-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .projects-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 10px;
    }

    .project-card {
      border-radius: var(--radius-md);
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.97);
      padding: 10px;
    }

    .project-card.completed {
      border-color: var(--success);
      opacity: 0.8;
    }

    .project-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .project-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
    }

    .project-meta {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .project-progress-bar {
      height: 8px;
      border-radius: 4px;
      background: rgba(55, 65, 81, 0.6);
      overflow: hidden;
      margin: 6px 0;
    }

    .project-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-soft));
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .project-progress-fill.complete {
      background: var(--success);
    }

    .project-progress-label {
      font-size: 10px;
      color: var(--ink-soft);
      text-align: right;
    }

    .project-steps {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .project-step {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 4px;
      background: rgba(31, 41, 55, 0.5);
      font-size: 11px;
    }

    .project-step.current-assignee {
      background: rgba(3, 170, 225, 0.15);
      border: 1px solid rgba(3, 170, 225, 0.5);
    }

    .project-step.done {
      opacity: 0.6;
    }

    .step-status-icon {
      flex-shrink: 0;
      width: 14px;
      text-align: center;
    }

    .step-title {
      flex: 1;
      color: var(--ink);
    }

    .step-done .step-title {
      text-decoration: line-through;
    }

    .step-assignee {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .step-action-btn {
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
    }

    .step-action-btn:hover {
      background: var(--accent-soft);
    }

    .add-step-form {
      display: flex;
      gap: 4px;
      margin-top: 6px;
    }

    .add-step-form input,
    .add-step-form select {
      flex: 1;
      font-size: 10px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 3px 5px;
    }

    .add-step-form button {
      border: none;
      background: rgba(55, 65, 81, 0.8);
      color: var(--ink);
      border-radius: 4px;
      padding: 3px 8px;
      font-size: 10px;
      cursor: pointer;
    }

    /* Light mode for projects */
    body:not([data-theme="dark"]) .project-card {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .project-title {
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .project-step {
      background: #f9fafb;
    }

    body:not([data-theme="dark"]) .project-step.current-assignee {
      background: rgba(3, 170, 225, 0.1);
    }

    body:not([data-theme="dark"]) .step-title {
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .add-step-form input,
    body:not([data-theme="dark"]) .add-step-form select {
      background: #ffffff;
      border-color: #d1d5db;
      color: var(--ink);
    }

    /* ===== WEEKLY TASKS (BETA) ===== */
    .weekly-tasks-section {
      margin-top: 16px;
      padding-top: 14px;
      border-top: 1px dashed rgba(55, 65, 81, 0.45);
    }

    .weekly-tasks-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .weekly-tasks-title {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .beta-badge {
      font-size: 9px;
      font-weight: 600;
      background: linear-gradient(135deg, #f59e0b, #f97316);
      color: #fff;
      padding: 2px 6px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .weekly-tasks-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }

    .weekly-tasks-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .weekly-task-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.97);
    }

    .weekly-task-item.done {
      opacity: 0.6;
    }

    .weekly-task-checkbox {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .weekly-task-title {
      flex: 1;
      font-size: 12px;
      color: var(--ink);
    }

    .weekly-task-item.done .weekly-task-title {
      text-decoration: line-through;
    }

    .add-weekly-task-form {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .add-weekly-task-form input {
      flex: 1;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 6px 8px;
    }

    .add-weekly-task-form button {
      border: none;
      background: var(--accent);
      color: #fff;
      border-radius: 4px;
      padding: 6px 12px;
      font-size: 11px;
      cursor: pointer;
    }

    /* Light mode for weekly tasks */
    body:not([data-theme="dark"]) .weekly-task-item {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .weekly-task-title {
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .add-weekly-task-form input {
      background: #ffffff;
      border-color: #d1d5db;
      color: var(--ink);
    }

    /* ===== DRAGGABLE SECTIONS ===== */
    .draggable-section {
      cursor: default;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .draggable-section.dragging {
      opacity: 0.5;
      transform: scale(0.98);
    }

    .draggable-section.drop-target {
      outline: 2px dashed var(--accent);
      outline-offset: 4px;
    }

    .section-drag-handle {
      cursor: grab;
      padding: 4px 8px;
      margin-right: 8px;
      font-size: 12px;
      color: var(--ink-soft);
      opacity: 0.5;
    }

    .section-drag-handle:hover {
      opacity: 1;
      color: var(--accent);
    }

    .section-drag-handle:active {
      cursor: grabbing;
    }

    /* User chooser overlay */

    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(0, 0, 0, 0.94));
      z-index: 50;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay-panel {
      width: min(360px, 100% - 32px);
      background: rgba(15, 23, 42, 0.98);
      border-radius: 18px;
      padding: 18px 18px 16px;
      border: 1px solid rgba(148, 163, 184, 0.55);
      box-shadow: var(--shadow-xl);
      text-align: left;
    }

    .overlay-panel h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }

    .overlay-panel p {
      margin: 0 0 12px;
      font-size: 13px;
      color: var(--ink-soft);
    }

    .overlay-panel select {
      width: 100%;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: var(--ink);
      padding: 6px 10px;
      margin-bottom: 10px;
      font-size: 13px;
    }

    .overlay-panel button {
      width: 100%;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #f9fafb;
      padding: 8px 10px;
      font-size: 13px;
      cursor: pointer;
    }

    .overlay-panel small {
      display: block;
      margin-top: 6px;
      font-size: 11px;
      color: var(--ink-soft);
      text-align: center;
    }

    /* Task modal */

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }

    .modal.hidden {
      display: none;
    }

    .modal-panel {
      width: min(420px, 100% - 32px);
      background: rgba(15, 23, 42, 0.98);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: var(--shadow-xl);
      padding: 14px 14px 12px;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
    }

    .modal-close {
      border: none;
      background: transparent;
      color: var(--ink-soft);
      font-size: 18px;
      cursor: pointer;
    }

    .modal-body label {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-bottom: 6px;
      font-size: 11px;
      color: var(--ink-soft);
    }

    .modal-body input,
    .modal-body select,
    .modal-body textarea {
      border-radius: 8px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: var(--ink);
      padding: 5px 7px;
      font-size: 12px;
    }

    .modal-body textarea {
      resize: vertical;
      min-height: 60px;
    }

    .modal-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 4px;
    }

    .button-secondary,
    .button-danger,
    .button-primary {
      border-radius: 999px;
      border: none;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .button-secondary {
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(75, 85, 99, 0.9);
      color: var(--ink-soft);
    }

    .button-danger {
      background: rgba(127, 29, 29, 0.9);
      color: #fee2e2;
    }

    .button-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #f9fafb;
    }

    .toast {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.98);
      color: var(--ink);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 11px;
      z-index: 60;
      display: none;
    }

    .toast.show {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .toast span {
      font-size: 12px;
    }

    /* TikTok-style action loader */

    .action-loader {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 80px;
      z-index: 80;
      pointer-events: none;
      opacity: 0;
      transform: translateY(16px);
      transition: opacity 0.18s ease-out, transform 0.18s ease-out;
    }

    .action-loader.show {
      opacity: 1;
      transform: translateY(0);
    }

    .action-loader-inner {
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 999px;
      background: radial-gradient(circle at top left,
          rgba(15, 23, 42, 0.98),
          rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.65);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(16px);
      font-size: 12px;
    }

    .loader-spinner {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid rgba(75, 85, 99, 0.8);
      border-top-color: var(--accent-soft);
      animation: spin 0.7s linear infinite;
    }

    .action-loader-text-main {
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .action-loader-text-sub {
      display: block;
      font-size: 11px;
      color: var(--ink-soft);
      margin-top: 1px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .theme-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--ink-soft);
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    .theme-toggle select {
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: var(--panel);
      color: var(--ink);
      padding: 3px 8px;
      font-size: 11px;
    }

    .goal-delete-btn {
      border: none;
      background: transparent;
      color: var(--accent-muted);
      font-size: 10px;
      cursor: pointer;
      padding: 0 2px;
      white-space: nowrap;
    }

    .goal-delete-btn:hover {
      color: var(--danger);
    }

    /* ================================
       Light Theme (Day) readability overrides
       ================================ */

    body:not([data-theme="dark"]) .panel-header {
      border-bottom: 1px solid #e5e7eb;
    }

    /* Calendar controls */
    body:not([data-theme="dark"]) .calendar-controls button,
    body:not([data-theme="dark"]) .calendar-controls select,
    body:not([data-theme="dark"]) #weekly-prev,
    body:not([data-theme="dark"]) #weekly-next,
    body:not([data-theme="dark"]) .add-project-btn,
    body:not([data-theme="dark"]) .tip-box,
    body:not([data-theme="dark"]) .header-hint-box {
      background: #000000 !important;
      color: #ffffff !important;
      border: 1px solid #000000 !important;
    }

    body:not([data-theme="dark"]) .calendar-controls button:hover,
    body:not([data-theme="dark"]) #weekly-prev:hover,
    body:not([data-theme="dark"]) #weekly-next:hover,
    body:not([data-theme="dark"]) .add-project-btn:hover {
      background: #333333 !important;
    }

    body:not([data-theme="dark"]) .header-hint {
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .calendar-controls span.month-label {
      color: var(--ink);
    }

    /* Weekday row */
    body:not([data-theme="dark"]) .calendar-weekdays div {
      border-bottom: 1px solid #e5e7eb;
    }

    /* Calendar day cells + tasks */
    body:not([data-theme="dark"]) .day-cell {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .task-pill {
      background: #f9fafb;
      border-color: #e5e7eb;
    }

    /* Goals columns & cards */
    body:not([data-theme="dark"]) .goal-column {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .goal-card {
      background: #f9fafb;
      border-color: #e5e7eb;
    }

    /* Inputs in goals area */
    body:not([data-theme="dark"]) .goals-controls input[type="month"],
    body:not([data-theme="dark"]) .goals-controls select,
    body:not([data-theme="dark"]) .goals-controls input[type="number"],
    body:not([data-theme="dark"]) .goal-progress input[type="number"],
    body:not([data-theme="dark"]) .goal-row-note textarea,
    body:not([data-theme="dark"]) .goal-add-form input,
    body:not([data-theme="dark"]) .goal-add-form select {
      background: #ffffff;
      border-color: #d1d5db;
      color: var(--ink);
    }

    /* Overlay & modal surfaces */
    body:not([data-theme="dark"]) .overlay {
      background: rgba(15, 23, 42, 0.3);
    }

    body:not([data-theme="dark"]) .overlay-panel,
    body:not([data-theme="dark"]) .modal-panel {
      background: #ffffff;
      border-color: #e5e7eb;
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .overlay-panel select,
    body:not([data-theme="dark"]) .modal-body input,
    body:not([data-theme="dark"]) .modal-body select,
    body:not([data-theme="dark"]) .modal-body textarea {
      background: #ffffff;
      border-color: #d1d5db;
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .modal {
      background: rgba(15, 23, 42, 0.3);
    }

    /* Secondary buttons + toast */
    body:not([data-theme="dark"]) .button-secondary {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #374151;
    }

    body:not([data-theme="dark"]) .toast {
      background: #111827;
      color: #f9fafb;
    }

    /* Goal subtasks - light mode */
    body:not([data-theme="dark"]) .goal-subtasks {
      border-top-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .goal-subtask-title {
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .goal-subtask-calendar-btn {
      color: #6b7280;
    }

    body:not([data-theme="dark"]) .goal-subtask-calendar-btn:hover {
      color: #03aae1;
    }

    body:not([data-theme="dark"]) .goal-subtask-calendar-btn.linked {
      color: #16a34a;
    }

    body:not([data-theme="dark"]) .goal-subtasks-toggle {
      color: #6b7280;
    }

    body:not([data-theme="dark"]) .goal-subtasks-toggle:hover {
      color: #03aae1;
    }

    body:not([data-theme="dark"]) .add-subtask-form input {
      background: #ffffff;
      border-color: #d1d5db;
      color: var(--ink);
    }

    body:not([data-theme="dark"]) .add-subtask-form button {
      background: #e5e7eb;
      color: #374151;
    }

    body:not([data-theme="dark"]) .add-subtask-form button:hover {
      background: #03aae1;
      color: #ffffff;
    }

    body:not([data-theme="dark"]) .goal-column-title-input {
      color: #6b7280;
    }

    /* Drag & drop feedback */
    .task-pill.dragging {
      opacity: 0.45;
    }

    .day-cell.drop-target {
      outline: 2px dashed var(--accent-soft);
      outline-offset: 2px;
    }

    #task-repeat-count-wrapper {
      transition: opacity 0.12s ease-out;
    }

    .modal-repeat-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .modal-repeat-row label {
      flex: 1 1 150px;
    }

    .modal-help-text,
    .field-hint {
      font-size: 10px;
      color: var(--ink-soft);
      margin-top: 2px;
    }

    .task-pill.completed .task-title {
      text-decoration: line-through;
      opacity: 0.7;
    }

    /* ===== Core Pillars (Elevate / Engage / Evolve / Excite) ===== */
    .draggable-section {
      margin-bottom: 15px;
    }

    .pillars-section {
      margin-top: 14px;
      padding-top: 10px;
      border-top: 1px dashed rgba(55, 65, 81, 0.45);
    }

    .pillars-header {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 12px;
      padding: 6px 2px 10px;
    }

    .pillars-kicker {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .pillars-sub {
      margin-top: 3px;
      font-size: 11px;
      color: var(--ink-soft);
    }

    .pillar-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 12px;
    }

    @media (max-width: 1100px) {
      .pillar-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 640px) {
      .pillar-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .pillar-card {
      background: var(--panel);
      border-radius: var(--radius-md);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow-md);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 400px;
    }

    .pillar-card-header {
      padding: 1.25rem;
      border-bottom: 1px solid var(--panel-border);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Top Borders matching BoardIdeas */
    .pillar-card.elevate {
      border-top: 4px solid var(--elevate);
    }

    .pillar-card.engage {
      border-top: 4px solid var(--engage);
    }

    .pillar-card.evolve {
      border-top: 4px solid var(--evolve);
    }

    .pillar-card.excite {
      border-top: 4px solid var(--excite);
    }

    .pillar-card.elevate .pillar-name {
      color: var(--elevate);
    }

    .pillar-card.engage .pillar-name {
      color: var(--engage);
    }

    .pillar-card.evolve .pillar-name {
      color: var(--evolve);
    }

    .pillar-card.excite .pillar-name {
      color: var(--excite);
    }

    .pillar-name {
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0.05em;
    }

    .pillar-add {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
      color: var(--ink);
    }

    .pillar-add:hover {
      opacity: 1;
    }

    .pillar-box {
      flex: 1;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      background: transparent;
      /* Removed the yellow block */
    }

    .pillar-task-row {
      background: rgba(2, 6, 23, 0.22);
      border: 1px solid rgba(15, 23, 42, 0.18);
      border-radius: 10px;
      padding: 8px 8px;
      cursor: pointer;
    }

    body[data-theme="dark"] .pillar-task-row {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .pillar-task-title {
      font-size: 12px;
      font-weight: 700;
      color: var(--ink);
      /* Was hardcoded #0f172a */
      line-height: 1.2;
    }

    .pillar-task-meta {
      margin-top: 4px;
      font-size: 11px;
      color: var(--ink-soft);
      /* Was hardcoded rgba */
      line-height: 1.25;
    }

    /* Dark Mode Input Fixes */
    body[data-theme="dark"] input,
    body[data-theme="dark"] select,
    body[data-theme="dark"] textarea {
      color: #ffffff !important;
      background: rgba(255, 255, 255, 0.1) !important;
      border-color: rgba(255, 255, 255, 0.3) !important;
    }

    body[data-theme="dark"] ::placeholder {
      color: rgba(255, 255, 255, 0.5) !important;
    }

    .pillar-empty {
      margin: auto 0;
      font-size: 12px;
      color: rgba(15, 23, 42, 0.8);
      text-align: center;
      padding: 10px 6px;
    }

    .pillar-circle-wrap {
      margin-top: auto;
      padding: 4px 12px 14px;
      display: flex;
      justify-content: center;
    }

    .pillar-circle {
      width: 150px;
      height: 150px;
      border-radius: 999px;
      background: var(--accent-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      color: #000000 !important;
      /* Force black text on light circle */
      border: 1px solid rgba(15, 23, 42, 0.18);
    }

    .pillar-circle strong {
      display: block;
      font-size: 28px;
      line-height: 1;
      margin-bottom: 6px;
    }

    .pillar-circle span {
      display: block;
      font-size: 12px;
      line-height: 1.2;
    }

    .pillar-task-row {
      background: rgba(255, 255, 255, 0.5);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .pillar-task-row:hover {
      background: rgba(255, 255, 255, 0.8);
    }

    .pillar-task-row.promo {
      background: #f0f9ff;
      border-left: 3px solid var(--accent);
    }

    .pillar-task-row.promo:hover {
      background: #e0f2fe;
    }

    /* View Options Toolbar */
    .view-options-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px;

      /* Match .panel style */
      background: var(--panel-elevated);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);

      margin-bottom: 24px;
      align-items: center;
      justify-content: space-between;
      /* Full width distribution */
    }

    .view-option {
      background: transparent;
      border: 1px solid var(--panel-border);
      color: var(--ink-soft);
      padding: 8px 16px;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      user-select: none;
      flex: 1;
      /* Grow to fill space */
      text-align: center;
      min-width: 140px;
      /* Prevent too smushed */
    }

    .view-option:hover {
      background: var(--bg-main);
      color: var(--ink);
      border-color: var(--ink-soft);
    }

    .view-option.active {
      background: rgba(3, 170, 225, 0.15);
      color: var(--accent);
      border-color: var(--accent);
      box-shadow: none;
    }

    .view-option.active::after {
      content: "âœ“";
      font-weight: bold;
      margin-left: 6px;
    }

    .drag-handle {
      margin-left: 4px;
      color: var(--ink-soft);
      font-size: 14px;
      opacity: 0.4;
      cursor: grab;
      line-height: 1;
    }

    .view-option:hover .drag-handle {
      opacity: 0.8;
      color: var(--theme-primary);
    }

    /* Dashboard Layout Overhaul (Flex) */
    #sections-container {
      display: flex;
      flex-wrap: wrap;
      margin: -10px;
      /* Negative margin for gutter */
    }

    .draggable-section {
      margin: 10px;
      width: calc(100% - 20px);
      /* Default full width */
      box-sizing: border-box;
    }

    /* Row 1: Daily Tasks (60%) & Backlog (40%) */
    @media (min-width: 1025px) {
      #section-daily-tasks {
        width: calc(60% - 20px);
      }

      #section-backlog {
        width: calc(40% - 20px);
      }

      /* Row 2: Gamification (Full) */
      #section-gamification {
        width: calc(100% - 20px);
      }

      /* Row 3: Strategy (50%) & Projects (50%) */
      #section-weekly-strategy {
        width: calc(50% - 20px);
      }

      #section-projects {
        width: calc(50% - 20px);
      }
    }

    .panel {
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      border: 1px solid var(--panel-border);
    }
  </style>
  <!-- Fireworks Library -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <!-- Chart.js for Metrics -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* Gamification Overlay */
    .celebration-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      background: rgba(255, 255, 255, 0.95);
      padding: 24px 48px;
      border-radius: 24px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      text-align: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .celebration-overlay.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .celebration-emoji {
      font-size: 48px;
      margin-bottom: 12px;
      display: block;
      animation: bounce 1s infinite;
    }

    .celebration-text {
      font-size: 28px;
      font-weight: 800;
      background: linear-gradient(135deg, #03aae1 0%, #a855f7 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 4px;
      letter-spacing: -0.02em;
    }

    .celebration-sub {
      font-size: 15px;
      font-weight: 500;
      color: var(--ink-soft);
    }

    body[data-theme="dark"] .celebration-overlay {
      background: rgba(15, 23, 42, 0.95);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-10px);
      }
    }

    /* ===== COIN REWARD SYSTEM ===== */
    .coin-counter-wrap {
      display: none;
      /* Hidden by default */
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .coin-counter-wrap.visible {
      display: flex;
    }

    .coin-counter {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      border: 2px solid #d97706;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      font-size: 14px;
      font-weight: 700;
      color: #78350f;
      cursor: default;
      user-select: none;
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .coin-caps {
      display: flex;
      gap: 8px;
      font-size: 10px;
      color: var(--ink-soft);
      opacity: 0.8;
    }

    .coin-caps span {
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
    }

    body[data-theme="dark"] .coin-caps span {
      background: rgba(255, 255, 255, 0.1);
    }

    .coin-counter:hover {
      transform: scale(1.05);
    }

    .coin-counter:hover {
      transform: scale(1.05);
    }

    .coin-counter.pulse {
      animation: coinPulse 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .coin-icon {
      font-size: 18px;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
    }

    .coin-amount {
      min-width: 24px;
      text-align: center;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    @keyframes coinPulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.15);
      }

      100% {
        transform: scale(1);
      }
    }

    /* Shake animation for coin deduction */
    .coin-counter.shake {
      animation: coinShake 0.4s ease-in-out;
    }

    @keyframes coinShake {

      0%,
      100% {
        transform: translateX(0);
      }

      20% {
        transform: translateX(-5px);
      }

      40% {
        transform: translateX(5px);
      }

      60% {
        transform: translateX(-3px);
      }

      80% {
        transform: translateX(3px);
      }
    }

    /* --- BIRD SYSTEM CSS --- */
    .bird-system-container {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      padding: 0 5px 5px;
      gap: 15px;
      height: 160px;
      /* Force height to accommodate bird and pie */
    }

    .bird-wrapper {
      position: relative;
      width: 110px;
      height: 120px;
      cursor: grab;
      flex-shrink: 0;
      /* background: rgba(0,0,0,0.02); Debug area */
      border-radius: 50%;
    }

    .bird-wrapper:active {
      cursor: grabbing;
    }

    /* Hearts for petting */
    .pet-heart {
      position: absolute;
      font-size: 20px;
      color: #ec4899;
      /* Excite pink */
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
      opacity: 0;
      z-index: 10;
    }

    @keyframes birdJump {

      0%,
      100% {
        transform: translateY(0) scale(1) rotate(0deg);
      }

      30% {
        transform: translateY(-8px) scale(1.05) rotate(-3deg);
      }

      50% {
        transform: translateY(0) scale(0.98) rotate(0deg);
      }

      70% {
        transform: translateY(-4px) scale(1.02) rotate(3deg);
      }
    }

    @keyframes wingFlapL {

      0%,
      100% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(20deg);
      }

      50% {
        transform: rotate(-10deg);
      }

      75% {
        transform: rotate(20deg);
      }
    }

    @keyframes wingFlapR {

      0%,
      100% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(-20deg);
      }

      50% {
        transform: rotate(10deg);
      }

      75% {
        transform: rotate(-20deg);
      }
    }

    .bird-celebrating .bird-anim-wrapper {
      animation: birdJump 0.6s ease-in-out infinite;
      transform-origin: center bottom;
    }

    .bird-celebrating .bird-wing-l {
      animation: wingFlapL 0.2s ease-in-out infinite;
      transform-origin: 100% 50%;
      transform-box: fill-box;
      /* Pivot from body connection */
    }

    .bird-celebrating .bird-wing-r {
      animation: wingFlapR 0.2s ease-in-out infinite;
      transform-origin: 0% 50%;
      transform-box: fill-box;
      /* Pivot from body connection */
    }

    @keyframes floatUp {
      0% {
        transform: translateY(0) scale(0.5);
        opacity: 1;
      }

      100% {
        transform: translateY(-40px) scale(1.2);
        opacity: 0;
      }
    }

    /* Edit Bird Button */
    .edit-bird-btn {
      position: absolute;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel-elevated);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      box-shadow: var(--shadow-md);
      z-index: 20;
    }

    .bird-wrapper:hover .edit-bird-btn {
      opacity: 1;
      bottom: -5px;
    }

    .edit-bird-btn:hover {
      transform: translateX(-50%) scale(1.1);
      background: var(--bg-main);
    }

    /* Bird Editor Modal */
    .bird-editor-layout {
      display: flex;
      gap: 20px;
      padding: 10px;
    }

    .bird-preview-col {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-main);
      border-radius: var(--radius-md);
      padding: 20px;
    }

    .bird-controls-col {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 400px;
      overflow-y: auto;
    }

    .color-control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .color-control-group label {
      font-size: 11px;
      font-weight: 600;
      color: var(--ink-soft);
      text-transform: uppercase;
    }

    .color-picker-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .color-input-styled {
      appearance: none;
      -webkit-appearance: none;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      overflow: hidden;
      cursor: pointer;
      padding: 0;
      background: none;
    }

    .color-input-styled::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    .color-input-styled::-webkit-color-swatch {
      border: 2px solid var(--panel-border);
      border-radius: 50%;
    }

    /* Daily Energy Meter */
    /* Daily Energy Meter - Horizontal */
    .coin-meter-container {
      flex: 1;
      margin: 0 15px 25px;
      /* Align with bird feet */
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
    }

    .coin-meter {
      width: 100%;
      height: 24px;
      background: rgba(0, 0, 0, 0.06);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
    }

    body[data-theme="dark"] .coin-meter {
      background: rgba(255, 255, 255, 0.1);
    }

    .coin-meter-fill {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      /* Horizontal fill */
      background: linear-gradient(to right, #fbbf24, #f59e0b);
      border-radius: 12px;
      transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
    }

    .coin-meter-label {
      text-align: center;
      font-size: 11px;
      font-weight: 600;
      color: var(--ink-soft);
      margin-top: 4px;
    }

    /* Flying coin sprites - use JS animation instead of CSS */
    .flying-coin {
      position: fixed;
      font-size: 28px;
      z-index: 10001;
      pointer-events: none;
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.4));
      transition: none;
    }

    @keyframes coinFly {
      0% {
        transform: translate(0, 0) scale(1) rotate(0deg);
        opacity: 1;
      }

      30% {
        transform: translate(calc(var(--dx) * 0.3), calc(var(--dy) * 0.3 - 40px)) scale(1.2) rotate(180deg);
        opacity: 1;
      }

      100% {
        transform: translate(var(--dx), var(--dy)) scale(0.5) rotate(720deg);
        opacity: 0.8;
      }
    }

    @keyframes coinBurst {
      0% {
        transform: scale(0) rotate(0deg);
        opacity: 0;
      }

      50% {
        transform: scale(1.3) rotate(180deg);
        opacity: 1;
      }

      100% {
        transform: scale(1) rotate(360deg);
        opacity: 1;
      }
    }

    .coin-burst {
      animation: coinBurst 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    /* Task Reminder Container - fixed position, stacks children vertically */
    .reminder-container {
      position: fixed;
      top: 80px;
      right: 16px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 360px;
    }

    /* Individual reminder banner */
    .reminder-banner {
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border: 2px solid #f59e0b;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(245, 158, 11, 0.3);
      animation: slideInRight 0.3s ease-out;
    }

    /* Overdue reminder style */
    .reminder-banner.overdue {
      background: linear-gradient(135deg, #fee2e2, #fecaca);
      border: 2px solid #ef4444;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(239, 68, 68, 0.3);
    }

    .reminder-banner.hidden {
      display: none;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .reminder-content {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
    }

    .reminder-icon {
      font-size: 28px;
      animation: shake 0.5s ease-in-out infinite;
    }

    @keyframes shake {

      0%,
      100% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(-10deg);
      }

      75% {
        transform: rotate(10deg);
      }
    }

    .reminder-text {
      flex: 1;
    }

    .reminder-title {
      font-weight: 700;
      font-size: 14px;
      color: #92400e;
      margin-bottom: 2px;
    }

    .reminder-time {
      font-size: 12px;
      color: #b45309;
    }

    .reminder-buttons {
      display: flex;
      gap: 6px;
    }

    .reminder-snooze {
      background: rgba(146, 64, 14, 0.2);
      color: #92400e;
      border: 1px solid #92400e;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .reminder-snooze:hover {
      background: rgba(146, 64, 14, 0.3);
    }

    .reminder-dismiss {
      background: #f59e0b;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .reminder-dismiss:hover {
      background: #d97706;
    }

    /* Checkbox list for assignees */
    .checkbox-list {
      border: 1px solid #d1d5db;
      border-radius: 6px;
      padding: 8px;
      max-height: 120px;
      overflow-y: auto;
      background: #fff;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .checkbox-list label {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      cursor: pointer;
      margin: 0;
      font-weight: normal;
      white-space: nowrap;
    }

    .checkbox-list label input[type="checkbox"] {
      margin: 0;
      flex-shrink: 0;
    }


    /* Bird System Layout */
    .bird-system-container {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      padding: 15px;
      background: var(--panel);
      border-radius: 8px;
      margin: 10px;
    }

    .bird-wrapper {
      position: relative;
      width: 100px;
      height: 100px;
      flex-shrink: 0;
      overflow: visible;
      /* Allow speech bubble to overflow */
    }

    #finch-svg {
      width: 100%;
      height: 100%;
    }

    /* Pet Animation */
    @keyframes pet-float {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-3px);
      }
    }

    .pet-anim {
      animation: pet-float 3s ease-in-out infinite;
    }

    /* Coin Meter (Horizontal) */
    .coin-meter-container {
      width: 200px;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .coin-meter {
      width: 100%;
      height: 12px !important;
      min-height: 12px !important;
      background: rgba(0, 0, 0, 0.1) !important;
      border-radius: 999px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .coin-meter-fill {
      height: 100%;
      width: 0%;
      background: #eab308;
      /* Fallback */
      background: linear-gradient(90deg, #facc15, #eab308);
      border-radius: 999px;
      transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      min-width: 4px;
      /* Ensure visibility even at near-0 */
    }

    .coin-meter-label {
      font-size: 11px;
      color: var(--ink-soft);
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    /* Coin Sprite Animation - FIXED OVERRIDE */
    .flying-coin {
      position: fixed !important;
      width: 32px !important;
      height: 32px !important;
      pointer-events: none;
      z-index: 2147483647 !important;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      will-change: transform, left, top;
      left: 0;
      top: 0;
    }

    /* Bird Speech Bubble - Finch Style (positioned to right of bird) */
    .speech-bubble {
      position: absolute;
      top: 50%;
      left: 100%;
      transform: translateY(-50%) translateX(10px);
      background: linear-gradient(135deg, #fef9c3 0%, #fef3c7 100%);
      border: 2px solid #fbbf24;
      color: #78350f;
      padding: 10px 14px;
      border-radius: 16px;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(251, 191, 36, 0.3), 0 2px 4px rgba(0, 0, 0, 0.1);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      min-width: 80px;
      text-align: center;
    }

    .speech-bubble.visible {
      opacity: 1;
      transform: translateY(-50%) translateX(15px);
    }

    /* Arrow pointing left toward the bird */
    .speech-bubble::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 100%;
      margin-top: -8px;
      border-width: 8px;
      border-style: solid;
      border-color: transparent #fbbf24 transparent transparent;
    }

    .speech-bubble::before {
      content: '';
      position: absolute;
      top: 50%;
      right: 100%;
      margin-top: -6px;
      margin-right: -2px;
      border-width: 6px;
      border-style: solid;
      border-color: transparent #fef9c3 transparent transparent;
      z-index: 1;
    }

    /* Mute Button - Subtle circular icon */
    .bird-mute-btn {
      position: absolute;
      top: -5px;
      right: -5px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.08);
      font-size: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, transform 0.1s, background 0.2s;
      z-index: 10;
      padding: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    #finch-container:hover .bird-mute-btn {
      opacity: 0.6;
    }

    .bird-mute-btn:hover {
      opacity: 1 !important;
      background: #fff;
      transform: scale(1.1);
    }

    .bird-mute-btn.muted {
      opacity: 0.8;
      background: #fee2e2;
      color: #ef4444;
      border-color: #fca5a5;
    }

    /* Edit Bird Button - Subtle icon that appears on hover */
    .edit-bird-btn {
      position: absolute;
      bottom: -5px;
      right: -5px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.08);
      font-size: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, transform 0.1s, background 0.2s;
      z-index: 10;
      padding: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    #finch-container:hover .edit-bird-btn {
      opacity: 0.6;
    }

    .edit-bird-btn:hover {
      opacity: 1 !important;
      background: #fff;
      transform: scale(1.1);
    }

    /* ===== SHOP MODAL STYLES ===== */
    .shop-tabs {
      display: flex;
      border-bottom: 1px solid #e5e7eb;
    }

    .shop-tab {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      font-size: 14px;
      font-weight: 500;
      color: #6b7280;
      cursor: pointer;
      transition: all 0.2s;
    }

    .shop-tab:hover {
      background: #f9fafb;
    }

    .shop-tab.active {
      color: #2563eb;
      border-bottom: 2px solid #2563eb;
      margin-bottom: -1px;
    }

    .shop-content {
      padding: 16px;
      max-height: 400px;
      overflow-y: auto;
    }

    .shop-tab-content.hidden {
      display: none;
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
    }

    .shop-item {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .shop-item:hover {
      border-color: #2563eb;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.1);
      transform: translateY(-2px);
    }

    .shop-item.owned {
      border-color: #22c55e;
      background: #f0fdf4;
    }

    .shop-item.equipped {
      border-color: #f59e0b;
      background: #fffbeb;
    }

    .shop-item-preview {
      width: 60px;
      height: 60px;
      margin: 0 auto 8px;
      background: #f3f4f6;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shop-item-preview svg {
      width: 40px;
      height: 40px;
    }

    .shop-item-name {
      font-size: 13px;
      font-weight: 500;
      color: #1f2937;
      margin-bottom: 4px;
    }

    .shop-item-price {
      font-size: 12px;
      color: #6b7280;
    }

    .shop-item-price .coin {
      color: #fbbf24;
    }

    .shop-item-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 600;
    }

    .shop-item-badge.owned {
      background: #22c55e;
      color: #fff;
    }

    .shop-item-badge.equipped {
      background: #f59e0b;
      color: #fff;
    }

    /* Shop Button in bird area */
    .shop-bird-btn {
      position: absolute;
      bottom: -5px;
      left: -5px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.08);
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, transform 0.1s;
      z-index: 10;
      padding: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    #finch-container:hover .shop-bird-btn {
      opacity: 0.6;
    }

    .shop-bird-btn:hover {
      opacity: 1 !important;
      transform: scale(1.1);
    }

    /* Header Bird Controls */
    .header-bird-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 12px;
      margin-right: 12px;
      padding-left: 12px;
      border-left: 1px solid var(--panel-border);
    }

    .header-icon-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--panel-border);
      font-size: 14px;
      cursor: pointer;
      padding: 0 12px;
      border-radius: 99px;
      color: var(--ink-soft);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      width: auto !important;
      height: 32px;
      gap: 6px;
    }

    .btn-label {
      font-size: 12px;
      font-weight: 500;
    }

    .btn-icon {
      font-size: 14px;
      display: flex;
    }

    .header-icon-btn:hover {
      background: var(--bg-main);
      color: var(--ink);
      transform: scale(1.1);
      border-color: var(--accent);
    }

    /* Override previous absolute positioning for buttons moved to header */
    #bird-mute-btn.header-icon-btn,
    #edit-bird-trigger.header-icon-btn {
      position: static !important;
      opacity: 1 !important;
    }

    /* Make coin wrapper interactive */
    .coin-counter-wrap {
      cursor: pointer;
      transition: transform 0.2s;
    }

    .coin-counter-wrap:hover {
      transform: scale(1.02);
    }

    .coin-counter-wrap:active {
      transform: scale(0.98);
    }

    /* Weekly Planner Styles */
    .weekly-section-header {
      font-size: 15px;
      font-weight: 700;
      color: #06b6d4;
      /* Cyan color from screenshot */
      margin-top: 20px;
      margin-bottom: 8px;
    }

    .weekly-grid {
      display: grid;
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-md);
      overflow: hidden;
      background: var(--panel);
      /* Remove fixed height to allow expansion */
      height: auto;
    }

    .weekly-cell {
      padding: 8px;
      border-right: 1px solid var(--panel-border);
      border-bottom: 1px solid var(--panel-border);
      font-size: 12px;
      position: relative;
      /* Auto height */
      height: auto;
      min-height: 50px;
      display: flex;
      flex-direction: column;
    }

    .weekly-cell textarea {
      width: 100%;
      height: 100%;
      min-height: 48px;
      /* Ensure space for text */
      border: none;
      background: transparent;
      resize: vertical;
      /* Allow resize */
      font-family: inherit;
      font-size: inherit;
      color: var(--ink);
      outline: none;
      overflow: hidden;
      /* Hide scrollbars */
      line-height: 1.4;
    }

    .weekly-cell.header {
      background: var(--panel-elevated);
      font-weight: 600;
      color: var(--ink-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    /* User Column Colors */
    .user-col-erica {
      background: rgba(236, 72, 153, 0.05);
    }

    .user-col-katie {
      background: rgba(59, 130, 246, 0.05);
    }

    .user-col-kevin {
      background: rgba(16, 185, 129, 0.05);
    }

    .user-col-jenna {
      background: rgba(245, 158, 11, 0.05);
    }

    .user-col-meighan {
      background: rgba(139, 92, 246, 0.05);
    }

    .user-col-melodie {
      background: rgba(249, 115, 22, 0.05);
    }

    body[data-theme="dark"] .user-col-erica {
      background: rgba(236, 72, 153, 0.1);
    }

    body[data-theme="dark"] .user-col-katie {
      background: rgba(59, 130, 246, 0.1);
    }

    body[data-theme="dark"] .user-col-kevin {
      background: rgba(16, 185, 129, 0.1);
    }

    body[data-theme="dark"] .user-col-jenna {
      background: rgba(245, 158, 11, 0.1);
    }

    body[data-theme="dark"] .user-col-meighan {
      background: rgba(139, 92, 246, 0.1);
    }

    body[data-theme="dark"] .user-col-melodie {
      background: rgba(249, 115, 22, 0.1);
    }

    .weekly-cell.row-header {
      background: #f1f5f9;
      /* Slightly darker gray for row headers */
      font-weight: 700;
      color: #334155;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding-left: 10px;
    }

    .weekly-cell textarea {
      width: 100%;
      height: 100%;
      min-height: 24px;
      background: transparent;
      border: none;
      color: var(--ink);
      resize: none;
      font-family: inherit;
      outline: none;
    }

    .weekly-cell textarea:focus {
      background: rgba(255, 255, 255, 0.05);
    }

    /* Header Ticker Styles */
    #header-ticker-container {
      width: 100%;
      height: 32px;
      background: linear-gradient(90deg, #0f172a, #1e293b, #0f172a);
      display: flex;
      align-items: center;
      position: relative;
      overflow: hidden;
      border-bottom: 1px solid rgba(51, 65, 85, 0.5);
      margin-bottom: 20px;
      /* Spacing before main content */
      mask-image: linear-gradient(to right, transparent, black 5%, black 95%, transparent);
      -webkit-mask-image: linear-gradient(to right, transparent, black 10%, black 90%, transparent);
    }

    .header-default-sub {
      color: var(--ink-soft);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.1em;
      width: 100%;
      text-align: center;
    }

    .ticker-card {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 3px 16px;
      background: rgba(30, 41, 59, 1);
      border: 1px solid rgba(56, 189, 248, 0.2);
      border-radius: 999px;
      font-size: 11px;
      color: #e2e8f0;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);

      position: absolute;
      left: 0;
      white-space: nowrap;
      cursor: pointer;
      will-change: transform;
    }

    .ticker-card.zoomed {
      z-index: 10;
      border-color: rgba(56, 189, 248, 0.6);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
      /* Transform is handled by JS loop now, class just adds style overrides */
    }

    .ticker-user {
      font-weight: 700;
      color: #38bdf8;
    }

    .ticker-task {
      color: #f8fafc;
      font-weight: 500;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .ticker-time {
      color: #94a3b8;
      font-size: 9px;
      margin-left: 4px;
    }

    .ticker-reactions {
      display: flex;
      gap: 4px;
      margin-left: 8px;
    }

    .ticker-reaction-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
      font-size: 12px;
      transition: transform 0.2s;
    }

    .ticker-reaction-btn:hover {
      transform: scale(1.5);
    }

    .ticker-reaction-count {
      font-size: 9px;
      margin-left: 1px;
      color: #cbd5e1;
    }

    /* Backlog Compact Style */
    .backlog-pill .task-title {
      font-size: 11px !important;
      line-height: 1.3;
    }

    .backlog-pill {
      padding: 8px !important;
      min-height: 60px;
    }
  </style>
</head>

<body>

  <!-- Task Ticker -->

  <!-- User chooser -->
  <div id="user-overlay" class="overlay">
    <div class="overlay-panel">
      <h2>Whoâ€™s on the Wrap?</h2>
      <p>Select your name so we know whoâ€™s assigning and completing tasks.</p>
      <select id="user-select">
        <option value="">Loading team...</option>
      </select>
      <button id="user-select-confirm">Open Wrap Sheet</button>
      <small>This is internal for BER: Meighan, Kevin, Erica, Jenna, Katie & Melodie.</small>
    </div>
  </div>

  <!-- Bird Editor Modal -->
  <div class="overlay" id="bird-editor-modal" style="display:none;">
    <div class="modal-panel" style="width: 600px; max-width: 90vw;">
      <div class="modal-header">
        <div class="modal-title">Customize Your Bird</div>
        <button class="modal-close" id="close-bird-editor">Ã—</button>
      </div>
      <div class="bird-editor-layout">
        <!-- Left: Preview -->
        <div class="bird-preview-col">
          <div style="width:180px; height:180px;">
            <svg id="bird-editor-preview" viewBox="0 0 200 200" style="width:100%; height:100%; overflow:visible;">
              <!-- JS will copy bird SVG here -->
            </svg>
          </div>
          <div id="bird-preview-label"
            style="margin-top:10px; font-size:11px; color:var(--ink-soft); text-align:center;">
            Preview
          </div>
        </div>

        <!-- Right: Controls -->
        <div class="bird-controls-col">
          <label class="bird-name-label">
            Name Your Bird
            <input type="text" id="bird-name-input" placeholder="e.g. Chirpy" maxlength="15"
              style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; font-size:14px; margin-bottom:15px; text-transform:capitalize;">
          </label>
          <div id="bird-color-controls">
            <!-- JS will inject color pickers here -->
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button-secondary" id="cancel-bird-editor">Cancel</button>
        <button class="button-primary" id="save-bird-editor">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Bird Shop Modal -->
  <div id="shop-modal" class="modal hidden">
    <div class="modal-panel" style="max-width:600px;">
      <div class="modal-header">
        <div class="modal-title">ðŸ›’ Bird Shop</div>
        <div id="shop-balance" style="margin-left:auto;margin-right:16px;font-size:14px;color:var(--accent);">ðŸ’° 0
        </div>
        <button class="modal-close" id="shop-modal-close">&times;</button>
      </div>
      <div class="shop-tabs">
        <button class="shop-tab active" data-tab="shop">Shop</button>
        <button class="shop-tab" data-tab="inventory">My Items</button>
      </div>
      <div class="modal-body" style="max-height:400px;overflow-y:auto;">
        <div id="shop-tab-content">
          <div id="shop-items-grid" class="shop-grid"></div>
        </div>
        <div id="inventory-tab-content" style="display:none;">
          <div id="inventory-grid" class="shop-grid"></div>
          <div id="inventory-empty" style="text-align:center;color:var(--ink-soft);padding:20px;">
            No items purchased yet. Visit the shop to buy some!
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Task modal -->

  <div id="task-modal" class="modal hidden">
    <div class="modal-panel">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="task-modal-title">New Task</div>
          <div id="task-modal-date" style="font-size:11px;color:#9ca3af;"></div>
        </div>
        <button class="modal-close" id="task-modal-close">&times;</button>
      </div>

      <div class="modal-body">
        <input type="hidden" id="task-id" />
        <input type="hidden" id="task-series-id" />

        <label>
          Title
          <input id="task-title-input" placeholder="e.g., TTT: Market Reports video" />
        </label>

        <label>
          Notes
          <textarea id="task-notes-input" placeholder="Optional detailsâ€¦"></textarea>
        </label>

        <label>
          Scheduled Time <span style="font-weight:normal;color:#9ca3af;">(optional)</span>
          <input id="task-time-input" type="time" style="width:150px;" />
          <div class="field-hint">Set a time to get a reminder 30 minutes before.</div>
        </label>

        <!-- New: Color & Priority -->
        <div style="display:flex; gap:15px; margin-bottom:15px;">
          <label style="flex:1;">
            Color
            <select id="task-color">
              <option value="">Default (None)</option>
              <option value="#f43f5e">Excite (Pink)</option>
              <option value="#3b82f6">Engage (Blue)</option>
              <option value="#10b981">Empower (Green)</option>
              <option value="#06b6d4">Tools (Teal)</option>
              <option value="#8b5cf6">Focus (Violet)</option>
              <option value="#f59e0b">Growth (Amber)</option>
            </select>
          </label>

          <label style="flex:1;">
            Priority
            <select id="task-priority">
              <option value="1">Low â˜•</option>
              <option value="2">Medium âš¡</option>
              <option value="3">High ðŸ”¥</option>
            </select>
          </label>
        </div>

        <!-- Repeat controls â€“ enhanced -->
        <label>
          Repeat
          <select id="task-repeat-type">
            <option value="none">Do not repeat</option>
            <option value="daily">Daily (Monâ€“Fri)</option>
            <option value="weekly">Weekly (same weekday)</option>
            <option value="biweekly">Biweekly (every 2 weeks)</option>
            <option value="monthly_date">Monthly â€“ same date (1st, 14thâ€¦)</option>
            <option value="monthly_weekday">Monthly â€“ same weekday pattern (1st Monday)</option>
            <option value="yearly">Yearly (same date)</option>
          </select>
        </label>

        <div class="modal-repeat-row">
          <label>
            Series start
            <input id="task-repeat-start" type="date" />
          </label>
          <label>
            Series end
            <input id="task-repeat-end" type="date" />
          </label>
        </div>

        <div class="modal-help-text">
          For monthly repeats, create the first task on the date you want
          (e.g. the 1st or the 1st Monday), then set an end date for the series.
          If the monthly date lands on a weekend, it will shift to a nearby weekday.
          <br><br>
          <strong>Series Tracking:</strong> All tasks in a series will be linked together,
          allowing you to delete the entire series at once if needed.
        </div>

        <label>
          Assigned To
          <select id="task-assigned-to"></select>
        </label>

        <label>
          Additional Assignees
          <div id="task-assignees-container" class="checkbox-list"></div>
          <div class="field-hint">
            Check multiple people to share this task.
          </div>
        </label>

        <label>
          Status
          <select id="task-status-input">
            <option value="pending">Pending</option>
            <option value="in_progress">In Progress</option>
            <option value="done">Done</option>
            <option value="could_not_complete">Could not complete</option>
          </select>
        </label>
      </div>

      <div class="modal-footer">
        <button class="button-secondary" id="task-modal-cancel">Cancel</button>
        <div style="display:flex;gap:6px;align-items:center;">
          <button class="button-danger" id="task-delete-btn" style="display:none;">Delete</button>
          <button class="button-primary" id="task-save-btn">Save Task</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Delete Confirmation Modal -->
  <div id="delete-confirm-modal" class="modal hidden">
    <div class="modal-panel" style="width: min(400px, 100% - 32px);">
      <div class="modal-header">
        <div class="modal-title">Delete Task</div>
        <button class="modal-close" id="delete-confirm-close">Ã—</button>
      </div>
      <div class="modal-body">
        <p id="delete-confirm-message" style="margin-bottom: 16px;"></p>
        <div id="delete-confirm-options" style="display:none; margin-bottom: 12px;">
          <label style="display:flex; gap:8px; align-items:center; margin-bottom:8px; cursor:pointer;">
            <input type="radio" name="delete-choice" value="one" checked />
            <span>Delete only this task</span>
          </label>
          <label style="display:flex; gap:8px; align-items:center; cursor:pointer;">
            <input type="radio" name="delete-choice" value="all" />
            <span id="delete-all-label">Delete all matching tasks</span>
          </label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button-secondary" id="delete-confirm-cancel">Cancel</button>
        <button class="button-danger" id="delete-confirm-yes">Delete</button>
      </div>
    </div>
  </div>

  <!-- Goal Create Modal -->
  <div id="goal-create-modal" class="modal hidden">
    <div class="modal-panel" style="width: min(500px, 100% - 32px);">
      <div class="modal-header">
        <div class="modal-title" id="goal-create-modal-title">New Goal</div>
        <button class="modal-close" id="goal-create-modal-close">Ã—</button>
      </div>
      <div class="modal-body">
        <label>
          Goal Name
          <input id="create-goal-title" placeholder="e.g., Q1 Marketing Push" />
        </label>

        <label>
          Header / Notes
          <textarea id="create-goal-desc" placeholder="Details about this goal..." style="min-height: 60px;"></textarea>
        </label>

        <label>
          Subtasks
          <div id="create-goal-subtasks-list" class="transient-subtasks">
            <!-- Subtask inputs added here -->
          </div>
          <div class="subtask-row-new">
            <input id="new-subtask-input" placeholder="Add a subtask..." style="flex:1;" />
            <button class="button-secondary" id="btn-add-transient-subtask" style="padding:4px 8px;">+</button>
          </div>
        </label>

        <!-- Advanced Fields Container -->
        <div id="create-goal-advanced"
          style="display:flex; flex-direction:column; gap:8px; border-top:1px solid var(--panel-border); padding-top:8px; margin-top:4px;">
          <label id="create-goal-committee-wrapper">
            Committee / Workgroup
            <select id="create-goal-committee">
              <option value="">(None)</option>
              <option value="Events Workgroup">Events Workgroup</option>
              <option value="Global Diversity Workgroup">Global Diversity Workgroup</option>
              <option value="Government Affair/RPAC Workgroup">Government Affair/RPAC Workgroup</option>
              <option value="Grievance">Grievance</option>
              <option value="Media (Brokers ONLY)">Media (Brokers ONLY)</option>
              <option value="MLS Committee">MLS Committee</option>
              <option value="Professional Development Workgroup">Professional Development Workgroup</option>
              <option value="Professional Standards">Professional Standards</option>
              <option value="Realtor Review Workgroup">Realtor Review Workgroup</option>
              <option value="YPN Workgroup">YPN Workgroup</option>
              <option value="Leadership Development Committee">Leadership Development Committee</option>
              <option value="Leadership Academy">Leadership Academy</option>
            </select>
          </label>

          <div id="create-goal-parent-wrapper">
            <label>
              Linked Annual Goal
              <select id="create-goal-parent">
                <option value="">(None)</option>
              </select>
            </label>
          </div>

          <label>
            Assignees
            <div id="create-goal-assignees-grid" class="assignee-grid">
              <!-- Populated by JS -->
            </div>
          </label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button-secondary" id="goal-create-modal-cancel">Cancel</button>
        <button class="button-primary" id="goal-create-save-btn">Create Goal</button>
      </div>
    </div>
  </div>

  <!-- Goal Edit Modal (Advanced) -->
  <div id="goal-edit-modal" class="modal hidden">
    <div class="modal-panel">
      <div class="modal-header">
        <div class="modal-title" id="goal-edit-modal-title">Edit Goal</div>
        <button class="modal-close" id="goal-edit-modal-close">Ã—</button>
      </div>
      <div class="modal-body">
        <label>
          Committee / Workgroup
          <select id="goal-edit-committee">
            <option value="">(None)</option>
            <option value="Events Workgroup">Events Workgroup</option>
            <option value="Global Diversity Workgroup">Global Diversity Workgroup</option>
            <option value="Government Affair/RPAC Workgroup">Government Affair/RPAC Workgroup</option>
            <option value="Grievance">Grievance</option>
            <option value="Media (Brokers ONLY)">Media (Brokers ONLY)</option>
            <option value="MLS Committee">MLS Committee</option>
            <option value="Professional Development Workgroup">Professional Development Workgroup</option>
            <option value="Professional Standards">Professional Standards</option>
            <option value="Realtor Review Workgroup">Realtor Review Workgroup</option>
            <option value="YPN Workgroup">YPN Workgroup</option>
            <option value="Leadership Development Committee">Leadership Development Committee</option>
            <option value="Leadership Academy">Leadership Academy</option>
          </select>
        </label>
        <div id="goal-edit-parent-wrapper">
          <label>
            Linked Annual Goal
            <select id="goal-edit-parent">
              <option value="">(None)</option>
            </select>
          </label>
        </div>
        <label>
          Assignees (Multi-select)
          <div id="goal-edit-assignees-list"
            style="max-height: 120px; overflow-y: auto; border: 1px solid var(--panel-border); border-radius: 8px; padding: 4px; background: rgba(15,23,42,0.3);">
            <!-- Checkboxes injected by JS -->
          </div>
        </label>
      </div>
      <div class="modal-footer">
        <button class="button-secondary" id="goal-edit-modal-cancel">Cancel</button>
        <button class="button-primary" id="goal-edit-save-btn">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Project Step Edit Modal -->
  <div id="project-step-modal" class="modal hidden">
    <div class="modal-panel">
      <div class="modal-header">
        <div class="modal-title">Edit Project Step</div>
        <button class="modal-close" id="project-step-modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <input type="hidden" id="edit-project-step-id">
        <label>
          Title
          <input id="edit-project-step-title-input" placeholder="Step title..." />
        </label>
        <label>
          Assign To
          <div id="edit-project-step-assignees-container" class="checkbox-list"></div>
          <div class="field-hint">Select all people responsible for this step.</div>
        </label>
      </div>
      <div class="modal-footer">
        <button class="button-secondary" id="project-step-modal-cancel">Cancel</button>
        <button class="button-primary" id="project-step-save-btn">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Bird Shop Modal -->
  <div id="shop-modal" class="modal hidden">
    <div class="modal-panel" style="max-width:600px;">
      <div class="modal-header">
        <div class="modal-title">ðŸª™ Bird Shop</div>
        <button class="modal-close" id="shop-modal-close">&times;</button>
      </div>
      <div class="modal-body" style="padding:0;">
        <!-- Shop Tabs -->
        <div class="shop-tabs">
          <button class="shop-tab active" data-tab="shop">Shop</button>
          <button class="shop-tab" data-tab="inventory">My Items</button>
        </div>
        <!-- Content -->
        <div class="shop-content">
          <div id="shop-tab-shop" class="shop-tab-content active">
            <div id="shop-items-grid" class="shop-grid"></div>
          </div>
          <div id="shop-tab-inventory" class="shop-tab-content hidden">
            <div id="inventory-grid" class="shop-grid"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <div style="display:flex;align-items:center;gap:8px;">
          <span style="font-size:20px;">ðŸª™</span>
          <span id="shop-balance">0</span> coins
        </div>
        <button class="button-secondary" id="shop-modal-done">Done</button>
      </div>
    </div>
  </div>

  <!-- Task Reminder Container (holds multiple stacked reminders) -->
  <div id="reminder-container" class="reminder-container"></div>

  <div class="toast" id="toast"></div>

  <!-- TikTok-style action loader -->
  <div id="action-loader" class="action-loader">
    <div class="action-loader-inner">
      <div class="loader-spinner"></div>
      <div>
        <div class="action-loader-text-main" id="action-loader-main">Syncingâ€¦</div>
        <div class="action-loader-text-sub" id="action-loader-sub">
          Saving your change to the Wrap Sheet
        </div>
      </div>
    </div>
  </div>

  <div class="app-shell">
    <header class="app-header">
      <div class="branding">
        <div class="branding-mark">W</div>
        <div class="branding-text">
          <h1>Wrap Sheet</h1>
          <span>BER â€¢ DAILY TASKS â€¢ GOALS</span>
        </div>

        <div class="header-controls">
          <div id="sync-indicator"
            style="font-size:11px;color:var(--ink-soft);display:flex;align-items:center;gap:4px;">
            <span style="font-size:12px;">ðŸ”„</span>
            <span id="last-sync-time">â€”</span>
          </div>

          <div class="theme-toggle">
            <label for="theme-select">Theme</label>
            <select id="theme-select">
              <option value="light">Day</option>
              <option value="dark">Night</option>
            </select>
          </div>

          <!-- Bird Controls & Shop -->
          <div class="header-bird-controls">
            <!-- Mute Button -->
            <button id="bird-mute-btn" class="header-icon-btn" title="Toggle Squeaks">
              <span class="btn-icon">ðŸ”Š</span>
              <span class="btn-label">Mute</span>
            </button>

            <!-- Customize Button -->
            <button id="edit-bird-trigger" class="header-icon-btn" title="Customize Bird">
              <span class="btn-icon">ðŸŽ¨</span>
              <span class="btn-label">Customize</span>
            </button>

            <!-- Coin Counter (Trigger Shop) -->
            <div class="coin-counter-wrap" id="coin-counter-wrap" onclick="openShopModal()" style="cursor:pointer;"
              title="Open Shop">
              <div class="coin-counter" id="coin-counter">
                <span class="coin-icon">ðŸª™</span>
                <span class="coin-amount" id="coin-amount">0</span>
              </div>
              <div class="coin-caps" id="coin-caps">
                <span id="coin-day-progress">0/50 today</span>
                <span id="coin-week-progress">0/250 week</span>
              </div>
            </div>
          </div>

          <div class="user-pill">
            <span id="current-user-label">Not signed in</span>
            <button id="switch-user-btn">Switch</button>
          </div>
        </div>
    </header>

    <!-- Full-width Ticker Bar -->
    <div id="header-ticker-container">
      <!-- Ticker items injected here -->
    </div>

    <main class="app-main">
      <!-- Section Toggle Toolbar -->
      <!-- Section Toggle Toolbar -->
      <div class="view-options-bar" id="view-options-bar" style="margin-bottom: 16px;">
        <div style="display:flex; flex-direction:column; gap:2px; margin-right:auto; padding-left: 4px;">
          <span style="font-size:12px; font-weight:700; color:var(--ink);">Customize</span>
          <span style="font-size:10px; color:var(--ink-soft);">Drag to reorder</span>
        </div>

        <!-- Grouped Buttons -->
        <div class="view-option" draggable="true" data-target="section-daily-tasks,section-backlog">Daily & Backlog
          <span class="drag-handle">â‹®â‹®</span>
        </div>
        <div class="view-option" draggable="true" data-target="section-gamification">Metrics <span
            class="drag-handle">â‹®â‹®</span></div>
        <div class="view-option" draggable="true" data-target="section-weekly-strategy,section-projects">Strategy &
          Projects <span class="drag-handle">â‹®â‹®</span></div>
        <div class="view-option" draggable="true" data-target="section-goals,section-pillars">Goals & Pillars <span
            class="drag-handle">â‹®â‹®</span></div>
      </div>

      <!-- Draggable Sections Container -->
      <div id="sections-container">
        <!-- Calendar (Daily Tasks) -->
        <section class="panel draggable-section" id="section-daily-tasks" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
            <div class="panel-title">Daily Tasks</div>
            <div class="calendar-controls">
              <button id="month-prev">&larr;</button>
              <span class="month-label" id="month-label">Month YYYY</span>
              <button id="month-next">&rarr;</button>

              <select id="calendar-view-select">
                <option value="month">Month</option>
                <option value="week">Full Week</option>
                <option value="workweek">Work Week</option>
                <option value="jointweek">Joint Weekly</option>
              </select>

              <select id="calendar-owner-select">
                <option value="">My Tasks</option>
              </select>

              <div class="calendar-legend">
                <span><span class="legend-dot legend-pending"></span>Pending</span>
                <span><span class="legend-dot legend-inprogress"></span>In Progress</span>
                <span><span class="legend-dot legend-done"></span>Done</span>
                <span><span class="legend-dot legend-blocked"></span>Could Not Complete</span>
              </div>



            </div>
          </div>
          <div class="calendar-grid">
            <div class="calendar-weekdays" id="calendar-weekdays"></div>
            <div class="calendar-days" id="calendar-days"></div>
          </div>

        </section>

        <!-- Task Backlog Section -->
        <section class="panel draggable-section" id="section-backlog">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
            <div class="panel-title">Task Backlog</div>
            <div class="header-hint" style="font-size:11px;color:var(--ink-soft);margin-left:auto;">
              Drag here to park tasks Â· Drag to calendar to schedule
            </div>
          </div>
          <div class="backlog-container" id="backlog-container"
            style="padding:10px;min-height:80px;background:rgba(0,0,0,0.03);border-radius:6px;margin:10px;">
            <div id="backlog-list" style="display:grid;grid-template-columns:repeat(2, 1fr);gap:8px;"></div>
            <div id="backlog-empty"
              style="font-size:11px;color:var(--ink-soft);text-align:center;padding:10px;width:100%;grid-column:1/-1;display:none;">
              No parked tasks.
            </div>
          </div>
          <div class="add-backlog-form" style="padding:0 10px 10px;display:flex;gap:6px;">
            <input type="text" id="new-backlog-input" placeholder="Add to backlog..."
              style="flex:1;font-size:11px;padding:5px;border-radius:4px;border:1px solid var(--panel-border);background:var(--panel);">
            <button id="add-backlog-btn"
              style="border:none;background:var(--accent);color:#fff;border-radius:4px;padding:5px 10px;font-size:11px;cursor:pointer;">Add</button>
          </div>
        </section>

        <!-- Gamification Section (Bird/Stats) -->
        <section class="panel draggable-section" id="section-gamification">
          <div class="panel-header" style="display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center;">
              <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
              <div class="panel-title">Team Pulse & Gamification</div>
            </div>

            <!-- Range Toggle UI -->
            <div class="metrics-range-toggle"
              style="display: flex; background: var(--accent-soft); padding: 2px; border-radius: 999px;">
              <button onclick="setMetricsRange('day')" id="metrics-btn-day" class="toggle-btn"
                style="border: none; background: transparent; padding: 4px 12px; border-radius: 999px; font-size: 11px; font-weight: 600; cursor: pointer; color: var(--ink-soft);">Day</button>
              <button onclick="setMetricsRange('week')" id="metrics-btn-week" class="toggle-btn active"
                style="border: none; background: var(--accent); color: var(--bg-main); padding: 4px 12px; border-radius: 999px; font-size: 11px; font-weight: 600; cursor: pointer;">Week</button>
              <button onclick="setMetricsRange('month')" id="metrics-btn-month" class="toggle-btn"
                style="border: none; background: transparent; padding: 4px 12px; border-radius: 999px; font-size: 11px; font-weight: 600; cursor: pointer; color: var(--ink-soft);">Month</button>
            </div>
          </div>

          <!-- Team Metrics Dashboard -->
          <div id="team-metrics-dashboard" style="padding: 0 16px 16px 16px;">
            <!-- Injected by JS -->
            <div class="metrics-stats-row" style="display: flex; gap: 16px; margin-bottom: 24px;"
              id="metrics-stats-row"></div>
            <div class="metrics-charts-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px;">
              <div class="chart-container"
                style="background: var(--bg-main); padding: 16px; border-radius: 12px; height: auto; min-height:300px; position: relative; display:flex; flex-direction:column;">
                <div style="flex:1;"><canvas id="chart-workload"></canvas></div>
                <div style="margin-top:12px; font-size:11px; color:var(--ink-soft); text-align:center;">
                  <strong>Workload per active user.</strong> <br>Active = To Do + In Progress.
                </div>
              </div>
              <div class="chart-container"
                style="background: var(--bg-main); padding: 16px; border-radius: 12px; height: auto; min-height:300px; position: relative; display:flex; flex-direction:column;">
                <div style="flex:1;"><canvas id="chart-efficiency"></canvas></div>
                <div style="margin-top:12px; font-size:11px; color:var(--ink-soft); text-align:center;">
                  <strong>Tasks completed per day.</strong> <br>Measures team velocity this week.
                </div>
              </div>
            </div>
          </div>

          <!-- Divider -->
          <div style="height: 1px; background: var(--panel-border); margin: 0 16px 16px 16px;"></div>

          <!-- Existing Bird Content -->
          <div id="gamification-content" class="calendar-metrics bird-system-container"
            style="display:flex; flex-direction:column; padding:15px; background:var(--panel); border-radius:8px; height:auto;">
            <!-- Top Row: Bird and Pie -->
            <div
              style="display:flex; justify-content:space-between; align-items:flex-start; width:100%; margin-bottom:15px;">
              <!-- Bird Container -->
              <div id="finch-container" class="bird-wrapper" title="Pet me!"
                style="position:relative; width:100px; height:100px; flex-shrink:0; overflow:visible;">
                <!-- Speech Bubble - Finch Style (positioned to right) -->
                <div id="bird-speech-bubble" class="speech-bubble hidden"></div>
                <!-- Bird Name Display -->
                <div id="bird-name-display"
                  style="position:absolute; top:-20px; width:100%; text-align:center; font-size:12px; font-weight:700; color:var(--ink-soft); text-shadow:0 1px 2px rgba(255,255,255,0.8);">
                </div>
                <svg id="finch-svg" viewBox="0 0 200 200" style="width:100%; height:100%; overflow:visible;">
                  <!-- Bird Logic will inject SVG here -->
                </svg>
                <div id="finch-hearts"
                  style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>
              </div>

              <!-- Existing Pie -->
              <div style="position:relative; display:flex; flex-direction:column; align-items:center;">
                <canvas id="status-pie" width="150" height="150"></canvas>
              </div>
            </div>

            <!-- Bottom Row: Full Width Coin Energy Bar -->
            <div class="coin-meter-container"
              style="width:100%; display:flex; flex-direction:column; align-items:center; gap:4px;">
              <div class="coin-meter" title="Daily Energy: 50 Coins"
                style="width:100%; height:20px; min-height:20px; background:#e5e7eb; border-radius:999px; overflow:hidden; position:relative; display:block; box-sizing:border-box; box-shadow:inset 0 1px 3px rgba(0,0,0,0.2);">
                <div class="coin-meter-fill" id="bird-energy-fill"
                  style="width: 0%; height:20px; min-height:20px; background:linear-gradient(90deg, #facc15, #eab308); border-radius:999px; display:block;">
                </div>
              </div>
              <div class="coin-meter-label" id="bird-energy-text" style="font-size:11px; font-weight:600;">0/50</div>
            </div>
          </div>
        </section>



        <!-- Weekly Strategy Section (New) -->
        <section class="panel draggable-section" id="section-weekly-strategy" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
            <div class="panel-title">Weekly Strategy</div>
          </div>

          <div id="weekly-planner-panel">
            <div class="goals-controls" style="justify-content:center; gap:20px;">
              <button id="weekly-prev" class="icon-btn">â† Prev Week</button>
              <span id="weekly-current-label" style="font-weight:600; color:var(--accent);">Week of ...</span>
              <button id="weekly-next" class="icon-btn">Next Week â†’</button>
            </div>

            <!-- Priorities Grid -->
            <div class="weekly-section">
              <div class="weekly-section-header">Top 3-5 Priorities</div>
              <div id="weekly-priorities-grid" class="weekly-grid"></div>
            </div>

            <!-- Marketing Grid -->
            <div class="weekly-section" style="margin-top:30px;">
              <div class="weekly-section-header">Marketing</div>
              <div id="weekly-marketing-grid" class="weekly-grid"></div>
            </div>

            <!-- Projects Grid -->
            <div class="weekly-section" style="margin-top:30px;">
              <div class="weekly-section-header">Projects & Events</div>
              <div id="weekly-projects-grid" class="weekly-grid"></div>
            </div>
          </div>
        </section>

        <!-- Joint Projects Section -->
        <section class="panel draggable-section" id="section-projects" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
            <div class="panel-title">Joint Projects</div>
            <button class="add-project-btn" id="add-project-btn">+ New Project</button>
          </div>
          <div class="projects-grid" id="projects-grid"></div>
        </section>

        <!-- Weekly Tasks (BETA - Jenna only) -->
        <section class="panel draggable-section" id="section-weekly-tasks" draggable="true" style="display: none;">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
            <div class="panel-title">
              Weekly Tasks <span class="beta-badge">BETA</span>
            </div>
            <div class="weekly-tasks-controls">
              <button id="week-prev"
                style="background:none;border:none;font-size:14px;cursor:pointer;color:var(--ink);">â†</button>
              <span id="week-label" style="font-size:11px;color:var(--ink-soft);min-width:80px;text-align:center;">Week
                52</span>
              <button id="week-next"
                style="background:none;border:none;font-size:14px;cursor:pointer;color:var(--ink);">â†’</button>
            </div>
          </div>
          <div class="weekly-tasks-list" id="weekly-tasks-list"></div>
          <div class="add-weekly-task-form">
            <input type="text" id="new-weekly-task-input" placeholder="Add weekly task...">
            <button id="add-weekly-task-btn">Add</button>
          </div>
        </section>

        <!-- Goals Section -->
        <section class="panel draggable-section" id="section-goals">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
            <div class="panel-title">Goals & Focus</div>
            <div class="goals-tabs">
              <button class="goals-tab active" data-tab="monthly">Monthly Strategies</button>
              <button class="goals-tab" data-tab="annual">Annual Goals</button>
            </div>
          </div>

          <!-- Monthly Goals -->
          <div id="monthly-goals-panel">
            <div class="goals-controls">
              <label>Month <input type="month" id="monthly-month-input" /></label>
              <label>Owner <select id="monthly-owner-filter">
                  <option value="all">Everyone</option>
                </select></label>
            </div>
            <div class="goals-grid" id="monthly-goals-grid"></div>
          </div>

          <!-- Annual Goals -->
          <div id="annual-goals-panel" style="display:none;">
            <div class="goals-controls">
              <label>Year <select id="annual-year-input"></select></label>
              <label>Owner <select id="annual-owner-filter">
                  <option value="all">Everyone</option>
                </select></label>
            </div>
            <div class="goals-grid" id="annual-goals-grid"></div>
          </div>
        </section>

        <!-- Core Pillars (per-user) -->
        <section class="panel draggable-section" id="section-pillars" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">â‹®â‹®</span>
            <div class="panel-title">Core Pillars</div>
            <div class="pillars-sub" id="pillars-subtitle"
              style="margin-left:auto;font-size:11px;color:var(--ink-soft);">Personal to you</div>
          </div>
          <!-- Subheader removed in favor of panel-header layout -->

          <div class="pillar-grid" id="pillar-grid"></div>
        </section>
      </div> <!-- End sections-container -->

      <!-- Pillar Task Modal -->
      <div id="pillar-modal" class="modal hidden">
        <div class="modal-panel">
          <div class="modal-header">
            <div>
              <div class="modal-title" id="pillar-modal-title">New Pillar Task</div>
              <div id="pillar-modal-meta" style="font-size:11px;color:#9ca3af;"></div>
            </div>
            <button class="modal-close" id="pillar-modal-close">&times;</button>
          </div>

          <div class="modal-body">
            <input type="hidden" id="pillar-task-id" />
            <input type="hidden" id="pillar-key" />

            <label>
              Task Title
              <input id="pillar-task-title" placeholder="e.g., Launch new onboarding email" />
            </label>

            <label>
              Assigned to who?
              <select id="pillar-task-assigned-to"></select>
            </label>

            <label>
              What is the benchmark?
              <input id="pillar-task-benchmark" placeholder="e.g., Draft approved by Friday" />
            </label>

            <div class="modal-repeat-row">
              <label>
                Percentage Complete
                <input id="pillar-task-percent" type="number" min="0" max="100" placeholder="0â€“100" />
                <div class="field-hint">This drives the circle % for the pillar.</div>
              </label>

              <label>
                Estimated date of completion
                <input id="pillar-task-eta" type="date" />
              </label>
            </div>

            <label>
              Staff Update / Notes
              <textarea id="pillar-task-notes" rows="2" placeholder="Share a progress update..."></textarea>
            </label>
          </div>

          <div class="modal-footer">
            <button class="button-secondary" id="pillar-modal-cancel">Cancel</button>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="button-danger" id="pillar-task-delete" style="display:none;">Delete</button>
              <button class="button-primary" id="pillar-task-save">Save</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Suggestion Modal (Board Ideas) -->
      <div id="suggestion-modal" class="modal hidden">
        <div class="modal-panel">
          <div class="modal-header">
            <div>
              <div class="modal-title">Update Board Idea</div>
              <div id="suggestion-modal-title"
                style="font-size:12px;color:var(--ink-soft);max-width:300px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
              </div>
            </div>
            <button class="modal-close" id="suggestion-modal-close">&times;</button>
          </div>

          <div class="modal-body">
            <input type="hidden" id="suggestion-id" />

            <label>
              Progress Percentage
              <div style="display:flex;align-items:center;gap:10px;">
                <input type="range" id="suggestion-percent" min="0" max="100" step="5" style="flex:1"
                  oninput="document.getElementById('suggestion-percent-val').textContent = this.value + '%'">
                <span id="suggestion-percent-val"
                  style="font-weight:600;width:40px;text-align:right;font-size:12px;">0%</span>
              </div>
            </label>

            <label>
              Progress Notes (Visible to Board)
              <textarea id="suggestion-notes" placeholder="Update the board on status..."></textarea>
            </label>

            <label>
              Status
              <select id="suggestion-status">
                <option value="suggested">Suggested (Pending)</option>
                <option value="active">Active (In Progress)</option>
                <option value="completed">Completed</option>
              </select>
            </label>

            <label>
              Estimated Completion
              <input type="date" id="suggestion-eta" />
            </label>
          </div>

          <div class="modal-footer">
            <button class="button-secondary" id="suggestion-modal-cancel">Cancel</button>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="button-primary" id="suggestion-save-btn">Update Idea</button>
            </div>
          </div>
        </div>
      </div>




    </main>

    <!-- Gamification Overlay -->
    <div id="celebration-overlay" class="celebration-overlay">
      <span class="celebration-emoji" id="celebration-emoji">ðŸŽ‰</span>
      <div class="celebration-text" id="celebration-text">Good work!</div>
      <div class="celebration-sub" id="celebration-sub">Task Completed</div>
    </div>
  </div>

  <script>
    // ===== CONFIG =====
    const API_BASE = "https://wrapsheet.bonitaspringsrealtors.workers.dev/api";

    const MONTHLY_CATEGORIES = [
      "Compliance/Audit",
      "Marketing",
      "Products & Tools",
      "Personal Focus",
      "Moving the Needle",
      "Team Work"
    ];

    const CATEGORY_COLORS = {
      "Compliance/Audit": "var(--evolve)", // Emerald
      "Marketing": "var(--excite)", // Pink
      "Products & Tools": "var(--accent)", // Teal
      "Personal Focus": "#8b5cf6", // Violet
      "Moving the Needle": "var(--elevate)", // Amber
      "Team Work": "var(--engage)" // Blue
    };

    const ANNUAL_CATEGORIES = [
      "Compliance/Audit",
      "Marketing",
      "Products & Tools",
      "Personal Focus",
      "Moving the Needle",
      "Team Work"
    ];

    const BACKLOG_DATE = "1900-01-01";

    const state = {
      users: [],
      currentUser: null,
      promotedSuggestions: [],
      currentMonthDate: new Date(),
      dailyTasks: [],
      backlogTasks: [], // NEW
      monthlyGoals: [],
      annualGoals: [],
      monthlyOwnerFilter: "all",
      annualOwnerFilter: "all",
      annualYear: new Date().getFullYear(),
      calendarView: "month",
      calendarOwnerId: null,
      theme: "light",
      pillars: {
        elevate: [],
        engage: [],
        evolve: [],
        excite: []
      },
      projects: [],               // Joint projects list
      weeklyTasks: [],           // Weekly tasks for current week
      currentWeekKey: null,      // '2025-W52' format
      userDbPrefs: null,         // User preferences from D1
      coinBalance: 0,            // Coin reward balance (Finch-style)
      activeUserId: null,     // who we are currently "working on" (driven by calendar owner select)
      activeUser: null,
      userPrefs: null,        // prefs for activeUserId (titles, category labels, etc.)
      monthlyCategoryDefs: null, // [{key,label}]
      annualCategoryDefs: null,
      metricsRange: 'week', // NEW: 'day' | 'week' | 'month'
    };


    const DEFAULT_MONTHLY_KEYS = [
      "Compliance/Audit", "Marketing", "Products & Tools", "Personal Focus", "Moving the Needle", "Team Work"
    ];
    const DEFAULT_ANNUAL_KEYS = [...DEFAULT_MONTHLY_KEYS];

    function defaultCategoryDefs(keys) {
      return keys.map(k => ({ key: k, label: k }));
    }

    // Get custom category name from user preferences (or return original)
    function getCustomCategoryName(goalType, originalCategory) {
      if (!state.userPrefs) return originalCategory;
      const customNames = state.userPrefs.customCategoryNames || {};
      const key = `${goalType}-${originalCategory}`;
      return customNames[key] || originalCategory;
    }

    // Save custom category name to database
    async function saveCustomCategoryName(goalType, originalCategory, customName) {
      if (!state.activeUser) return;

      const prefs = state.userPrefs || {};
      const newCustomNames = { ...(prefs.customCategoryNames || {}) };

      const key = `${goalType}-${originalCategory}`;

      // If custom name is same as original or empty, remove the override
      if (!customName || customName === originalCategory) {
        delete newCustomNames[key];
      } else {
        newCustomNames[key] = customName;
      }

      const newPrefs = { ...prefs, customCategoryNames: newCustomNames };
      state.userPrefs = newPrefs; // Optimistic update

      try {
        await apiSend("/user-prefs", "POST", {
          userId: state.activeUser.id,
          prefs: newPrefs
        });
      } catch (err) {
        console.error("Error saving user prefs:", err);
        showToast("Error saving header", true);
      }
    }

    async function loadUserPrefsForActiveUser() {
      if (!state.activeUser) {
        state.userPrefs = {};
        return;
      }

      try {
        // Load from DB
        const res = await apiSend(`/user-prefs?userId=${state.activeUser.id}`);
        state.userPrefs = res || {};
      } catch (err) {
        console.error("Error loading user preferences:", err);
        state.userPrefs = {}; // fallback
      }
    }

    async function setActiveUser(userIdOrNull) {
      state.activeUserId = userIdOrNull ? Number(userIdOrNull) : null;
      state.activeUser = getActiveUserSafe();

      // Sync goals filters to match active user (or "Everyone" if null)
      const ownerVal = state.activeUserId ? String(state.activeUserId) : "all";
      state.monthlyOwnerFilter = ownerVal;
      state.annualOwnerFilter = ownerVal;

      const mo = document.getElementById("monthly-owner-filter");
      const ao = document.getElementById("annual-owner-filter");
      if (mo) mo.value = ownerVal;
      if (ao) ao.value = ownerVal;

      // Load prefs + pillars for whoever we're working on
      await Promise.all([
        loadUserPrefsForActiveUser(),
        loadPillarsForActiveUser()
      ]);

      renderMonthlyGoals();
      renderAnnualGoals();
      renderPillars();
    }


    async function loadPillarsForActiveUser() {
      if (!state.activeUser) {
        console.error("No active user found");
        return;
      }

      // NOTE: state.userPrefs is loaded by loadUserPrefsForActiveUser() from the DB
      // Do NOT overwrite it with localStorage here

      const pillarsKey = `wrapsheet-pillars-v1:${state.activeUser.id}`;
      try {
        const raw = localStorage.getItem(pillarsKey);
        if (!raw) {
          state.pillars = { elevate: [], engage: [], evolve: [], excite: [] };
        } else {
          const parsed = JSON.parse(raw);
          state.pillars = parsed || { elevate: [], engage: [], evolve: [], excite: [] };
        }
      } catch (err) {
        console.error("Error loading pillars:", err);
        state.pillars = { elevate: [], engage: [], evolve: [], excite: [] };
      }

      renderPillars(); // Ensure pillars are rendered after loading
    }


    function getActiveUserSafe() {
      return state.users.find(u => String(u.id) === String(state.activeUserId)) || null;
    }


    // ===== DRAG & DROP STATE =====
    const dragState = {
      taskId: null,
      fromDate: null
    };

    function onTaskDragStart(e) {
      e.stopPropagation(); // Prevent section drag
      const pill = e.currentTarget;
      const taskId = pill.dataset.taskId;
      const fromDate = pill.dataset.date;

      if (!taskId || !fromDate) return;

      dragState.taskId = taskId;
      dragState.fromDate = fromDate;

      e.dataTransfer.effectAllowed = "move";
      // Needed for Firefox / some browsers
      e.dataTransfer.setData("text/plain", taskId);

      pill.classList.add("dragging");
    }

    function onTaskDragEnd(e) {
      const pill = e.currentTarget;
      pill.classList.remove("dragging");
      dragState.taskId = null;
      dragState.fromDate = null;
    }

    function onDayDragOver(e) {
      if (!dragState.taskId) return;
      // Allow drop
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    }

    function onDayDragEnter(e) {
      if (!dragState.taskId) return;
      e.preventDefault();
      e.currentTarget.classList.add("drop-target");
    }

    function onDayDragLeave(e) {
      e.currentTarget.classList.remove("drop-target");
    }

    function onDayDrop(e) {
      if (!dragState.taskId) return;
      e.preventDefault();

      const cell = e.currentTarget;
      cell.classList.remove("drop-target");

      const newDateKey = cell.dataset.dateKey;
      if (!newDateKey) return;

      // If same date, ignore
      if (state.dailyTasks.find(t => String(t.id) === String(dragState.taskId))?.task_date === newDateKey) return;

      moveTaskToDate(dragState.taskId, newDateKey);
    }

    async function moveTaskToDate(taskId, newDateKey) {
      // Search in both lists
      let task = state.dailyTasks.find(t => String(t.id) === String(taskId));
      const sourceList = task ? "daily" : "backlog";

      if (!task) {
        task = state.backlogTasks.find(t => String(t.id) === String(taskId));
      }

      if (!task) return;

      const oldDate = task.task_date;
      if (oldDate === newDateKey) return;

      // Optimistic Update
      task.task_date = newDateKey;

      if (newDateKey === BACKLOG_DATE) {
        // Moved TO Backlog
        // Remove from dailyTasks if there
        state.dailyTasks = state.dailyTasks.filter(t => t.id !== task.id);
        // Add to backlogTasks if not there
        if (!state.backlogTasks.find(t => t.id === task.id)) {
          state.backlogTasks.push(task);
        }
      } else {
        // Moved TO Calendar
        // Remove from backlogTasks if there
        state.backlogTasks = state.backlogTasks.filter(t => t.id !== task.id);
        // Add to dailyTasks if not there (and if it matches visible range, but for now just add it)
        if (!state.dailyTasks.find(t => t.id === task.id)) {
          state.dailyTasks.push(task);
        }
      }

      renderCalendar();
      if (typeof renderBacklog === "function") renderBacklog();

      try {
        await apiSend("/daily-tasks/" + taskId, "PATCH", { task_date: newDateKey });
        if (newDateKey === BACKLOG_DATE) {
          showToast("Moved to Backlog");
        } else {
          showToast("Scheduled for " + newDateKey);
        }
        // Reload to be safe and sync sorting/etc
        // await Promise.all([loadDailyTasks(), loadBacklogTasks()]); 
      } catch (err) {
        console.error(err);
        // Revert
        task.task_date = oldDate;
        if (sourceList === "daily") {
          if (!state.dailyTasks.find(t => t.id === task.id)) state.dailyTasks.push(task);
          state.backlogTasks = state.backlogTasks.filter(t => t.id !== task.id);
        } else {
          if (!state.backlogTasks.find(t => t.id === task.id)) state.backlogTasks.push(task);
          state.dailyTasks = state.dailyTasks.filter(t => t.id !== task.id);
        }
        renderCalendar();
        if (typeof renderBacklog === "function") renderBacklog();
        showToast("Error moving task", true);
      }
    }
    // ===== GAMIFICATION & FIREWORKS =====
    const AFFIRMATIONS = [
      "Good work! :)", "Awesome job!", "You're on fire! ðŸ”¥", "Way to go!",
      "Keep it up!", "Slaying it! âœ¨", "Productivity genius :D",
      "One step closer!", "Boom! Done.", "Excellent work!", "Victory! âœŒï¸"
    ];

    function getRandomAffirmation() {
      return AFFIRMATIONS[Math.floor(Math.random() * AFFIRMATIONS.length)];
    }

    function showCelebration(text, subtext = "Task Completed") {
      const overlay = document.getElementById("celebration-overlay");
      const textEl = document.getElementById("celebration-text");
      const subEl = document.getElementById("celebration-sub");
      const emojiEl = document.getElementById("celebration-emoji");

      if (!overlay) return;

      textEl.textContent = text;
      subEl.textContent = subtext;
      emojiEl.textContent = "ðŸŽ‰"; // Could randomize emojis too

      overlay.classList.add("show");
      setTimeout(() => overlay.classList.remove("show"), 2500);
    }

    // Trigger fireworks
    // type: 'small' (single task), 'medium' (day complete), 'huge' (week complete)
    function triggerFireworks(type = 'small') {
      const duration = type === 'huge' ? 30 * 1000 : (type === 'medium' ? 3 * 1000 : 800);
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 9995 };

      function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      if (type === 'small') {
        // Single burst
        confetti({
          ...defaults,
          particleCount: 50,
          scalar: 1.2,
          origin: { y: 0.8 }
        });
      } else if (type === 'medium') {
        // Daily complete: couple of bursts
        const interval = setInterval(function () {
          const timeLeft = animationEnd - Date.now();
          if (timeLeft <= 0) return clearInterval(interval);

          confetti({
            ...defaults,
            particleCount: 50,
            origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
          });
          confetti({
            ...defaults,
            particleCount: 50,
            origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
          });
        }, 250);
      } else {
        // Huge (Week Complete): 30 seconds of pure joy
        const interval = setInterval(function () {
          const timeLeft = animationEnd - Date.now();
          if (timeLeft <= 0) return clearInterval(interval);

          const particleCount = 50 * (timeLeft / duration);
          confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } });
          confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } });
        }, 250);

        showCelebration("CONGRATULATIONS!", "You finished ALL weekly tasks!");
      }

      if (type === 'small') {
        showCelebration(getRandomAffirmation());
      } else if (type === 'medium') {
        showCelebration("Daily Goals Crushed!", "All tasks done for today");
      }
    }

    function checkDailyCompletion(dateKey) {
      if (!dateKey) return;
      const tasks = state.dailyTasks.filter(t => t.task_date === dateKey);
      if (tasks.length === 0) return;

      const allDone = tasks.every(t => t.status === "done" || t.status === "could_not_complete");
      // Check if we just completed the last one is tricky without previous state, 
      // but triggering it every time the last one is clicked is acceptable gamification/affirmation.
      // Better: check if > 0 tasks are done.
      const doneCount = tasks.filter(t => t.status === "done").length;

      if (allDone && doneCount > 0) {
        triggerFireworks('medium');
        // Bonus coins for completing ALL daily tasks
        if (isRewardEligible()) {
          setTimeout(() => {
            awardCoins(25, null);
            playCoinBurstSound();
          }, 600);
        }
      } else {
        triggerFireworks('small');
      }
    }

    function checkWeeklyCompletion() {
      if (!state.weeklyTasks || state.weeklyTasks.length === 0) return;

      const allDone = state.weeklyTasks.every(t => t.status === "done");
      if (allDone) {
        triggerFireworks('huge');
      } else {
        triggerFireworks('small');
      }
    }

    // ===== COIN REWARD SYSTEM (Finch-style) =====
    const COIN_DAILY_CAP = 50;
    const COIN_WEEKLY_CAP = 250;

    // Check if current user is eligible for coin rewards
    function isRewardEligible() {
      // All logged-in users are eligible for coin rewards
      return !!state.currentUser;
    }

    // Get current day/week keys for cap tracking
    function getCoinDayKey() {
      return new Date().toISOString().split("T")[0]; // "2026-01-20"
    }
    function getCoinWeekKey() {
      const now = new Date();
      const startOfYear = new Date(now.getFullYear(), 0, 1);
      const days = Math.floor((now - startOfYear) / 86400000);
      const weekNum = Math.ceil((days + startOfYear.getDay() + 1) / 7);
      return `${now.getFullYear()}-W${String(weekNum).padStart(2, "0")}`;
    }

    let coinSaveTimeout;

    // Load coin balance from API only (no local fallback)
    async function loadCoinBalance() {
      if (!state.currentUser) return;

      try {
        const data = await apiGet(`/users/${state.currentUser.id}/coins`);
        if (data) {
          state.coinBalance = data.coin_balance || 0;
          state.coinDayEarned = data.coin_day_earned || 0;
          state.coinDayKey = data.coin_day_key || "";
          state.coinWeekEarned = data.coin_week_earned || 0;
          state.coinWeekKey = data.coin_week_key || "";
        }
      } catch (e) {
        console.warn("Could not load coins from API", e);
        // Initialize defaults if API fails
        state.coinBalance = 0;
        state.coinDayEarned = 0;
        state.coinDayKey = getCoinDayKey();
        state.coinWeekEarned = 0;
        state.coinWeekKey = getCoinWeekKey();
      }

      // Reset daily/weekly counters if needed
      checkCoinRollovers();

      updateCoinCounterDisplay();

      // Show the coin counter wrapper for eligible users
      const wrapper = document.getElementById("coin-counter-wrap");
      if (wrapper && isRewardEligible()) {
        wrapper.classList.add("visible");
      }
    }

    function checkCoinRollovers() {
      // Reset daily counter if new day
      const today = getCoinDayKey();
      if (state.coinDayKey !== today) {
        state.coinDayKey = today;
        state.coinDayEarned = 0;
      }
      // Reset weekly counter if new week
      const thisWeek = getCoinWeekKey();
      if (state.coinWeekKey !== thisWeek) {
        state.coinWeekKey = thisWeek;
        state.coinWeekEarned = 0;
      }
      // Save to server after rollover check
      saveCoinBalanceToServer();
    }

    // Save coin balance to server (debounced)
    // IMPORTANT: Capture user and data NOW to prevent race condition on user switch
    function saveCoinBalance() {
      // Cancel any pending save for a different user
      clearTimeout(coinSaveTimeout);

      // Capture current user and data at THIS moment
      const userId = state.currentUser?.id;
      const coinData = {
        coin_balance: state.coinBalance,
        coin_day_earned: state.coinDayEarned,
        coin_day_key: state.coinDayKey,
        coin_week_earned: state.coinWeekEarned,
        coin_week_key: state.coinWeekKey
      };

      if (!userId) return;

      // Debounce but use captured data
      coinSaveTimeout = setTimeout(() => saveCoinBalanceToServerWithData(userId, coinData), 2000);
    }

    async function saveCoinBalanceToServerWithData(userId, coinData) {
      try {
        await apiSend(`/users/${userId}/coins`, "PUT", coinData);
      } catch (e) {
        console.warn("Error saving coins to server:", e);
      }
    }

    async function saveCoinBalanceToServer() {
      if (!state.currentUser) return;
      try {
        await apiSend(`/users/${state.currentUser.id}/coins`, "PUT", {
          coin_balance: state.coinBalance,
          coin_day_earned: state.coinDayEarned,
          coin_day_key: state.coinDayKey,
          coin_week_earned: state.coinWeekEarned,
          coin_week_key: state.coinWeekKey
        });
      } catch (e) {
        console.warn("Error saving coins to server:", e);
      }
    }

    // Update the coin counter display and cap progress
    function updateCoinCounterDisplay() {
      const amountEl = document.getElementById("coin-amount");
      if (amountEl) {
        amountEl.textContent = state.coinBalance || 0;
      }
      // Update cap progress display
      const dayProgress = document.getElementById("coin-day-progress");
      const weekProgress = document.getElementById("coin-week-progress");
      if (dayProgress) {
        dayProgress.textContent = `${state.coinDayEarned || 0}/${COIN_DAILY_CAP} today`;
      }
      if (weekProgress) {
        weekProgress.textContent = `${state.coinWeekEarned || 0}/${COIN_WEEKLY_CAP} week`;
      }

      // Update Bird Energy Meter
      if (typeof updateBirdEnergy === "function") {
        updateBirdEnergy();
      }
    }

    // Check how many coins can be awarded (respecting caps)
    function getAwardableCoins(requested) {
      const dayRemaining = COIN_DAILY_CAP - (state.coinDayEarned || 0);
      const weekRemaining = COIN_WEEKLY_CAP - (state.coinWeekEarned || 0);
      return Math.max(0, Math.min(requested, dayRemaining, weekRemaining));
    }

    // Award coins - Logic Decoupled from Animation
    function awardCoins(amount, sourceElement) {
      if (!isRewardEligible() || amount <= 0) return;

      // Apply caps logic overrides
      const actualAmount = getAwardableCoins(amount);
      if (actualAmount <= 0) {
        showToast("Daily coin cap reached! ðŸª™");
        return;
      }

      // 1. Update State IMMEDIATELY
      state.coinBalance = (state.coinBalance || 0) + actualAmount;
      state.coinDayEarned = (state.coinDayEarned || 0) + actualAmount;
      state.coinWeekEarned = (state.coinWeekEarned || 0) + actualAmount;
      saveCoinBalance();
      updateCoinCounterDisplay();

      // 2. Play Sound/Animation
      playChaChingSound(0);

      // Bird Personality Reactions
      if (typeof squeak === "function") squeak(); // Happy squeak
      if (typeof speak === "function" && Math.random() > 0.6) {
        const praises = ["Great job!", "You did it!", "Keep going!", "Awesome!", "Woohoo!", "So productive!", "Proud of you!"];
        speak(praises[Math.floor(Math.random() * praises.length)]);
      }

      const counterEl = document.getElementById("coin-counter");
      if (counterEl) {
        counterEl.classList.add("pulse");
        setTimeout(() => counterEl.classList.remove("pulse"), 150);
      }

      // 3. Spawn Visuals (Fire and forget)
      if (counterEl && sourceElement) {
        // Pass 0 as coinsPerVisual because we already updated the balance
        spawnFlyingCoinsWithLanding(sourceElement.getBoundingClientRect(), counterEl.getBoundingClientRect(), Math.min(actualAmount, 8), 0, counterEl);
      }
    }

    // Deduct coins when unchecking a task
    function deductCoins(amount) {
      if (!isRewardEligible() || amount <= 0) return;

      // 1. Always decrement the "earned" counters so user can re-earn towards cap
      state.coinDayEarned = Math.max(0, (state.coinDayEarned || 0) - amount);
      state.coinWeekEarned = Math.max(0, (state.coinWeekEarned || 0) - amount);

      // 2. Decrement balance (floor at 0)
      const oldBalance = state.coinBalance;
      state.coinBalance = Math.max(0, oldBalance - amount);

      saveCoinBalance();
      updateCoinCounterDisplay(); // updates caps text and meter width

      // Play sad sound
      playDeductSound();

      // Animate counter if balance changed
      const counterEl = document.getElementById("coin-counter");
      if (counterEl && state.coinBalance !== oldBalance) {
        animateCoinCounter(oldBalance, state.coinBalance, 300);
        counterEl.classList.add("shake");
        setTimeout(() => counterEl.classList.remove("shake"), 400);
      }
    }

    // Spawn flying coins - use requestAnimationFrame for visible arc flight
    function spawnFlyingCoinsWithLanding(fromRect, toRect, count, coinsPerVisual, counterEl) {
      // Use viewport stats (Fixed positioning)
      const startX = fromRect.left + fromRect.width / 2;
      const startY = fromRect.top + fromRect.height / 2;
      const endX = toRect.left + toRect.width / 2;
      const endY = toRect.top + toRect.height / 2;

      for (let i = 0; i < count; i++) {
        const spawnDelay = i * 80; // Faster stagger

        setTimeout(() => {
          const coin = document.createElement("div");
          coin.className = "flying-coin";
          coin.textContent = "ðŸª™";
          coin.style.transform = "scale(0)";

          // Force styles in JS to ensure visibility
          coin.style.position = "fixed";
          coin.style.zIndex = "2147483647";

          // Randomize start position slightly
          const offsetX = (Math.random() - 0.5) * 40;
          const offsetY = (Math.random() - 0.5) * 40;
          const coinStartX = startX + offsetX;
          const coinStartY = startY + offsetY;

          coin.style.left = coinStartX + "px";
          coin.style.top = coinStartY + "px";
          document.body.appendChild(coin);

          // Flight parameters
          const duration = 600 + Math.random() * 200;
          const arcHeight = Math.min(150, Math.abs(endY - coinStartY) * 0.5 + 50);
          const startTime = performance.now();

          // Animate with requestAnimationFrame
          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Ease out cubic for smooth deceleration
            const eased = 1 - Math.pow(1 - progress, 3);

            // Calculate position with arc (parabolic curve)
            const x = coinStartX + (endX - coinStartX) * eased;
            // Arc: goes up then down using sine curve
            const arcOffset = Math.sin(progress * Math.PI) * arcHeight;
            const y = coinStartY + (endY - coinStartY) * eased - arcOffset;

            // Scale and rotation
            const scale = progress < 0.2
              ? progress * 5  // Pop in (0 to 1)
              : progress > 0.9
                ? 1 - (progress - 0.9) * 5  // Shrink at end
                : 1;
            const rotation = progress * 720;

            coin.style.left = x + "px";
            coin.style.top = y + "px";
            coin.style.transform = `scale(${scale}) rotate(${rotation}deg)`;

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Coin landed!
              playChaChingSound(i);

              // Increment balance
              state.coinBalance += coinsPerVisual;

              // Only save if meaningful
              if (coinsPerVisual > 0) saveCoinBalance();

              // Update counter with pulse
              if (typeof updateCoinCounterDisplay === "function") updateCoinCounterDisplay();

              if (counterEl) {
                counterEl.classList.add("pulse");
                setTimeout(() => counterEl.classList.remove("pulse"), 150);
              }

              // Remove coin
              coin.remove();
            }
          }

          requestAnimationFrame(animate);
        }, spawnDelay);
      }
    }

    // Animate coin counter from old to new value
    function animateCoinCounter(from, to, duration) {
      const amountEl = document.getElementById("coin-amount");
      if (!amountEl) return;

      const startTime = performance.now();
      const diff = to - from;

      function step(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        const current = Math.round(from + diff * eased);
        amountEl.textContent = current;
        if (progress < 1) {
          requestAnimationFrame(step);
        }
      }
      requestAnimationFrame(step);
    }

    // Play cha-ching coinslot sound using Web Audio API
    function playChaChingSound(index) {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        const now = audioContext.currentTime;

        // Create metallic "cha-ching" sound with multiple harmonics
        const fundamentalFreq = 1200 + (index * 80);

        // Main tone
        const osc1 = audioContext.createOscillator();
        const gain1 = audioContext.createGain();
        osc1.type = "square";
        osc1.frequency.setValueAtTime(fundamentalFreq, now);
        osc1.frequency.exponentialRampToValueAtTime(fundamentalFreq * 0.5, now + 0.15);
        gain1.gain.setValueAtTime(0, now);
        gain1.gain.linearRampToValueAtTime(0.12, now + 0.01);
        gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc1.connect(gain1);
        gain1.connect(audioContext.destination);
        osc1.start(now);
        osc1.stop(now + 0.2);

        // High metallic ping
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.type = "sine";
        osc2.frequency.setValueAtTime(fundamentalFreq * 2, now);
        osc2.frequency.exponentialRampToValueAtTime(fundamentalFreq * 1.5, now + 0.1);
        gain2.gain.setValueAtTime(0, now);
        gain2.gain.linearRampToValueAtTime(0.08, now + 0.005);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.start(now);
        osc2.stop(now + 0.15);

        // Low "clunk" for slot machine feel
        const osc3 = audioContext.createOscillator();
        const gain3 = audioContext.createGain();
        osc3.type = "triangle";
        osc3.frequency.setValueAtTime(200, now);
        osc3.frequency.exponentialRampToValueAtTime(80, now + 0.05);
        gain3.gain.setValueAtTime(0.1, now);
        gain3.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc3.connect(gain3);
        gain3.connect(audioContext.destination);
        osc3.start(now);
        osc3.stop(now + 0.1);

      } catch (e) {
        // Silently fail
      }
    }

    // --- BIRD SYSTEM LOGIC ---

    let birdState = {
      isHappy: false,
      pettingScore: 0,
      lastMouseX: 0,
      blinkTimer: null
    };

    function initBirdSystem() {
      const svgContainer = document.getElementById("finch-svg");
      if (!svgContainer) return;

      // Render Bird SVG (Refined "Round Blob" Finch Style)
      // Reference Colors: Pink Body (#f9a8d4), Yellow Cap/Wings (#fde047), Blue Tummy (#60a5fa)
      svgContainer.innerHTML = `
        <g id="bird-whole" transform="translate(100, 110) scale(1.4)">
           <g class="bird-anim-wrapper">
             <!-- Legs (Orange) -->
             <path class="bird-foot-l" d="M -20 70 Q -30 75 -40 70 L -35 60 L -20 50" fill="#f97316" stroke="#ea580c" stroke-width="2.5" stroke-linecap="round" />
             <path class="bird-foot-r" d="M 20 70 Q 30 75 40 70 L 35 60 L 20 50" fill="#f97316" stroke="#ea580c" stroke-width="2.5" stroke-linecap="round" />
 
             <!-- Body (Large Pink Blob) -->
             <!-- Rounder, fuller bottom -->
             <path class="bird-body" d="M -55 20 C -65 -20 -40 -60 0 -60 C 40 -60 65 -20 55 20 C 50 70 -50 70 -55 20 Z" fill="#f9a8d4" />
 
             <!-- Head Cap (Yellow) -->
             <!-- Follows top contour of body, comes down to forehead -->
             <path class="bird-head" d="M -48 -25 C -40 -50 -20 -60 0 -60 C 20 -60 40 -50 48 -25 C 25 -10 -25 -10 -48 -25 Z" fill="#fde047" />
 
             <!-- Tummy (Blue) -->
             <!-- Large round oval -->
             <ellipse class="bird-tummy" cx="0" cy="35" rx="38" ry="32" fill="#60a5fa" />
 
             <!-- Wings (Yellow) - Bigger and Rounder -->
             <!-- Sticking out more noticeably -->
             <path class="bird-wing-l" d="M -53 10 Q -85 15 -75 45 Q -60 50 -50 35" fill="#fde047" stroke="#eab308" stroke-width="1.5" />
             <path class="bird-wing-r" d="M 53 10 Q 85 15 75 45 Q 60 50 50 35" fill="#fde047" stroke="#eab308" stroke-width="1.5" />
 
             <!-- Face -->
             <g id="bird-face" transform="translate(0, -25)">
               <!-- Cheeks (Pinker) -->
               <circle cx="-32" cy="15" r="9" fill="#f472b6" opacity="0.6" />
               <circle cx="32" cy="15" r="9" fill="#f472b6" opacity="0.6" />
 
               <!-- Beak (Orange/Yellow) -->
               <path class="bird-beak" d="M -8 10 Q 0 18 8 10 L 0 4 Z" fill="#facc15" stroke="#ca8a04" stroke-width="1.5" />
 
               <!-- Eyes -->
               <g id="eyes-open">
                 <circle cx="-18" cy="0" r="7.5" fill="#1f2937" />
                 <circle cx="18" cy="0" r="7.5" fill="#1f2937" />
                 <circle cx="-15" cy="-3" r="2.5" fill="#fff" />
                 <circle cx="21" cy="-3" r="2.5" fill="#fff" />
               </g>
               
               <!-- Eyes Closed/Happy -->
               <g id="eyes-closed" style="display:none">
                 <path d="M -24 5 Q -18 10 -12 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
                 <path d="M 12 5 Q 18 10 24 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
               </g>
               <g id="eyes-happy" style="display:none">
                  <path d="M -24 5 Q -18 -5 -12 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
                  <path d="M 12 5 Q 18 -5 24 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
               </g>
             </g>
           </g>
         </g>
      `;

      // Start interactions
      startBlinking();
      setupPetting();
      updateBirdEnergy(); // Init meter

      // Init Personality (Audio/Speech)
      initBirdPersonality();
    }

    // --- Bird Personality System ---
    let birdName = null;
    let birdColors = {
      body: "#f9a8d4",
      head: "#fde047",
      tummy: "#60a5fa",
      wings: "#fde047"
    };

    let squeaksMuted = localStorage.getItem("bird_squeaks_muted") === "true";
    let speechTimer = null;

    function initBirdEditor() {
      const modal = document.getElementById("bird-editor-modal");
      const openBtn = document.getElementById("edit-bird-trigger");
      const closeBtn = document.getElementById("close-bird-editor");
      const cancelBtn = document.getElementById("cancel-bird-editor");
      const saveBtn = document.getElementById("save-bird-editor");
      const nameInput = document.getElementById("bird-name-input");

      if (!modal || !openBtn) return;

      // Color Controls Generation
      const colorControls = document.getElementById("bird-color-controls");
      if (colorControls) {
        colorControls.innerHTML = "";
        const parts = [
          { id: "body", label: "Body Color" },
          { id: "head", label: "Head/Cap" },
          { id: "tummy", label: "Tummy" },
          { id: "wings", label: "Wings" }
        ];

        parts.forEach(part => {
          const row = document.createElement("div");
          row.style.marginBottom = "10px";

          const label = document.createElement("div");
          label.textContent = part.label;
          label.style.fontSize = "12px";
          label.style.fontWeight = "600";
          label.style.marginBottom = "4px";

          const input = document.createElement("input");
          input.type = "color";
          input.value = birdColors[part.id] || "#ffffff";
          input.style.width = "100%";
          input.style.height = "30px";
          input.style.cursor = "pointer";
          input.dataset.partId = part.id;

          input.addEventListener("input", (e) => {
            const val = e.target.value;
            // Live preview on the Main Bird (and the preview bird if we copy it)
            // For simplicity, we just apply to the main bird immediately for preview
            // In a real modal we might want a separate preview SVG, but let's just use the main one logic
            // Actually the modal has a #bird-editor-preview SVG. Let's start by copying the bird there.

            // Update preview bird
            const previewSvg = document.getElementById("bird-editor-preview");
            if (previewSvg) {
              const els = previewSvg.querySelectorAll(part.id === 'wings' ? '.bird-wing-l, .bird-wing-r' : `.bird-${part.id}`);
              els.forEach(el => el.setAttribute("fill", val));
            }
          });

          row.appendChild(label);
          row.appendChild(input);
          colorControls.appendChild(row);
        });
      }

      openBtn.addEventListener("click", () => {
        // Copy current bird state to modal
        nameInput.value = birdName || "";

        // Copy SVG to preview
        const mainSvg = document.getElementById("finch-svg");
        const previewSvg = document.getElementById("bird-editor-preview");
        if (mainSvg && previewSvg) {
          previewSvg.innerHTML = mainSvg.innerHTML;
        }

        // Reset color inputs
        const inputs = colorControls.querySelectorAll("input[type='color']");
        inputs.forEach(input => {
          const part = input.dataset.partId;
          if (birdColors[part]) input.value = birdColors[part];
        });

        modal.style.display = "flex";
      });

      const close = () => modal.style.display = "none";
      closeBtn.addEventListener("click", close);
      cancelBtn.addEventListener("click", close);

      saveBtn.addEventListener("click", async () => {
        const newName = nameInput.value.trim();

        // Collect colors
        const newColors = { ...birdColors };
        const inputs = colorControls.querySelectorAll("input[type='color']");
        inputs.forEach(input => {
          newColors[input.dataset.partId] = input.value;
        });

        // 1. Update State
        birdName = newName;
        birdColors = newColors;
        updateBirdNameUI();
        currentBirdColors = newColors; // Sync both color states
        applyBirdColors(currentBirdColors); // Apply to main bird

        // 2. Persist
        if (state.currentUser) {
          try {
            await saveUserDbPreference("bird_name", newName);
            await saveUserDbPreference("bird_colors", newColors); // Will be JSON stringified by our updated saveUserDbPreference logic? 
            // Wait, saveUserDbPreference takes (key, value) and sends { [key]: value }. 
            // My updated Wrap.js accepts bird_colors in body.
            // But saveUserDbPreference calls apiSend with { [key]: value }.
            // If I call saveUserDbPreference("bird_colors", object), it sends { bird_colors: object }.
            // JSON.stringify happens in apiSend? No, apiSend does JSON.stringify(body).
            // So if value is an object, it gets stringified into the body JSON.
            // The backend logic I wrote: body.bird_colors ? JSON.stringify(body.bird_colors) : null
            // If body.bird_colors is ALREADY an object (from JSON parsing the request body), then JSON.stringify(object) works.
            // Yes, standard fetch sends JSON. 
            showToast("Bird saved!");
          } catch (e) {
            console.error(e);
            showToast("Error saving bird", true);
          }
        }

        close();
      });
    }

    function initBirdPersonality() {
      // 0. Init Editor
      initBirdEditor();

      // 1. Mute Button
      const muteBtn = document.getElementById("bird-mute-btn");
      if (muteBtn) {
        updateMuteUI();
        muteBtn.addEventListener("click", toggleMute);
      }

      // 2. Random Encouragement Loop
      if (speechTimer) clearInterval(speechTimer);
      speechTimer = setInterval(() => {
        // 10% chance every minute to show a random message
        if (Math.random() < 0.1) {
          const idleMessages = [
            // Original messages
            "Tweet?", "I believe in you!", "*hop*", "Don't give up!", "You got this!", "*flutter*",
            // Wellness reminders
            "Did you stretch today?", "Did you drink enough water?", "Are you protecting your peace today?",
            "Take a deep breath! ðŸŒ¬ï¸", "Have you taken a break recently?", "How's your posture right now?",
            "Remember to blink! ðŸ‘€", "Stand up and stretch!", "You're doing amazing!",
            "What's one thing you're grateful for?", "Smile! Even if no one's watching.", "Your goals matter!",
            "Small steps = big progress!", "Be kind to yourself today.", "Celebrate your wins! ðŸŽ‰"
          ];
          const msg = idleMessages[Math.floor(Math.random() * idleMessages.length)];
          squeak(); // Chirp before speaking
          speak(msg);
        }
      }, 60000);

      // 3. Update Name UI
      updateBirdNameUI();
    }

    // Bird name and preferences helper functions
    function updateBirdNameUI() {
      const el = document.getElementById("bird-name-display");
      if (el) {
        el.textContent = birdName || "Bird";
      }
    }

    async function saveUserDbPreference(key, value) {
      if (!state.currentUser) return;
      try {
        const payload = {};
        payload[key] = value;

        await fetch(`${API_BASE}/user-preferences/${state.currentUser.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        // Also update local state
        if (key === 'bird_name') birdName = value;
        if (key === 'bird_colors') {
          birdColors = (typeof value === 'string') ? JSON.parse(value) : value;
        }
      } catch (e) {
        console.error("Failed to save preference:", e);
      }
    }

    async function loadUserDbPreferences() {
      if (!state.currentUser) return;
      try {
        const res = await fetch(`${API_BASE}/user-preferences/${state.currentUser.id}`);
        if (res.ok) {
          const data = await res.json();
          state.userDbPrefs = data;

          if (data.bird_name) {
            birdName = data.bird_name;
            updateBirdNameUI();
          }
          if (data.bird_colors) {
            let colors = data.bird_colors;
            if (typeof colors === "string") {
              try { colors = JSON.parse(colors); } catch (e) { }
            }
            birdColors = colors;
            applyBirdColors(colors);
          }
        }
      } catch (e) {
        console.error("Failed to load user preferences:", e);
      }
    }

    async function loadBirdPreferences() {
      if (!state.currentUser) return;
      try {
        const res = await fetch(`${API_BASE}/user-preferences/${state.currentUser.id}`);
        if (res.ok) {
          const data = await res.json();
          if (data.bird_name) {
            birdName = data.bird_name;
            updateBirdNameUI();
          }
          if (data.bird_colors) {
            let colors = data.bird_colors;
            if (typeof colors === "string") {
              try { colors = JSON.parse(colors); } catch (e) { }
            }
            birdColors = colors;
            // SYNC with global editor state
            if (typeof currentBirdColors !== 'undefined') {
              currentBirdColors = { ...DEFAULT_BIRD_COLORS, ...colors };
            }
            applyBirdColors(colors);
          }
        }
      } catch (e) {
        console.error("Failed to load bird preferences:", e);
      }
    }

    function applyBirdColors(colors) {
      if (!colors) colors = birdColors;
      const svg = document.getElementById("finch-svg");
      if (!svg) return;

      if (colors.body) {
        svg.querySelectorAll(".bird-body").forEach(el => el.setAttribute("fill", colors.body));
      }
      if (colors.head) {
        svg.querySelectorAll(".bird-head").forEach(el => el.setAttribute("fill", colors.head));
      }
      if (colors.tummy) {
        svg.querySelectorAll(".bird-tummy").forEach(el => el.setAttribute("fill", colors.tummy));
      }
      if (colors.wings) {
        svg.querySelectorAll(".bird-wing-l, .bird-wing-r").forEach(el => el.setAttribute("fill", colors.wings));
      }
    }

    function updateMuteUI() {
      const muteBtn = document.getElementById("bird-mute-btn");
      if (muteBtn) {
        muteBtn.innerHTML = `<span class="btn-icon">${squeaksMuted ? "ðŸ”‡" : "ðŸ”Š"}</span> <span class="btn-label">Mute</span>`;
        muteBtn.classList.toggle("muted", squeaksMuted);
        muteBtn.title = squeaksMuted ? "Unmute Squeaks" : "Mute Squeaks";
      }
    }

    function toggleMute() {
      squeaksMuted = !squeaksMuted;
      localStorage.setItem("bird_squeaks_muted", squeaksMuted);
      updateMuteUI();
      if (!squeaksMuted) squeak(); // Confirmation squeak
    }

    // Web Audio API Context
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();

    function squeak() {
      if (squeaksMuted) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();

      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      // Finch-like chirp: high pitch, rapid drop
      // Start high
      const now = audioCtx.currentTime;
      osc.type = 'sine';
      osc.frequency.setValueAtTime(2000 + Math.random() * 500, now);
      osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);

      // Envelope
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(0.1, now + 0.02);
      gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

      osc.start(now);
      osc.stop(now + 0.2);
    }


    function speak(text) {
      const bubble = document.getElementById("bird-speech-bubble");
      if (!bubble) return;

      bubble.textContent = text;
      bubble.classList.remove("hidden");
      // Trigger reflow/animation
      requestAnimationFrame(() => {
        bubble.classList.add("visible");
      });

      // Play sound if acceptable? Squeak on speak?
      // squeak(); 

      // Hide after 4 seconds
      setTimeout(() => {
        bubble.classList.remove("visible");
        setTimeout(() => bubble.classList.add("hidden"), 300);
      }, 4000);
    }

    function updateBirdNameUI() {
      const display = document.getElementById("bird-name-display");
      if (display) {
        display.textContent = birdName || "";
      }
    }

    function startBlinking() {
      // Random blink interval between 2s and 6s
      const nextBlink = 2000 + Math.random() * 4000;

      birdState.blinkTimer = setTimeout(() => {
        if (!birdState.isHappy) { // Don't blink if happy (closed eyes)
          toggleEyes(false); // Close
          setTimeout(() => toggleEyes(true), 150); // Open
        }
        startBlinking();
      }, nextBlink);
    }

    function toggleEyes(isOpen) {
      const open = document.getElementById("eyes-open");
      const closed = document.getElementById("eyes-closed");
      if (open && closed) {
        open.style.display = isOpen ? "block" : "none";
        closed.style.display = isOpen ? "none" : "block";
      }
    }

    function setExpression(type) { // 'normal', 'happy'
      const open = document.getElementById("eyes-open");
      const closed = document.getElementById("eyes-closed");
      const happy = document.getElementById("eyes-happy");

      if (!open || !happy) return;

      if (type === 'happy') {
        open.style.display = "none";
        closed.style.display = "none";
        happy.style.display = "block";
      } else {
        open.style.display = "block";
        closed.style.display = "none";
        happy.style.display = "none";
      }
    }

    function setupPetting() {
      const wrapper = document.getElementById("finch-container");
      if (!wrapper) return;

      wrapper.addEventListener("click", () => {
        // Click to pet/poke
        birdState.pettingScore += 50;
        triggerBirdCelebration();
      });

      wrapper.addEventListener("mousemove", (e) => {
        // Calculate movement speed/distance
        const dist = Math.abs(e.movementX) + Math.abs(e.movementY);

        if (dist > 5) {
          birdState.pettingScore += dist;

          if (birdState.pettingScore > 300 && !birdState.isHappy) {
            triggerBirdCelebration();
          }
        }
      });

      wrapper.addEventListener("mouseleave", () => {
        birdState.pettingScore = 0;
        if (birdState.isHappy) {
          stopHappyBird();
        }
      });
    }

    function triggerBirdCelebration() {
      if (birdState.isHappy) return;
      birdState.isHappy = true;
      setExpression('happy');

      // Add celebrating class for CSS animations
      const container = document.getElementById("finch-container");
      if (container) container.classList.add("bird-celebrating");

      // Happy chirp!
      squeak();

      // Random celebration message
      const celebMessages = [
        "Yay!", "Woohoo!", "Great job!", "So proud!", "Level up!", "You did it!",
        "Fantastic!", "Keep it up!", "You're on fire!", "Booyah!"
      ];
      if (Math.random() < 0.3) {
        speak(celebMessages[Math.floor(Math.random() * celebMessages.length)]);
      }

      // Spawn hearts
      spawnHeart();

      // Revert after a few seconds
      setTimeout(() => {
        stopHappyBird();
      }, 3500);
    }

    function stopHappyBird() {
      birdState.isHappy = false;
      setExpression('normal');

      const container = document.getElementById("finch-container");
      if (container) container.classList.remove("bird-celebrating");
    }





    function spawnHeart() {
      if (!birdState.isHappy) return;

      const container = document.getElementById("finch-hearts");
      if (!container) return;

      const heart = document.createElement("div");
      heart.className = "pet-heart";
      heart.textContent = "â¤ï¸";
      // Random position near head
      const left = 30 + Math.random() * 60; // Roughly centered
      const top = 20 + Math.random() * 20;

      heart.style.left = left + "%";
      heart.style.top = top + "%";

      container.appendChild(heart);

      // Clean up
      setTimeout(() => heart.remove(), 1000);

      // Continue spawning if still happy and moving
      if (birdState.pettingScore > 0) {
        setTimeout(spawnHeart, 400 + Math.random() * 400);
      }
    }

    function updateBirdEnergy() {
      const fill = document.getElementById("bird-energy-fill");
      if (fill) {
        const earned = state.coinDayEarned || 0;
        const pct = Math.min(100, (earned / COIN_DAILY_CAP) * 100);
        fill.style.width = pct + "%";

        // Update label
        const txt = document.getElementById("bird-energy-text");
        if (txt) txt.textContent = `${earned}/${COIN_DAILY_CAP}`;
      }
    }

    // --- BIRD EDITOR LOGIC ---

    // Default Colors
    const DEFAULT_BIRD_COLORS = {
      head: "#fde047",
      body: "#f9a8d4",
      tummy: "#60a5fa",
      wings: "#fde047",
      beak: "#facc15",
      feet: "#f97316"
    };

    let currentBirdColors = { ...DEFAULT_BIRD_COLORS };

    async function loadBirdPreferences() {
      // 1. Try to load from local storage first for speed
      if (state.currentUser) {
        try {
          // Attempt to fetch from API
          // Endpoint: /api/user-preferences/:id
          const prefs = await apiGet(`/user-preferences/${state.currentUser.id}`);

          let savedColors = prefs ? (prefs.bird_colors || prefs.birdColors) : null;
          if (typeof savedColors === 'string') {
            try { savedColors = JSON.parse(savedColors); } catch (e) { }
          }

          // Load Name
          birdName = prefs ? prefs.bird_name : null;
          updateBirdNameUI();

          if (savedColors) {
            currentBirdColors = { ...DEFAULT_BIRD_COLORS, ...savedColors };
            applyBirdColors(currentBirdColors);
          }
        } catch (e) {
          console.warn("Could not load bird prefs", e);
        }
      }
    }

    function applyBirdColors(colors, targetSvgId = "bird-whole") {
      // Guard against undefined colors
      if (!colors) {
        colors = currentBirdColors || DEFAULT_BIRD_COLORS;
      }
      // Apply colors to specific elements via CSS selection
      // Target can be main bird or preview bird
      const root = document.getElementById(targetSvgId);
      if (!root) return;

      const setFill = (cls, val) => {
        root.querySelectorAll(`.${cls}`).forEach(el => el.setAttribute("fill", val));
      };
      const setStroke = (cls, val) => {
        // For beak/wings, we might also want to darken stroke automatically?
        // For now just fill, we kept strokes hardcoded or could derive them.
        root.querySelectorAll(`.${cls}`).forEach(el => el.setAttribute("fill", val));
      };

      setFill("bird-head", colors.head);
      setFill("bird-body", colors.body);
      setFill("bird-tummy", colors.tummy);
      setFill("bird-wing-l", colors.wings);
      setFill("bird-wing-r", colors.wings);
      setFill("bird-beak", colors.beak);
      setFill("bird-foot-l", colors.feet);
      setFill("bird-foot-r", colors.feet);
    }

    function openBirdEditor() {
      const modal = document.getElementById("bird-editor-modal");
      const previewSvg = document.getElementById("bird-editor-preview");
      const controls = document.getElementById("bird-color-controls");
      const nameInput = document.getElementById("bird-name-input");

      if (!modal || !previewSvg || !controls) return;

      // Pre-fill name
      if (nameInput) nameInput.value = birdName || "";

      // 1. Clone current bird to preview
      const mainBirdGroup = document.getElementById("bird-whole");
      if (mainBirdGroup) {
        previewSvg.innerHTML = ""; // Clear
        const clone = mainBirdGroup.cloneNode(true);
        clone.id = "bird-preview-group";
        // Scale up significantly (2.2) to fill the modal box
        clone.setAttribute("transform", "translate(100, 110) scale(2.2)");
        previewSvg.appendChild(clone);
      }

      // 2. Render Color Controls
      const parts = [
        { id: "head", label: "Head Cap" },
        { id: "body", label: "Body" },
        { id: "tummy", label: "Tummy" },
        { id: "wings", label: "Wings" },
        { id: "beak", label: "Beak" },
        { id: "feet", label: "Feet" }
      ];

      controls.innerHTML = parts.map(part => `
         <div class="color-control-group">
            <label>${part.label}</label>
            <div class="color-picker-row">
               <input type="color" class="color-input-styled" 
                      data-part="${part.id}" 
                      value="${currentBirdColors[part.id]}"
                      oninput="handleColorChange('${part.id}', this.value)">
            </div>
         </div>
       `).join("");

      modal.style.display = "flex";
      applyBirdColors(currentBirdColors, "bird-preview-group");
    }

    window.handleColorChange = (part, value) => {
      try {
        // Debug Feedback
        const label = document.getElementById("bird-preview-label");
        if (label) label.textContent = `Preview: ${part} -> ${value}`;

        // Update preview only
        const previewColors = { ...currentBirdColors };
        if (!previewColors) {
          console.error("currentBirdColors is missing!");
          if (label) label.textContent = "Error: Colors missing";
          return;
        }

        previewColors[part] = value;
        if (currentBirdColors) currentBirdColors[part] = value;

        // Force direct update if applyBirdColors is flaky
        const previewGroup = document.getElementById("bird-preview-group");
        if (previewGroup) {
          const el = previewGroup.querySelector(`.bird-${part}`);
          if (el) el.setAttribute("fill", value);
          else if (label) label.textContent += " (no element)";

          // Still try global apply (handles secondary parts like wings-r)
          // applyBirdColors(previewColors, "bird-preview-group");
          // actually let's replicate applyBirdColors for wings/feet which have pairs
          if (part === 'wings') {
            previewGroup.querySelectorAll('.bird-wing-l, .bird-wing-r').forEach(e => e.setAttribute('fill', value));
          } else if (part === 'feet') {
            previewGroup.querySelectorAll('.bird-foot-l, .bird-foot-r').forEach(e => e.setAttribute('fill', value));
          } else {
            // single elements like head, body, tummy, beak
            const e = previewGroup.querySelector(`.bird-${part}`);
            if (e) e.setAttribute('fill', value);
          }
        } else {
          if (label) label.textContent += " (no group)";
        }
      } catch (e) {
        console.error("handleColorChange error:", e);
        showToast("Error: " + e.message);
      }
    };

    function closeBirdEditor() {
      document.getElementById("bird-editor-modal").style.display = "none";
    }


    async function saveBirdColors() {
      const newColors = { ...currentBirdColors };
      document.querySelectorAll(".color-input-styled").forEach(input => {
        newColors[input.dataset.part] = input.value;
      });

      // 1. Update State
      currentBirdColors = newColors;

      // 2. Apply to Real Bird
      applyBirdColors(currentBirdColors, "bird-whole");

      // 3. Persist to DB
      if (state.currentUser) {
        // Show loading state
        const saveBtn = document.getElementById("save-bird-editor");
        const originalText = saveBtn ? saveBtn.textContent : "Save";
        if (saveBtn) {
          saveBtn.textContent = "Saving...";
          saveBtn.disabled = true;
        }

        birdName = document.getElementById("bird-name-input").value.trim() || null;
        updateBirdNameUI();

        try {
          // Await the API call to ensure it completes
          await apiSend(`/user-preferences/${state.currentUser.id}`, "PUT", {
            bird_colors: currentBirdColors,
            bird_name: birdName
          });
          showToast("Bird saved successfully!");

          // Only close if successful
          closeBirdEditor();
        } catch (e) {
          console.error("Save failed", e);
          showToast("Failed to save changes. Please try again.", true);
        } finally {
          // Reset button state
          if (saveBtn) {
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
          }
        }
      } else {
        // Guest mode - just close
        closeBirdEditor();
      }
    }




    // Initialize Editor Listeners
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => {
        try {
          initBirdSystem();
        } catch (e) {
          console.error("initBirdSystem failed:", e);
        }
        try {
          loadBirdPreferences(); // visual init
        } catch (e) {
          console.error("loadBirdPreferences failed:", e);
        }
      }, 1000);

      const editBtn = document.getElementById("edit-bird-trigger");
      if (editBtn) editBtn.addEventListener("click", openBirdEditor);

      const closeBtn = document.getElementById("close-bird-editor");
      const cancelBtn = document.getElementById("cancel-bird-editor");
      const saveBtn = document.getElementById("save-bird-editor");

      if (closeBtn) closeBtn.addEventListener("click", closeBirdEditor);
      if (cancelBtn) cancelBtn.addEventListener("click", closeBirdEditor);
      if (saveBtn) saveBtn.addEventListener("click", saveBirdColors);
    });

    // --- END BIRD EDITOR LOGIC ---

    // Play sad deduct sound
    function playDeductSound() {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const now = audioContext.currentTime;

        // Descending sad tone
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.start(now);
        osc.stop(now + 0.35);
      } catch (e) { }
    }

    // Play burst sound for bonus
    function playCoinBurstSound() {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const now = audioContext.currentTime;

        // Play ascending chord for jackpot feel
        [523, 659, 784, 880, 1047].forEach((freq, i) => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          osc.type = "sine";
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, now + i * 0.04);
          gain.gain.linearRampToValueAtTime(0.08, now + i * 0.04 + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.04 + 0.5);
          osc.connect(gain);
          gain.connect(audioContext.destination);
          osc.start(now + i * 0.04);
          osc.stop(now + i * 0.04 + 0.6);
        });
      } catch (e) { }
    }

    async function quickUpdateTaskStatus(task, newStatus) {
      const oldStatus = task.status || "pending";
      if (oldStatus === newStatus) return;

      // Optimistic UI
      task.status = newStatus;
      renderCalendar();

      try {
        await apiSend("/daily-tasks/" + task.id, "PATCH", { status: newStatus });

        if (newStatus === "done") {
          showToast("Task marked complete");
          checkDailyCompletion(task.task_date);

          // Award coins for task completion
          if (isRewardEligible()) {
            const pillEl = document.querySelector(`[data-task-id="${task.id}"]`);
            awardCoins(5, pillEl);
          }
        } else if (newStatus === "could_not_complete") {
          showToast("Task marked as could not complete");
          // Deduct coins if was previously done
          if (oldStatus === "done" && isRewardEligible()) {
            deductCoins(5);
          }
        } else {
          showToast("Task updated");
          // Deduct coins if was previously done (unchecked)
          if (oldStatus === "done" && isRewardEligible()) {
            deductCoins(5);
          }
        }

        // Reload to ensure we pick up any server-side changes (emails, timestamps, assignees)
        await loadDailyTasks();
      } catch (err) {
        console.error(err);
        // Revert on error
        task.status = oldStatus;
        renderCalendar();
        showToast("Error updating task status", true);
      }
    }


    const LOADER_MESSAGES = [
      {
        main: "Syncingâ€¦",
        sub: "Saving your change to the Wrap Sheet"
      },
      {
        main: "Updating tasksâ€¦",
        sub: "Pushing your edits to HQ"
      },
      {
        main: "Locking it inâ€¦",
        sub: "Your goals are being updated"
      },
      {
        main: "Polishing your wrapâ€¦",
        sub: "Making everything look just right"
      },
      {
        main: "Checking it twiceâ€¦",
        sub: "Confirming those changes with the cloud"
      }
    ];

    function pickLoaderMessage() {
      return LOADER_MESSAGES[
        Math.floor(Math.random() * LOADER_MESSAGES.length)
      ];
    }

    function showActionLoader(customMessage) {
      const loader = document.getElementById("action-loader");
      if (!loader) return;

      const mainEl = document.getElementById("action-loader-main");
      const subEl = document.getElementById("action-loader-sub");

      const msg = customMessage || pickLoaderMessage();

      if (typeof msg === "string") {
        mainEl.textContent = msg;
        subEl.textContent = "One sec while we save thatâ€¦";
      } else {
        mainEl.textContent = msg.main || "Syncingâ€¦";
        subEl.textContent = msg.sub || "Saving your changeâ€¦";
      }

      loader.classList.add("show");
    }

    function hideActionLoader() {
      const loader = document.getElementById("action-loader");
      if (!loader) return;
      loader.classList.remove("show");
    }


    // ===== UTILITIES =====
    function pad2(n) {
      return String(n).padStart(2, "0");
    }

    function monthKeyFromDate(d) {
      return d.getFullYear() + "-" + pad2(d.getMonth() + 1);
    }

    function dateKey(y, mIndexZeroBased, day) {
      return y + "-" + pad2(mIndexZeroBased + 1) + "-" + pad2(day);
    }

    function addDays(date, days) {
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      d.setDate(d.getDate() + days);
      return d;
    }

    function parseDateKey(key) {
      const [y, m, d] = key.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function formatDateKeyFromDate(d) {
      return dateKey(d.getFullYear(), d.getMonth(), d.getDate());
    }

    // Move a date to a nearby weekday if it falls on a weekend.
    // Sat -> Friday, Sun -> Monday.
    function adjustToBusinessDay(d) {
      const weekday = d.getDay();
      if (weekday === 6) {
        // Saturday -> Friday
        d.setDate(d.getDate() - 1);
      } else if (weekday === 0) {
        // Sunday -> Monday
        d.setDate(d.getDate() + 1);
      }
      return d;
    }

    // e.g. "2nd Tuesday of the month"
    function nthWeekdayOfMonth(year, monthIndex0, weekday, nth) {
      const first = new Date(year, monthIndex0, 1);
      const offset = (weekday - first.getDay() + 7) % 7;
      const day = 1 + offset + (nth - 1) * 7;

      const daysInMonth = new Date(year, monthIndex0 + 1, 0).getDate();
      if (day > daysInMonth) return null;

      return new Date(year, monthIndex0, day);
    }

    /**
     * Compute future dates for a repeated task between a start & end date.
     *
     * baseDateStr: the date of the task in the modal, "YYYY-MM-DD"
     * repeatType: "weekly" | "monthly_date" | "monthly_weekday"
     * seriesStartStr: "YYYY-MM-DD" (when the series is allowed to start)
     * seriesEndStr: "YYYY-MM-DD" (inclusive)
     *
     * Returns array of "YYYY-MM-DD" strings for FUTURE dates only (not including base).
     */
    function computeRecurringDatesBetween(baseDateStr, repeatType, seriesStartStr, seriesEndStr) {
      if (!baseDateStr || repeatType === "none" || !seriesEndStr) return [];

      const base = parseDateKey(baseDateStr);
      const seriesStart = seriesStartStr ? parseDateKey(seriesStartStr) : base;
      const seriesEnd = parseDateKey(seriesEndStr);

      // If end is before base, nothing to do
      if (seriesEnd < base) return [];

      const results = [];
      const maxOccurrences = 120; // safety cap so you don't accidentally spam the year

      if (repeatType === "daily") {
        // Daily (Mon-Fri): create task for each weekday between base and end
        let current = new Date(base);
        while (true) {
          current = addDays(current, 1);
          if (current > seriesEnd || results.length >= maxOccurrences) break;
          const dayOfWeek = current.getDay();
          // Only include weekdays (1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri)
          if (dayOfWeek >= 1 && dayOfWeek <= 5 && current >= seriesStart) {
            results.push(formatDateKeyFromDate(current));
          }
        }
      } else if (repeatType === "weekly") {
        let current = new Date(base);
        while (true) {
          current = addDays(current, 7);
          if (current > seriesEnd || results.length >= maxOccurrences) break;
          if (current >= seriesStart) {
            results.push(formatDateKeyFromDate(current));
          }
        }
      } else if (repeatType === "biweekly") {
        // Every 2 weeks (14 days)
        let current = new Date(base);
        while (true) {
          current = addDays(current, 14);
          if (current > seriesEnd || results.length >= maxOccurrences) break;
          if (current >= seriesStart) {
            results.push(formatDateKeyFromDate(current));
          }
        }
      } else if (repeatType === "monthly_date") {
        const dayOfMonth = base.getDate();
        let y = base.getFullYear();
        let m = base.getMonth();

        while (true) {
          m++;
          if (m > 11) {
            m = 0;
            y++;
          }
          const daysInMonth = new Date(y, m + 1, 0).getDate();
          const safeDay = Math.min(dayOfMonth, daysInMonth);
          let cand = new Date(y, m, safeDay);
          cand = adjustToBusinessDay(cand);
          if (cand > seriesEnd || results.length >= maxOccurrences) break;
          if (cand >= seriesStart && cand > base) {
            results.push(formatDateKeyFromDate(cand));
          }
        }
      } else if (repeatType === "monthly_weekday") {
        const weekday = base.getDay(); // 0â€“6
        const nth = Math.floor((base.getDate() - 1) / 7) + 1; // 1st, 2nd, 3rdâ€¦

        let y = base.getFullYear();
        let m = base.getMonth();

        while (true) {
          m++;
          if (m > 11) {
            m = 0;
            y++;
          }

          const cand = nthWeekdayOfMonth(y, m, weekday, nth);
          if (!cand) continue;

          if (cand > seriesEnd || results.length >= maxOccurrences) break;
          if (cand >= seriesStart && cand > base) {
            results.push(formatDateKeyFromDate(cand));
          }
        }
      } else if (repeatType === "yearly") {
        // Same date each year
        const dayOfMonth = base.getDate();
        const monthOfYear = base.getMonth();
        let y = base.getFullYear();

        while (true) {
          y++;
          const daysInMonth = new Date(y, monthOfYear + 1, 0).getDate();
          const safeDay = Math.min(dayOfMonth, daysInMonth);
          let cand = new Date(y, monthOfYear, safeDay);
          cand = adjustToBusinessDay(cand);
          if (cand > seriesEnd || results.length >= maxOccurrences) break;
          if (cand >= seriesStart && cand > base) {
            results.push(formatDateKeyFromDate(cand));
          }
        }
      }

      return results;
    }



    function getWeekStart(date, weekStartsOnMonday = false) {
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      const day = d.getDay(); // 0â€“6 (Sunâ€“Sat)
      let diff;
      if (weekStartsOnMonday) {
        diff = day === 0 ? -6 : 1 - day;
      } else {
        diff = -day;
      }
      d.setDate(d.getDate() + diff);
      return d;
    }

    function getVisibleDateRange() {
      const base = state.currentMonthDate;
      const year = base.getFullYear();
      const month = base.getMonth();

      if (state.calendarView === "month") {
        const first = dateKey(year, month, 1);
        const lastDay = new Date(year, month + 1, 0).getDate();
        const last = dateKey(year, month, lastDay);
        return [first, last];
      }

      const isWorkweek = state.calendarView === "workweek" || state.calendarView === "jointweek";
      const weekStart = getWeekStart(base, isWorkweek);
      const daysCount = isWorkweek ? 4 : 6; // inclusive end
      const startKey = dateKey(
        weekStart.getFullYear(),
        weekStart.getMonth(),
        weekStart.getDate()
      );
      const weekEnd = addDays(weekStart, daysCount);
      const endKey = dateKey(
        weekEnd.getFullYear(),
        weekEnd.getMonth(),
        weekEnd.getDate()
      );
      return [startKey, endKey];
    }

    function showToast(message, isError = false) {
      const toast = document.getElementById("toast");
      toast.textContent = "";
      const span = document.createElement("span");
      span.textContent = message;
      toast.appendChild(span);
      toast.style.borderColor = isError ? "#f97373" : "rgba(148,163,184,0.7)";
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 2800);
    }

    async function apiGet(path) {


      const res = await fetch(API_BASE + path, {
        headers: { "Accept": "application/json" }
      });
      if (!res.ok) throw new Error("GET " + path + " failed");
      return res.json();
    }

    async function apiSend(path, method, body) {
      showActionLoader(); // TikTok-style popup



      // random delay between 500ms and 2000ms
      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        const fetchPromise = fetch(API_BASE + path, {
          method,
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          body: JSON.stringify(body)
        });

        // Wait for BOTH: the network AND the fake delay
        const res = await Promise.all([fetchPromise, delayPromise]).then(
          ([res]) => res
        );

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          throw new Error(method + " " + path + " failed: " + text);
        }

        // Handle empty responses (common for DELETE with 204 No Content)
        const text = await res.text();
        if (!text || text.trim() === "") {
          return null;
        }
        const data = JSON.parse(text);
        return data;
      } catch (e) {
        throw e;
      } finally {
        hideActionLoader();
      }
    }

    async function createMultipleTasks(payloads, loaderMessage) {
      if (!payloads || !payloads.length) return;

      showActionLoader(
        loaderMessage || {
          main: "Creating repeated tasksâ€¦",
          sub: "Adding them to your Wrap Sheet"
        }
      );

      const delayMs = 600 + Math.random() * 1200;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        const fetches = payloads.map(p =>
          fetch(API_BASE + "/daily-tasks", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
            },
            body: JSON.stringify(p)
          })
        );

        const responsesPlusDelay = await Promise.all([...fetches, delayPromise]);
        const responses = responsesPlusDelay.slice(0, -1); // strip delay

        for (const res of responses) {
          if (!res.ok) {
            const text = await res.text().catch(() => "");
            throw new Error("POST /daily-tasks failed: " + text);
          }
        }
      } finally {
        hideActionLoader();
      }
    }


    function applyTheme(theme) {
      const safeTheme = theme === "dark" ? "dark" : "light";
      state.theme = safeTheme;
      document.body.dataset.theme = safeTheme;

      const select = document.getElementById("theme-select");
      if (select && select.value !== safeTheme) {
        select.value = safeTheme;
      }

      try {
        localStorage.setItem("wrapsheet-theme", safeTheme);
        saveUserDbPreference("theme", safeTheme);
      } catch {
        // ignore storage errors
      }
    }

    function initTheme() {
      let stored = null;
      try {
        stored = localStorage.getItem("wrapsheet-theme");
      } catch {
        stored = null;
      }
      const initial = stored === "dark" ? "dark" : "light";
      applyTheme(initial);
    }


    // ===== LIVE SYNC =====
    const LIVE_SYNC_INTERVAL_MS = 300000; // 5 minutes
    const TYPING_COOLDOWN_MS = 30000; // 30 seconds after typing before sync
    let liveSyncIntervalId = null;
    let lastUserTypingTime = 0;

    // Track user typing activity
    document.addEventListener("input", () => {
      lastUserTypingTime = Date.now();
    });

    function startLiveSync() {
      if (liveSyncIntervalId) return; // Already running
      console.log("[LiveSync] Starting with interval:", LIVE_SYNC_INTERVAL_MS, "ms");
      liveSyncIntervalId = setInterval(() => {
        if (document.visibilityState === "visible") {
          // Check if user was typing recently
          const timeSinceTyping = Date.now() - lastUserTypingTime;
          if (timeSinceTyping < TYPING_COOLDOWN_MS) {
            console.log("[LiveSync] Skipping - user was typing recently (", Math.round(timeSinceTyping / 1000), "s ago)");
            return;
          }
          console.log("[LiveSync] Refreshing data...");
          refreshAllData(true); // silent=true to avoid toasts
        }
      }, LIVE_SYNC_INTERVAL_MS);
      // Also refresh immediately when tab becomes visible after being hidden
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    function onVisibilityChange() {
      if (document.visibilityState === "visible" && liveSyncIntervalId) {
        // Check if user was typing recently before syncing on visibility change
        const timeSinceTyping = Date.now() - lastUserTypingTime;
        if (timeSinceTyping < TYPING_COOLDOWN_MS) {
          console.log("[LiveSync] Tab visible but skipping sync - user was typing recently");
          return;
        }
        console.log("[LiveSync] Tab visible again, refreshing...");
        refreshAllData(true);
      }
    }
    function stopLiveSync() {
      if (liveSyncIntervalId) {
        clearInterval(liveSyncIntervalId);
        liveSyncIntervalId = null;
        document.removeEventListener("visibilitychange", onVisibilityChange);
        console.log("[LiveSync] Stopped");
      }
    }

    // ===== INITIAL LOAD =====
    document.addEventListener("DOMContentLoaded", async () => {
      attachEventHandlers();

      initTheme();

      try {
        await loadUsers();
      } catch (err) {
        console.error(err);
        showToast("Error loading users", true);
      }
      restoreUserFromStorage();
      if (state.currentUser) {
        // Default to My Tasks on load
        state.calendarOwnerId = state.currentUser.id;

        document.getElementById("user-overlay").classList.add("hidden");
        document.getElementById("user-overlay").classList.add("hidden");
        await refreshAllData();
        initBacklogUI(); // Initialize backlog event listeners
        startLiveSync(); // Start live sync after successful login
      }
    });

    async function refreshAllData(silent = false) {
      await refreshCalendarAndMonthlyGoals();
      updateLastSyncTime();
      // Any other global refresh
    }

    function updateLastSyncTime() {
      const el = document.getElementById("last-sync-time");
      if (el) {
        const now = new Date();
        const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        el.textContent = `Synced ${timeStr}`;
      }
    }

    function pillarsStorageKey(userId) {
      return `wrapsheet-pillars-v1:${userId}`;
    }

    function getEmptyPillars() {
      return { elevate: [], engage: [], evolve: [], excite: [] };
    }

    function loadPillarsForCurrentUser() {
      if (!state.currentUser) {
        state.pillars = getEmptyPillars();
        renderPillars();
        return;
      }

      const key = pillarsStorageKey(state.currentUser.id);
      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          state.pillars = getEmptyPillars();
        } else {
          const parsed = JSON.parse(raw);
          state.pillars = { ...getEmptyPillars(), ...(parsed || {}) };
        }
      } catch {
        state.pillars = getEmptyPillars();
      }

      renderPillars();
    }

    function savePillarsForCurrentUser() {
      if (!state.currentUser) return;
      try {
        localStorage.setItem(pillarsStorageKey(state.currentUser.id), JSON.stringify(state.pillars));
      } catch {
        // ignore
      }
    }

    function clampPercent(n) {
      const v = Number(n);
      if (Number.isNaN(v)) return 0;
      return Math.max(0, Math.min(100, v));
    }

    function computePillarPercent(tasks) {
      if (!Array.isArray(tasks) || !tasks.length) return 0;
      const vals = tasks.map(t => clampPercent(t.progress_percent !== undefined ? t.progress_percent : (t.percent ?? 0)));
      const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
      return Math.round(avg);
    }

    function pillarDisplayName(key) {
      const map = { elevate: "Elevate", engage: "Engage", evolve: "Evolve", excite: "Excite" };
      return map[key] || key;
    }


    function renderPillars() {
      const grid = document.getElementById("pillar-grid");
      if (!grid) return;

      const subtitle = document.getElementById("pillars-subtitle");
      subtitle.textContent = state.currentUser
        ? `Synced for ${state.currentUser.name}`
        : "Pick a user to edit your pillars";

      grid.innerHTML = "";

      const keys = ["elevate", "engage", "evolve", "excite"];

      keys.forEach(pKey => {
        const card = document.createElement("div");
        card.className = `pillar-card ${pKey}`; // Add pillar class for coloring

        const header = document.createElement("div");
        header.className = "pillar-card-header";

        const name = document.createElement("div");
        name.className = "pillar-name";
        name.textContent = pillarDisplayName(pKey);

        const addBtn = document.createElement("button");
        addBtn.className = "pillar-add";
        addBtn.innerHTML = "+";
        addBtn.title = "Add Task";
        addBtn.disabled = !state.currentUser;
        addBtn.addEventListener("click", () => openPillarModal(pKey));

        header.appendChild(name);
        header.appendChild(addBtn);

        const box = document.createElement("div");
        box.className = "pillar-box";

        // 1. Legacy Tasks (Local Storage)
        const legacy = (state.pillars && state.pillars[pKey]) ? state.pillars[pKey] : [];

        // 2. API Tasks (Promoted/Active)
        // Filter by pillar. Show all active + suggested that were returned.
        // Use lowercase comparison to handle DB case mismatches
        const apiTasks = state.promotedSuggestions ? state.promotedSuggestions.filter(s => (s.pillar || "").toLowerCase() === pKey) : [];

        // Combine (Legacy first so they sit at top until deleted/migrated, or bottom? Let's put API first as they are "real")
        // User asked for "Erica's pillars", which are likely API grounded now.
        const allTasks = [...apiTasks, ...legacy];

        if (!allTasks.length) {
          const empty = document.createElement("div");
          empty.className = "pillar-empty";
          empty.textContent = "No tasks yet.\nClick + Add to create one.";
          box.appendChild(empty);
        } else {
          allTasks.forEach(t => {
            const row = document.createElement("div");
            row.className = "pillar-task-row";
            if (t.status === 'suggested') row.classList.add("promo"); // visual distinction

            const title = document.createElement("div");
            title.className = "pillar-task-title";
            title.textContent = t.title || "(Untitled)";

            // Determine fields
            const assignedId = t.assigned_to_id;
            const assignedUser = state.users.find(u => String(u.id) === String(assignedId));

            const isApi = !!t.status;
            const voteTxt = t.vote_count ? ` Â· Votes: ${t.vote_count}` : "";
            const statusTxt = t.status ? ` Â· ${t.status.toUpperCase()}` : "";

            const pct = clampPercent(t.progress_percent !== undefined ? t.progress_percent : (t.percent || 0));
            const eta = t.eta_date || t.eta || "â€”";
            const bench = t.description || t.benchmark || "â€”";

            // Meta Line
            const meta = document.createElement("div");
            meta.className = "pillar-task-meta";

            if (isApi) {
              // API Style: Status, Votes, Progress
              meta.innerHTML = `Assigned: <b>${assignedUser ? assignedUser.name : "â€”"}</b>${statusTxt}${voteTxt}<br>` +
                `Progress: ${pct}% Â· ETA: ${eta}`;
            } else {
              // Legacy Style
              meta.innerHTML = `Assigned: <b>${assignedUser ? assignedUser.name : "â€”"}</b><br>` +
                `Benchmark: ${bench}<br>` +
                `Percent: ${pct}% Â· ETA: ${eta}`;
            }

            row.appendChild(title);
            row.appendChild(meta);

            row.addEventListener("click", () => openPillarModal(pKey, t));
            box.appendChild(row);
          });
        }

        const circleWrap = document.createElement("div");
        circleWrap.className = "pillar-circle-wrap";

        const circle = document.createElement("div");
        circle.className = "pillar-circle";

        const pct = computePillarPercent(allTasks);
        circle.innerHTML = `<div><strong>${pct}%</strong><span>Percentage of goal<br>complete</span></div>`;

        circleWrap.appendChild(circle);

        card.appendChild(header);
        card.appendChild(box);
        card.appendChild(circleWrap);

        grid.appendChild(card);
      });
    }

    function populatePillarAssignedToSelect() {
      const sel = document.getElementById("pillar-task-assigned-to");
      if (!sel) return;
      sel.innerHTML = "";
      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = String(u.id);
        opt.textContent = u.name;
        sel.appendChild(opt);
      });
    }

    function editPromotedTask(task) {
      if (!task) return;
      // Simple interaction for now. Could be a full modal.
      const action = prompt(`Edit Board Idea: "${task.title}"\n\nEnter new progress notes (or keep existing).\nPrefix with [COMPLETE] to mark done.`);
      if (action === null) return;

      let status = task.status === 'suggested' ? 'active' : task.status;
      let notes = action;

      if (action.startsWith("[COMPLETE]")) {
        status = 'completed';
        notes = action.replace("[COMPLETE]", "").trim();
      }

      showActionLoader();
      apiSend(`/pillar-suggestions/${task.id}`, "PATCH", {
        progress_notes: notes,
        status: status
      }).then(() => {
        showToast("Board Idea updated");
        refreshAllData();
      }).catch(err => {
        console.error(err);
        showToast("Error updating idea", true);
      }).finally(hideActionLoader);
    }

    function populatePillarAssignedToSelect() {
      const select = document.getElementById("pillar-task-assigned-to");
      if (!select) return;
      // Only repopulate if empty or needed, but straightforward to just wipe
      select.innerHTML = "";
      if (state.users && state.users.length) {
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = u.id;
          opt.textContent = u.name;
          select.appendChild(opt);
        });
      }
    }

    // NEW: Calendar Owner Filter Logic
    function populateCalendarOwnerFilter() {
      const sel = document.getElementById("calendar-owner-select");
      if (!sel) return;
      sel.innerHTML = "";

      // 1. My Tasks (Default)
      const myOpt = document.createElement("option");
      myOpt.value = ""; // Empty string = My Tasks (current user)
      myOpt.textContent = "My Tasks";
      sel.appendChild(myOpt);

      // 2. Combined View
      const combinedOpt = document.createElement("option");
      combinedOpt.value = "combined";
      combinedOpt.textContent = "Combined View (All)";
      sel.appendChild(combinedOpt);

      // 3. Team Members
      if (state.users && state.users.length) {
        state.users.forEach(u => {
          // Exclude dummy users if needed for list purity
          if (u.id === 19 || u.id === 20) return;
          const opt = document.createElement("option");
          opt.value = String(u.id);
          opt.textContent = u.name;
          sel.appendChild(opt);
        });
      }

      // Restore selection
      if (state.calendarOwnerId === "combined") {
        sel.value = "combined";
      } else if (state.calendarOwnerId) {
        sel.value = String(state.calendarOwnerId);
      } else {
        sel.value = "";
      }

      // Attach Listener
      sel.onchange = async () => {
        const val = sel.value;
        if (val === "") {
          state.calendarOwnerId = state.currentUser ? state.currentUser.id : null;
        } else if (val === "combined") {
          state.calendarOwnerId = "combined";
        } else {
          state.calendarOwnerId = Number(val);
        }
        await refreshCalendarAndMonthlyGoals();
      };
    }

    // NEW: Calendar Owner Filter Logic
    function populateCalendarOwnerFilter() {
      const sel = document.getElementById("calendar-owner-select");
      if (!sel) return;
      sel.innerHTML = "";

      // 1. My Tasks (Default)
      const myOpt = document.createElement("option");
      myOpt.value = ""; // Empty string = My Tasks (current user)
      myOpt.textContent = "My Tasks";
      sel.appendChild(myOpt);

      // 2. Combined View
      const combinedOpt = document.createElement("option");
      combinedOpt.value = "combined";
      combinedOpt.textContent = "Combined View (All)";
      sel.appendChild(combinedOpt);

      // 3. Team Members
      if (state.users && state.users.length) {
        state.users.forEach(u => {
          // Exclude dummy users if needed for list purity
          if (u.id === 19 || u.id === 20) return;
          const opt = document.createElement("option");
          opt.value = String(u.id);
          opt.textContent = u.name;
          sel.appendChild(opt);
        });
      }

      // Restore selection
      if (state.calendarOwnerId === "combined") {
        sel.value = "combined";
      } else if (state.calendarOwnerId) {
        sel.value = String(state.calendarOwnerId);
      } else {
        sel.value = "";
      }

      // Attach Listener
      sel.onchange = async () => {
        const val = sel.value;
        if (val === "") {
          state.calendarOwnerId = state.currentUser ? state.currentUser.id : null;
        } else if (val === "combined") {
          state.calendarOwnerId = "combined";
        } else {
          state.calendarOwnerId = Number(val);
        }
        await refreshCalendarAndMonthlyGoals();
      };
    }

    function openPillarModal(pillarKey, task = null) {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return;
      }

      populatePillarAssignedToSelect();

      const modal = document.getElementById("pillar-modal");
      const idEl = document.getElementById("pillar-task-id");
      const keyEl = document.getElementById("pillar-key");
      const titleEl = document.getElementById("pillar-task-title");
      const assignedEl = document.getElementById("pillar-task-assigned-to");
      const benchEl = document.getElementById("pillar-task-benchmark");
      const percentEl = document.getElementById("pillar-task-percent");
      const etaEl = document.getElementById("pillar-task-eta");
      const deleteBtn = document.getElementById("pillar-task-delete");

      keyEl.value = pillarKey;

      if (task) {
        idEl.value = task.id;
        titleEl.value = task.title || "";
        assignedEl.value = String(task.assigned_to_id || state.currentUser.id);

        // Unified field mapping (API uses description/progress_percent/eta_date)
        benchEl.value = task.description || task.benchmark || "";
        percentEl.value = clampPercent(task.progress_percent !== undefined ? task.progress_percent : task.percent);
        etaEl.value = task.eta_date || task.eta || "";
        document.getElementById("pillar-task-notes").value = task.progress_notes || "";

        document.getElementById("pillar-modal-title").textContent = "Edit Pillar Task";
        // Show status if available
        const statusTxt = task.status ? ` Â· ${task.status.toUpperCase()}` : "";
        document.getElementById("pillar-modal-meta").textContent = `${pillarDisplayName(pillarKey)} â€¢ ${task.id}${statusTxt}`;
        deleteBtn.style.display = "inline-flex";
      } else {
        idEl.value = "";
        titleEl.value = "";
        assignedEl.value = String(state.currentUser.id);
        benchEl.value = "";
        percentEl.value = "0";
        etaEl.value = "";
        document.getElementById("pillar-task-notes").value = "";

        document.getElementById("pillar-modal-title").textContent = "New Pillar Task";
        document.getElementById("pillar-modal-meta").textContent = pillarDisplayName(pillarKey);
        deleteBtn.style.display = "none";
      }

      modal.classList.remove("hidden");
    }

    function closePillarModal() {
      document.getElementById("pillar-modal").classList.add("hidden");
    }

    function getPillarTasks(pillarKey) {
      if (!state.pillars) state.pillars = getEmptyPillars();
      if (!Array.isArray(state.pillars[pillarKey])) state.pillars[pillarKey] = [];
      return state.pillars[pillarKey];
    }

    function genPillarTaskId() {
      return "pt_" + Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    async function savePillarTaskFromModal() {
      const id = document.getElementById("pillar-task-id").value;
      const pillarKey = document.getElementById("pillar-key").value;

      const title = document.getElementById("pillar-task-title").value.trim();
      const assignedToId = document.getElementById("pillar-task-assigned-to").value; // Keep as string or int
      const benchmark = document.getElementById("pillar-task-benchmark").value.trim();
      const percent = clampPercent(document.getElementById("pillar-task-percent").value);
      const eta = document.getElementById("pillar-task-eta").value;
      const notes = document.getElementById("pillar-task-notes").value.trim();

      if (!title) {
        showToast("Task title is required", true);
        return;
      }
      if (!assignedToId) {
        showToast("Assigned to is required", true);
        return;
      }

      const payload = {
        title: title || "",
        description: benchmark || "",
        category: "General", // Ensure field exists for DB binding
        pillar: (pillarKey || "").toLowerCase(),
        status: 'active',
        source: 'staff', // Mark as staff-created (shows in Staff Core Pillars, not Board Ideas)
        assigned_to_id: assignedToId || null,
        created_by_id: (state.currentUser && state.currentUser.id) ? state.currentUser.id : null,
        progress_percent: percent || 0,
        eta_date: eta || null,
        progress_notes: notes || ""
      };

      try {
        if (id && !id.startsWith("pt_")) {
          // Edit API Item
          await apiSend(`/pillar-suggestions/${id}`, "PATCH", payload);
        } else {
          // Create New (or ignore legacy ID if we can't migrate easily, assume create new)
          // If it was a legacy item (pt_), we create a new DB item. 
          // Realistically we should delete the local one too, but let's just create new for now.
          payload.created_by_id = state.currentUser.id;
          await apiSend("/pillar-suggestions", "POST", payload);
        }

        await refreshAllData(); // Reloads promoted suggestions
        closePillarModal();
        showToast("Pillar task saved to DB");
      } catch (e) {
        console.error(e);
        showToast("Error saving task", true);
      }
    }

    async function deletePillarTaskFromModal() {
      const id = document.getElementById("pillar-task-id").value;
      const pillarKey = document.getElementById("pillar-key").value;
      if (!id) return;

      if (!confirm("Delete this pillar task?")) return;

      try {
        if (id.startsWith("pt_")) {
          // Legacy local delete
          const tasks = getPillarTasks(pillarKey);
          const next = tasks.filter(t => String(t.id) !== String(id));
          state.pillars[pillarKey] = next;
          savePillarsForCurrentUser();
          renderPillars();
        } else {
          // API Delete
          await fetch(`${API_BASE}/pillar-suggestions/${id}`, { method: "DELETE" });
          await refreshAllData();
        }

        closePillarModal();
        showToast("Pillar task deleted");
      } catch (e) {
        console.error(e);
        showToast("Error deleting task", true);
      }
    }



    async function loadUsers() {
      const allUsers = await apiGet("/users");
      // Filter to only show core BER staff
      const allowedNames = ["kevin", "meighan", "jenna", "erica", "katie", "melodie"];
      const excludedNames = ["kevin test", "kevin weinkauff", "meighan harris", "test whale"];
      state.users = allUsers.filter(u => {
        const lower = u.name.toLowerCase();
        if (excludedNames.some(ex => lower.includes(ex))) return false;
        return allowedNames.some(name => lower.includes(name));
      });



      populateUserSelects();
      populateCalendarOwnerFilter(); // NEW
    }

    function populateUserSelects() {
      const userSelect = document.getElementById("user-select");
      userSelect.innerHTML = '<option value="">Select your nameâ€¦</option>';
      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = u.id;
        opt.textContent = u.name;
        userSelect.appendChild(opt);
      });

      const monthlyOwnerFilter = document.getElementById("monthly-owner-filter");
      const annualOwnerFilter = document.getElementById("annual-owner-filter");
      [monthlyOwnerFilter, annualOwnerFilter].forEach(sel => {
        while (sel.options.length > 1) sel.remove(1); // keep "Everyone"
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = String(u.id);
          opt.textContent = u.name;
          sel.appendChild(opt);
        });
      });

      const taskAssignedTo = document.getElementById("task-assigned-to");
      taskAssignedTo.innerHTML = "";

      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = u.id;
        opt.textContent = u.name;
        taskAssignedTo.appendChild(opt);
      });

      // NEW: multi-assignee select
      const taskAssignees = document.getElementById("task-assignees");
      if (taskAssignees) {
        taskAssignees.innerHTML = "";
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = u.id;
          opt.textContent = u.name;
          taskAssignees.appendChild(opt);
        });
      }

    }

    function populateCalendarOwnerSelect() {
      const sel = document.getElementById("calendar-owner-select");
      if (!sel) return;
      sel.innerHTML = "";
      if (!state.currentUser) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Select userâ€¦";
        sel.appendChild(opt);
        sel.disabled = true;
        return;
      }
      sel.disabled = false;

      const mine = document.createElement("option");
      mine.value = "me";
      mine.textContent = "My Tasks";
      sel.appendChild(mine);

      const all = document.createElement("option");
      all.value = "all";
      all.textContent = "All Team";
      sel.appendChild(all);

      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = String(u.id);
        opt.textContent = u.name;
        sel.appendChild(opt);
      });

      sel.value = "me";
    }

    function restoreUserFromStorage() {
      const stored = localStorage.getItem("wrapsheet-user");
      if (!stored) return;
      const parsed = JSON.parse(stored);
      const found = state.users.find(u => u.id === parsed.id);
      if (found) setCurrentUser(found);
    }

    function setCurrentUser(user) {
      state.currentUser = user;
      document.getElementById("current-user-label").textContent =
        user ? user.name + " Â· " + user.email : "Not signed in";
      if (user) {
        localStorage.setItem("wrapsheet-user", JSON.stringify({ id: user.id }));
        document.getElementById("monthly-owner-filter").value = "all";
        document.getElementById("annual-owner-filter").value = "all";
        state.calendarOwnerId = user.id;
        populateCalendarOwnerSelect();
        setActiveUser(user.id);
        loadPillarsForCurrentUser();
      }
    }

    // ===== EVENT HANDLERS =====
    function attachEventHandlers() {
      const themeSelect = document.getElementById("theme-select");
      if (themeSelect) {
        themeSelect.addEventListener("change", () => {
          applyTheme(themeSelect.value);
        });
      }
      // User overlay
      const userSelectConfirm = document.getElementById("user-select-confirm");
      if (userSelectConfirm) {
        userSelectConfirm.addEventListener("click", async () => {
          const userSelect = document.getElementById("user-select");
          const id = userSelect ? parseInt(userSelect.value, 10) : 0;
          if (!id) {
            showToast("Please pick your name");
            return;
          }
          const user = state.users.find(u => u.id === id);
          if (!user) return;
          setCurrentUser(user);
          const userOverlay = document.getElementById("user-overlay");
          if (userOverlay) userOverlay.classList.add("hidden");
          await refreshAllData();
          startLiveSync(); // Start live sync after user login
        });
      }

      const switchUserBtn = document.getElementById("switch-user-btn");
      if (switchUserBtn) {
        switchUserBtn.addEventListener("click", () => {
          stopLiveSync(); // Stop live sync when switching users
          document.getElementById("user-overlay").classList.remove("hidden");
        });
      }

      // Calendar view switcher
      const calendarViewSelect = document.getElementById("calendar-view-select");
      if (calendarViewSelect) {
        calendarViewSelect.addEventListener("change", async () => {
          state.calendarView = calendarViewSelect.value;
          saveUserDbPreference("calendar_view", state.calendarView);
          await refreshCalendarAndMonthlyGoals(); // reloads tasks for the visible range
        });
      }

      // Calendar owner (whose calendar you are viewing)
      const calendarOwnerSelect = document.getElementById("calendar-owner-select");
      if (calendarOwnerSelect) {
        calendarOwnerSelect.addEventListener("change", async () => {
          const val = calendarOwnerSelect.value;

          if (val === "me") {
            state.calendarOwnerId = state.currentUser?.id ?? null;
            await setActiveUser(state.currentUser?.id ?? null);
          } else if (val === "all") {
            state.calendarOwnerId = null;        // IMPORTANT
            await setActiveUser(null);
          } else {
            const uid = parseInt(val, 10);
            state.calendarOwnerId = Number.isNaN(uid) ? null : uid;   // IMPORTANT
            await setActiveUser(state.calendarOwnerId);
          }

          await loadDailyTasks();
        });
      }



      // Navigation: prev/next
      // Navigation: prev/next
      const monthPrevBtn = document.getElementById("month-prev");
      if (monthPrevBtn) {
        monthPrevBtn.addEventListener("click", async () => {
          const d = state.currentMonthDate;
          if (state.calendarView === "month") {
            state.currentMonthDate = new Date(d.getFullYear(), d.getMonth() - 1, 1);
          } else {
            state.currentMonthDate = addDays(d, -7);
          }
          await refreshCalendarAndMonthlyGoals();
        });
      }

      const monthNextBtn = document.getElementById("month-next");
      if (monthNextBtn) {
        monthNextBtn.addEventListener("click", async () => {
          const d = state.currentMonthDate;
          if (state.calendarView === "month") {
            state.currentMonthDate = new Date(d.getFullYear(), d.getMonth() + 1, 1);
          } else {
            state.currentMonthDate = addDays(d, 7);
          }
          await refreshCalendarAndMonthlyGoals();
        });
      }

      // Goals tabs
      // Goals tabs
      document.querySelectorAll(".goals-tab").forEach(btn => {
        btn.addEventListener("click", () => {
          const tab = btn.dataset.tab;
          document.querySelectorAll(".goals-tab").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          if (tab === "monthly") {
            document.getElementById("monthly-goals-panel").style.display = "";
            document.getElementById("annual-goals-panel").style.display = "none";
          } else {
            document.getElementById("monthly-goals-panel").style.display = "none";
            document.getElementById("annual-goals-panel").style.display = "";
          }
        });
      });

      // Monthly goals: month input
      const monthlyMonthInput = document.getElementById("monthly-month-input");
      if (monthlyMonthInput) {
        monthlyMonthInput.addEventListener("change", async () => {
          if (!monthlyMonthInput.value) return;
          const [year, month] = monthlyMonthInput.value.split("-").map(Number);
          state.currentMonthDate = new Date(year, month - 1, 1);
          await refreshCalendarAndMonthlyGoals();
        });
      }

      // Owner filters (goals)
      document.getElementById("monthly-owner-filter")?.addEventListener("change", () => {
        state.monthlyOwnerFilter = document.getElementById("monthly-owner-filter").value;
        renderMonthlyGoals();
      });

      document.getElementById("annual-owner-filter")?.addEventListener("change", () => {
        state.annualOwnerFilter = document.getElementById("annual-owner-filter").value;
        renderAnnualGoals();
      });

      // Annual year input
      const annualYearInput = document.getElementById("annual-year-input");
      if (annualYearInput) {
        const thisYear = new Date().getFullYear();
        for (let y = thisYear - 1; y <= thisYear + 4; y++) {
          const opt = document.createElement("option");
          opt.value = y;
          opt.textContent = y;
          if (y === thisYear) opt.selected = true;
          annualYearInput.appendChild(opt);
        }
        annualYearInput.addEventListener("change", async () => {
          state.annualYear = parseInt(annualYearInput.value, 10);
          await loadAnnualGoals();
        });
      }

      // Task modal controls
      document.getElementById("task-modal-close")?.addEventListener("click", closeTaskModal);
      document.getElementById("task-modal-cancel")?.addEventListener("click", closeTaskModal);
      document.getElementById("task-save-btn")?.addEventListener("click", onTaskSave);
      document.getElementById("task-delete-btn")?.addEventListener("click", onTaskDelete);

      // Delete confirmation modal controls
      document.getElementById("delete-confirm-close")?.addEventListener("click", () => {
        document.getElementById("delete-confirm-modal").classList.add("hidden");
        pendingDeleteInfo = null;
      });
      document.getElementById("delete-confirm-cancel")?.addEventListener("click", () => {
        document.getElementById("delete-confirm-modal").classList.add("hidden");
        pendingDeleteInfo = null;
      });
      document.getElementById("delete-confirm-yes")?.addEventListener("click", () => {
        const deleteAll = document.querySelector('input[name="delete-choice"]:checked')?.value === "all";
        executeTaskDelete(deleteAll);
      });

      // Project Step Modal listeners
      document.getElementById("project-step-modal-close")?.addEventListener("click", () => document.getElementById("project-step-modal").classList.add("hidden"));
      document.getElementById("project-step-modal-cancel")?.addEventListener("click", () => document.getElementById("project-step-modal").classList.add("hidden"));
      document.getElementById("project-step-save-btn")?.addEventListener("click", saveProjectStepFromModal);


      // Enter key to save task in modal
      const taskModal = document.getElementById("task-modal");
      if (taskModal) {
        taskModal.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            // Don't trigger on textarea (allow Enter for new lines there)
            if (e.target.tagName === "TEXTAREA") return;
            e.preventDefault();
            document.getElementById("task-save-btn").click();
          }
        });
      }

      // Pillar modal controls
      document.getElementById("pillar-modal-close")?.addEventListener("click", closePillarModal);
      document.getElementById("pillar-modal-cancel")?.addEventListener("click", closePillarModal);
      document.getElementById("pillar-task-save")?.addEventListener("click", savePillarTaskFromModal);
      document.getElementById("pillar-task-delete")?.addEventListener("click", deletePillarTaskFromModal);

      // Joint Projects
      document.getElementById("add-project-btn")?.addEventListener("click", createNewProject);

      // Suggestion Modal (Board Ideas)
      // Suggestion Modal (Board Ideas)
      document.getElementById("suggestion-modal-close")?.addEventListener("click", () => {
        document.getElementById("suggestion-modal").classList.add("hidden");
      });
      document.getElementById("suggestion-modal-cancel")?.addEventListener("click", () => {
        document.getElementById("suggestion-modal").classList.add("hidden");
      });
      document.getElementById("suggestion-save-btn")?.addEventListener("click", saveSuggestionFromModal);


      // Weekly Tasks (BETA)
      document.getElementById("add-weekly-task-btn").addEventListener("click", () => {
        const input = document.getElementById("new-weekly-task-input");
        const title = input.value.trim();
        if (title) {
          createWeeklyTask(title);
          input.value = "";
        }
      });
      document.getElementById("new-weekly-task-input").addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          document.getElementById("add-weekly-task-btn").click();
        }
      });
      document.getElementById("week-prev").addEventListener("click", async () => {
        state.currentWeekKey = shiftWeek(state.currentWeekKey, -1);
        await loadWeeklyTasks();
      });
      document.getElementById("week-next").addEventListener("click", async () => {
        state.currentWeekKey = shiftWeek(state.currentWeekKey, 1);
        await loadWeeklyTasks();
      });

    }

    // --- Suggestion Modal Logic ---

    function editPromotedTask(task) {
      if (!task) return;

      const modal = document.getElementById("suggestion-modal");
      document.getElementById("suggestion-modal-title").textContent = task.title;
      document.getElementById("suggestion-id").value = task.id;
      document.getElementById("suggestion-status").value = task.status;

      // Parse metadata from notes if present
      // Format: "Real notes... [PROGRESS: 50] [ETA: 2026-01-30]"
      let notes = task.progress_notes || "";
      let percent = 0;
      let eta = "";

      const progMatch = notes.match(/\[PROGRESS:\s*(\d+)\]/);
      if (progMatch) {
        percent = parseInt(progMatch[1], 10);
        notes = notes.replace(progMatch[0], "").trim();
      }

      const etaMatch = notes.match(/\[ETA:\s*([^\]]+)\]/);
      if (etaMatch) {
        eta = etaMatch[1];
        notes = notes.replace(etaMatch[0], "").trim();
      }

      // If we have real DB fields eventually, check them too
      if (task.progress_percent) percent = task.progress_percent;
      if (task.eta_date) eta = task.eta_date;

      document.getElementById("suggestion-notes").value = notes;
      document.getElementById("suggestion-percent").value = percent;
      document.getElementById("suggestion-percent-val").textContent = percent + "%";
      document.getElementById("suggestion-eta").value = eta;

      modal.classList.remove("hidden");
    }

    async function saveSuggestionFromModal() {
      const id = document.getElementById("suggestion-id").value;
      const rawNotes = document.getElementById("suggestion-notes").value.trim();
      const percent = document.getElementById("suggestion-percent").value;
      const eta = document.getElementById("suggestion-eta").value;
      const status = document.getElementById("suggestion-status").value;

      let finalNotes = rawNotes;
      // Append metadata tags
      if (percent > 0) finalNotes += ` [PROGRESS: ${percent}]`;
      if (eta) finalNotes += ` [ETA: ${eta}]`;

      showActionLoader();
      try {
        // Send both the compound notes AND the direct fields (future proofing)
        await apiSend(`/pillar-suggestions/${id}`, "PATCH", {
          progress_notes: finalNotes,
          progress_percent: parseInt(percent, 10), // Send just in case backend supports it
          eta_date: eta, // Send just in case
          status: status,
          assigned_to_id: state.currentUser?.id // Auto-assign to me if editing
        });

        showToast("Board Idea updated");
        document.getElementById("suggestion-modal").classList.add("hidden");
        refreshAllData();
      } catch (err) {
        console.error(err);
        showToast("Error updating idea", true);
      } finally {
        hideActionLoader();
      }
    }

    // ===== DATA REFRESH =====
    async function refreshAllData(silent = false) {
      await refreshCalendarAndMonthlyGoals();
      await loadAnnualGoals();
      await loadProjects();
      await loadUserDbPreferences();
      await loadPromotedSuggestions(); // New
      initWeeklyTasksUI();
      updateLastSyncTime();

      // Initialize coin reward system for eligible users
      if (isRewardEligible()) {
        loadCoinBalance();
      }
    }

    // Fetch top suggestions assigned to current user
    async function loadPromotedSuggestions() {
      if (!state.currentUser) return;
      try {
        // Fetch ALL suggestions (team view) instead of just mine. 
        // passing userId ensures 'vote_count' or 'liked_by_me' logic works if backend supports it.
        // Reverted to fetching ONLY assigned to me, per user request "Each user should see only THEIR assigned item"
        const res = await apiGet(`/pillar-suggestions?assignedTo=${state.currentUser.id}&limit=100&status=all`);

        if (Array.isArray(res)) {
          state.promotedSuggestions = res;
        } else {
          state.promotedSuggestions = [];
        }
        renderPillars(); // Re-render to show suggestions
      } catch (e) {
        console.warn("Failed to load promoted suggestions", e);
        state.promotedSuggestions = [];
        renderPillars();
      }
    }



    // ===== BACKLOG LOGIC =====
    async function loadBacklogTasks() {
      try {
        let targetId = state.calendarOwnerId;
        // If no filter selected (My Tasks), default to current user
        if (!targetId && state.currentUser) {
          targetId = state.currentUser.id;
        }

        let path = "/daily-tasks?month=1900-01"; // Backlog Month

        if (targetId) {
          // REMOVED: Fetch all backlog for potential team metrics
          // path += "&assignedToId=" + encodeURIComponent(targetId);
        } else {
          // If we really don't have a user (not logged in?), maybe we fetch nothing? 
          // Or fetch all (unsafe). Let's assume fetch all is fallback but we prefer isolation.
          // The user requested strict isolation.
          if (state.currentUser) {
            path += "&assignedToId=" + encodeURIComponent(state.currentUser.id);
          }
        }

        const tasks = await apiGet(path);
        // Dedupe
        const merged = [];
        const seen = new Set();
        tasks.forEach(t => {
          if (!seen.has(t.id)) { seen.add(t.id); merged.push(t); }
        });

        state.backlogTasks = merged;
        renderBacklog();
      } catch (err) {
        console.warn("Error loading backlog", err);
        state.backlogTasks = [];
        renderBacklog();
      }
    }

    // Pagination State
    const paginationState = {
      backlog: 1,
      projects: 1
    };

    function paginateList(items, page, perPage) {
      const start = (page - 1) * perPage;
      const end = start + perPage;
      return {
        data: items.slice(start, end),
        totalPages: Math.ceil(items.length / perPage)
      };
    }

    function renderPaginationControls(containerId, currentPage, totalPages, type) {
      const container = document.getElementById(containerId);
      if (!container || totalPages <= 1) return; // No controls needed
      const controls = document.createElement("div");
      controls.className = "pagination-controls";
      controls.style.display = "flex";
      controls.style.justifyContent = "center";
      controls.style.gap = "8px";
      controls.style.marginTop = "10px";
      controls.style.fontSize = "12px";

      const prev = document.createElement("button");
      prev.textContent = "â†";
      prev.disabled = currentPage === 1;
      prev.style.border = "none";
      prev.style.background = "transparent";
      prev.style.cursor = prev.disabled ? "default" : "pointer";
      prev.style.opacity = prev.disabled ? "0.3" : "1";
      prev.onclick = () => {
        if (currentPage > 1) {
          paginationState[type]--;
          if (type === 'backlog') renderBacklog();
          if (type === 'projects') renderProjects();
        }
      };

      const label = document.createElement("span");
      label.textContent = `${currentPage} / ${totalPages}`;
      label.style.color = "var(--ink-soft)";

      const next = document.createElement("button");
      next.textContent = "â†’";
      next.disabled = currentPage === totalPages;
      next.style.border = "none";
      next.style.background = "transparent";
      next.style.cursor = next.disabled ? "default" : "pointer";
      next.style.opacity = next.disabled ? "0.3" : "1";
      next.onclick = () => {
        if (currentPage < totalPages) {
          paginationState[type]++;
          if (type === 'backlog') renderBacklog();
          if (type === 'projects') renderProjects();
        }
      };

      controls.appendChild(prev);
      controls.appendChild(label);
      controls.appendChild(next);
      container.parentNode.appendChild(controls);
    }

    function renderBacklog() {
      const container = document.getElementById("backlog-list");
      const empty = document.getElementById("backlog-empty");
      // Clean up old pagination if exists
      const oldControls = container.parentNode.querySelector(".pagination-controls");
      if (oldControls) oldControls.remove();

      if (!container) return;
      container.innerHTML = "";

      const ownerId = state.calendarOwnerId || (state.currentUser ? state.currentUser.id : null);

      const visible = state.backlogTasks.filter(t => {
        if (ownerId !== "combined" && ownerId && t.assigned_to_id !== ownerId && (!t.assignee_ids || !t.assignee_ids.includes(ownerId))) {
          return false;
        }
        // Hide completed tasks unless recently done? Backlog usually hides done.
        if (t.status === 'done') return false;
        return true;
      });

      if (visible.length === 0) {
        if (empty) empty.style.display = "block";
        return;
      }
      if (empty) empty.style.display = "none";

      // Pagination
      const ITEMS_PER_PAGE = 10; // Grid 2x5
      const { data, totalPages } = paginateList(visible, paginationState.backlog, ITEMS_PER_PAGE);

      // Reset page if out of bounds (e.g. after deletion)
      if (paginationState.backlog > totalPages && totalPages > 0) {
        paginationState.backlog = totalPages;
        renderBacklog();
        return;
      }

      data.forEach(task => {
        const pill = buildTaskPill(task);
        container.appendChild(pill);
      });

      renderPaginationControls("backlog-list", paginationState.backlog, totalPages, 'backlog');
    }

    async function checkAndMigrateOverdueTasks() {
      if (state.hasCheckedOverdue) return;
      state.hasCheckedOverdue = true;

      const today = new Date();
      const todayKey = dateKey(today.getFullYear(), today.getMonth(), today.getDate());

      const overdue = state.dailyTasks.filter(t => {
        return t.task_date < todayKey && t.task_date !== BACKLOG_DATE &&
          t.status !== 'done' && t.status !== 'could_not_complete';
      });

      if (overdue.length === 0) return;

      showActionLoader({ main: "Organizing...", sub: `Moving ${overdue.length} overdue tasks to backlog` });

      try {
        await Promise.all(overdue.map(t =>
          apiSend(`/daily-tasks/${t.id}`, "PATCH", { task_date: BACKLOG_DATE })
        ));

        showToast(`Moved ${overdue.length} tasks to backlog`);
        await Promise.all([loadDailyTasks(), loadBacklogTasks()]);
      } catch (err) {
        console.error("Migration failed", err);
      } finally {
        hideActionLoader();
      }
    }

    function initBacklogUI() {
      const section = document.getElementById("section-backlog");
      const container = document.getElementById("backlog-container");
      const addBtn = document.getElementById("add-backlog-btn");
      const input = document.getElementById("new-backlog-input");

      if (container) {
        container.addEventListener("dragover", onDayDragOver);
        container.addEventListener("dragenter", onDayDragEnter);
        container.addEventListener("dragleave", onDayDragLeave);
        container.addEventListener("drop", onBacklogDrop);
      }

      if (addBtn && input) {
        const handler = async () => {
          const val = input.value.trim();
          if (!val) return;
          if (!state.currentUser) {
            showToast("Who are you?", true);
            return;
          }

          try {
            await apiSend("/daily-tasks", "POST", {
              title: val,
              task_date: BACKLOG_DATE,
              assigned_to_id: state.currentUser.id,
              created_by_id: state.currentUser.id,
              assigned_by_id: state.currentUser.id,
              status: "pending"
            });
            input.value = "";
            showToast("Added to backlog");
            await loadBacklogTasks();
          } catch (e) {
            console.error(e);
            showToast("Error adding to backlog", true);
          }
        };

        addBtn.addEventListener("click", handler);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") handler();
        });
      }
    }

    function onBacklogDrop(e) {
      if (!dragState.taskId) return;
      e.preventDefault();
      const el = document.getElementById("backlog-container");
      if (el) el.classList.remove("drop-target");

      const inBacklog = state.backlogTasks.find(t => String(t.id) === String(dragState.taskId));
      if (inBacklog) return;

      moveTaskToDate(dragState.taskId, BACKLOG_DATE);
    }

    async function refreshCalendarAndMonthlyGoals() {
      updateMonthLabel();
      setMonthInputsFromState();
      await Promise.all([
        loadDailyTasks(),
        loadMonthlyGoals(),
        loadBacklogTasks() // NEW
      ]);
      await checkAndMigrateOverdueTasks(); // Auto-migrate overdue
      if (document.getElementById("team-metrics-dashboard").style.display !== "none") {
        renderTeamMetrics();
      }
    }

    function updateMonthLabel() {
      const labelEl = document.getElementById("month-label");
      const d = state.currentMonthDate;
      if (state.calendarView === "month") {
        const monthName = d.toLocaleString("default", { month: "long" });
        labelEl.textContent = monthName + " " + d.getFullYear();
      } else {
        const isWorkweek = state.calendarView === "workweek" || state.calendarView === "jointweek";
        const weekStart = getWeekStart(d, isWorkweek);
        const weekEnd = addDays(weekStart, isWorkweek ? 4 : 6);
        const startLabel = weekStart.toLocaleString("default", {
          month: "short",
          day: "numeric"
        });
        const endLabel = weekEnd.toLocaleString("default", {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
        labelEl.textContent = `${startLabel} â€“ ${endLabel}`;
      }
    }

    function setMonthInputsFromState() {
      const d = state.currentMonthDate;
      const monthVal = d.getFullYear() + "-" + pad2(d.getMonth() + 1);
      document.getElementById("monthly-month-input").value = monthVal;
    }

    async function loadDailyTasks() {
      try {
        const [startKey, endKey] = getVisibleDateRange();

        const startMonth = startKey.slice(0, 7);
        const endMonth = endKey.slice(0, 7);
        const months = startMonth === endMonth ? [startMonth] : [startMonth, endMonth];

        const ownerFilterOn = state.calendarOwnerId !== null && state.calendarOwnerId !== undefined;

        const results = await Promise.all(months.map(mk => {
          let path = "/daily-tasks?month=" + encodeURIComponent(mk);
          // REMOVED: assignedToId filter to fetch ALL data for metrics
          // if (ownerFilterOn) path += "&assignedToId=" + encodeURIComponent(state.calendarOwnerId);
          return apiGet(path);
        }));

        // merge + dedupe by id
        const merged = [];
        const seen = new Set();
        results.flat().forEach(t => {
          if (!seen.has(t.id)) { seen.add(t.id); merged.push(t); }
        });

        state.dailyTasks = merged;
        if (document.getElementById("team-metrics-dashboard").style.display !== "none") {
          renderTeamMetrics();
        }
        renderCalendar();
      } catch (err) {
        console.error(err);
        showToast("Error loading daily tasks", true);
      }
    }



    async function loadMonthlyGoals() {
      const mk = monthKeyFromDate(state.currentMonthDate);
      try {
        const goals = await apiGet("/monthly-goals?month=" + encodeURIComponent(mk));
        state.monthlyGoals = goals;
        renderMonthlyGoals();
      } catch (err) {
        console.error(err);
        showToast("Error loading monthly goals", true);
      }
    }

    async function loadAnnualGoals() {
      try {
        const goals = await apiGet("/annual-goals?year=" + encodeURIComponent(state.annualYear));
        state.annualGoals = goals;
        renderAnnualGoals();
      } catch (err) {
        console.error(err);
        showToast("Error loading annual goals", true);
      }
    }

    function buildDayCell(key, displayDayNumber, todayKey, tasksByDate) {
      const cell = document.createElement("div");
      cell.className = "day-cell";
      cell.dataset.dateKey = key;
      if (key === todayKey) cell.classList.add("is-today");

      // Drop targets for drag & drop
      cell.addEventListener("dragover", onDayDragOver);
      cell.addEventListener("dragenter", onDayDragEnter);
      cell.addEventListener("dragleave", onDayDragLeave);
      cell.addEventListener("drop", onDayDrop);

      const header = document.createElement("div");
      header.className = "day-header";

      const num = document.createElement("div");
      num.className = "day-number";
      num.textContent = displayDayNumber;
      header.appendChild(num);

      const addBtn = document.createElement("button");
      addBtn.className = "add-task-btn";
      addBtn.textContent = "+";
      addBtn.title = "Add task";
      addBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        openTaskModalForDate(key);
      });
      header.appendChild(addBtn);

      cell.appendChild(header);

      const list = document.createElement("div");
      list.className = "tasks-list";
      const tasks = tasksByDate[key] || [];
      tasks.forEach(task => {
        const pill = buildTaskPill(task);
        list.appendChild(pill);
      });

      cell.appendChild(list);
      return cell;
    }



    function renderCalendar() {
      const weekdaysEl = document.getElementById("calendar-weekdays");
      const container = document.getElementById("calendar-days");
      weekdaysEl.innerHTML = "";
      container.innerHTML = "";

      const d = state.currentMonthDate;
      const year = d.getFullYear();
      const monthIndex = d.getMonth();
      const today = new Date();
      const todayKey = dateKey(today.getFullYear(), today.getMonth(), today.getDate());

      const tasksByDate = {};
      const ownerId = state.calendarOwnerId;

      state.dailyTasks.forEach(t => {
        // Filter by owner if set
        // Allow "combined" to show all
        if (ownerId !== "combined" && ownerId && t.assigned_to_id !== ownerId && (!t.assignee_ids || !t.assignee_ids.includes(ownerId))) {
          return;
        }

        const key = t.task_date;
        if (!tasksByDate[key]) tasksByDate[key] = [];
        tasksByDate[key].push(t);
      });

      // Include completed backlog tasks on their completion date
      // Include completed backlog tasks on their completion date
      if (state.backlogTasks) {
        state.backlogTasks.forEach(t => {
          if (t.status === 'done' && t.completed_at) {
            // Apply same filter as daily tasks
            if (ownerId !== "combined" && ownerId && t.assigned_to_id !== ownerId && (!t.assignee_ids || !t.assignee_ids.includes(ownerId))) {
              return;
            }

            const d = new Date(t.completed_at);
            const key = dateKey(d.getFullYear(), d.getMonth(), d.getDate());
            if (!tasksByDate[key]) tasksByDate[key] = [];
            if (!tasksByDate[key].some(existing => existing.id === t.id)) {
              tasksByDate[key].push(t);
            }
          }
        });
      }

      if (state.calendarView === "month") {
        const weekdayLabels = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        weekdayLabels.forEach(label => {
          const div = document.createElement("div");
          div.textContent = label;
          weekdaysEl.appendChild(div);
        });
        weekdaysEl.style.gridTemplateColumns = "repeat(7, minmax(0, 1fr))";
        container.style.gridTemplateColumns = "repeat(7, minmax(0, 1fr))";

        const firstDay = new Date(year, monthIndex, 1);
        const firstWeekday = firstDay.getDay();
        const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();

        for (let i = 0; i < firstWeekday; i++) {
          const emptyCell = document.createElement("div");
          emptyCell.className = "day-cell day-cell-empty";
          container.appendChild(emptyCell);
        }

        for (let day = 1; day <= daysInMonth; day++) {
          const key = dateKey(year, monthIndex, day);
          const cell = buildDayCell(key, day, todayKey, tasksByDate);
          container.appendChild(cell);
        }
      } else {
        const isWorkweek = state.calendarView === "workweek" || state.calendarView === "jointweek";
        const weekStart = getWeekStart(d, isWorkweek);
        const labels = isWorkweek
          ? ["Mon", "Tue", "Wed", "Thu", "Fri"]
          : ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const daysCount = isWorkweek ? 5 : 7;

        labels.forEach(label => {
          const div = document.createElement("div");
          div.textContent = label;
          weekdaysEl.appendChild(div);
        });
        weekdaysEl.style.gridTemplateColumns = `repeat(${daysCount}, minmax(0, 1fr))`;
        container.style.gridTemplateColumns = `repeat(${daysCount}, minmax(0, 1fr))`;

        for (let i = 0; i < daysCount; i++) {
          const dateObj = addDays(weekStart, i);
          const key = dateKey(
            dateObj.getFullYear(),
            dateObj.getMonth(),
            dateObj.getDate()
          );
          const dayNumber = dateObj.getDate();
          const cell = buildDayCell(key, dayNumber, todayKey, tasksByDate);
          container.appendChild(cell);
        }
      }

      updateStatusChart();
    }

    function buildTaskPill(task) {
      const pill = document.createElement("div");
      pill.className = "task-pill";
      // Identify backlog items specifically or just generic
      if (task.task_date === BACKLOG_DATE) {
        pill.classList.add("backlog-pill");
        // Removed explicit width 100% to let grid handle it
      }

      // Apply Color Coding from Linked Monthly Goal
      if (task.linked_monthly_goal_id) {
        const parentGoal = (state.monthlyGoals || []).find(g => g.id === task.linked_monthly_goal_id);
        if (parentGoal && parentGoal.category) {
          const colorVar = CATEGORY_COLORS[parentGoal.category];
          if (colorVar) {
            pill.style.background = colorVar;
            pill.style.color = "#fff";
            pill.style.borderColor = "transparent";
            pill.style.textShadow = "0 1px 2px rgba(0,0,0,0.5)";
            pill.style.boxShadow = `0 2px 5px -1px ${colorVar}`;
          }
        }
      }

      // CUSTOM COLOR OVERRIDE
      if (task.color && task.color !== "#ffffff" && task.color !== "") {
        pill.style.background = task.color;
        pill.style.color = "#fff";
        pill.style.borderColor = "transparent";
        pill.style.textShadow = "0 1px 2px rgba(0,0,0,0.5)";
        pill.style.boxShadow = `0 2px 5px -1px ${task.color}`;
      }

      // DRAGGABLE
      pill.draggable = true;
      pill.dataset.taskId = task.id;
      pill.dataset.date = task.task_date;
      pill.addEventListener("dragstart", onTaskDragStart);
      pill.addEventListener("dragend", onTaskDragEnd);

      const statusVal = task.status || "pending";

      const dot = document.createElement("div");
      dot.className = "task-status-dot";
      dot.classList.add("task-status-" + statusVal);
      pill.appendChild(dot);

      if (statusVal === "done") {
        pill.classList.add("completed");
      } else if (statusVal === "could_not_complete") {
        pill.classList.add("blocked");
      }

      const title = document.createElement("div");
      title.className = "task-title";

      // PRIORITY ICON
      let pIcon = "";
      if (task.priority === 3) pIcon = "ðŸ”¥ ";
      if (task.priority === 2) pIcon = "âš¡ ";

      title.textContent = pIcon + task.title;
      pill.appendChild(title);

      const assignee = document.createElement("div");
      assignee.className = "task-assignee";

      // Multi-assignee label: "Name" or "Name +2"
      let assigneeLabel = "";
      if (Array.isArray(task.assignees) && task.assignees.length) {
        const names = task.assignees.map(a => a.name).filter(Boolean);
        if (names.length === 1) {
          assigneeLabel = names[0];
        } else if (names.length > 1) {
          assigneeLabel = names[0] + " +" + (names.length - 1);
        }
      } else {
        const assignedUser = state.users.find(u => u.id === task.assigned_to_id);
        assigneeLabel = assignedUser ? assignedUser.name : "";
      }
      assignee.textContent = assigneeLabel;
      pill.appendChild(assignee);

      // Quick actions
      const quick = document.createElement("div");
      quick.className = "task-quick-actions";

      const quickDone = document.createElement("input");
      quickDone.type = "checkbox";
      quickDone.title = "Mark complete";
      quickDone.checked = statusVal === "done";
      quickDone.addEventListener("click", async (e) => {
        e.stopPropagation();
        const newStatus = quickDone.checked ? "done" : "pending";

        // Trigger celebration if marking as done!
        if (newStatus === "done" && typeof triggerBirdCelebration === "function") {
          triggerBirdCelebration();
        }

        // If in backlog, updating status keeps it in backlog unless it's marked done (maybe we move done items to today? No, stays in backlog)
        await quickUpdateTaskStatus(task, newStatus);
      });

      const quickBlocked = document.createElement("button");
      quickBlocked.type = "button";
      quickBlocked.textContent = "X";
      quickBlocked.title = "Could not complete";
      if (statusVal === "could_not_complete") {
        quickBlocked.classList.add("active");
      }
      quickBlocked.addEventListener("click", async (e) => {
        e.stopPropagation();
        await quickUpdateTaskStatus(task, "could_not_complete");
      });

      quick.appendChild(quickDone);
      quick.appendChild(quickBlocked);
      pill.appendChild(quick);

      pill.addEventListener("click", (e) => {
        e.stopPropagation();
        openTaskModalForExistingTask(task);
      });

      return pill;
    }

    function updateStatusChart() {
      const canvas = document.getElementById("status-pie");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const [startKey, endKey] = getVisibleDateRange();

      let pending = 0;
      let inProgress = 0;
      let done = 0;
      let blocked = 0;

      state.dailyTasks.forEach(t => {
        const date = t.task_date;
        if (!date || date < startKey || date > endKey) return;
        const status = t.status || "pending";
        if (status === "done") done++;
        else if (status === "in_progress") inProgress++;
        else if (status === "could_not_complete") blocked++;
        else pending++;
      });

      const total = pending + inProgress + done + blocked;
      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) / 2 - 4;

      if (!total) {
        ctx.fillStyle = "#6b7280";
        ctx.font = "12px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("No tasks", cx, cy);
        return;
      }

      const segments = [
        { value: pending, color: "rgba(248,250,252,0.3)" },
        { value: inProgress, color: "#12d0c9" },
        { value: done, color: "#22c55e" },
        { value: blocked, color: "#ef4444" }
      ];

      let startAngle = -Math.PI / 2;
      segments.forEach(seg => {
        if (!seg.value) return;
        const sliceAngle = (seg.value / total) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, radius, startAngle, startAngle + sliceAngle);
        ctx.closePath();
        ctx.fillStyle = seg.color;
        ctx.fill();
        startAngle += sliceAngle;
      });

      // Inner circle for donut effect
      ctx.beginPath();
      ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2);
      ctx.closePath();
      const panelBg = getComputedStyle(document.body).getPropertyValue("--panel").trim() || "#ffffff";
      ctx.fillStyle = panelBg;
      ctx.fill();
    }


    function openTaskModalForDate(dateStr) {
      const modal = document.getElementById("task-modal");
      document.getElementById("task-id").value = "";
      document.getElementById("task-title-input").value = "";
      document.getElementById("task-notes-input").value = "";
      document.getElementById("task-status-input").value = "pending";
      document.getElementById("task-time-input").value = ""; // clear scheduled time
      document.getElementById("task-modal-title").textContent = "New Task";
      document.getElementById("task-modal-date").textContent = dateStr;
      document.getElementById("task-delete-btn").style.display = "none";

      const taskAssignedTo = document.getElementById("task-assigned-to");
      const defaultAssigneeId =
        state.calendarOwnerId || (state.currentUser && state.currentUser.id);
      if (defaultAssigneeId) {
        taskAssignedTo.value = String(defaultAssigneeId);
      }

      // NEW: Clear multi-assignee checkboxes
      const container = document.getElementById("task-assignees-container");
      if (container) {
        container.innerHTML = "";
        (state.users || []).forEach(u => {
          const lbl = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.value = u.id;
          lbl.appendChild(cb);
          lbl.appendChild(document.createTextNode(u.name));
          container.appendChild(lbl);
        });
      }

      // NEW: reset repeat fields
      const rt = document.getElementById("task-repeat-type");
      const rs = document.getElementById("task-repeat-start");
      const re = document.getElementById("task-repeat-end");
      if (rt) rt.value = "none";
      if (rs) rs.value = dateStr;   // default series start = this date
      if (re) re.value = "";        // no end set yet

      // NEW: Set default color and priority
      const colorInput = document.getElementById("task-color");
      if (colorInput) colorInput.value = "#ffffff"; // Default to white or a neutral color

      const priorityInput = document.getElementById("task-priority");
      if (priorityInput) priorityInput.value = "1"; // Default to lowest priority

      modal.dataset.date = dateStr;
      modal.classList.remove("hidden");
    }





    function openTaskModalForExistingTask(task) {
      const modal = document.getElementById("task-modal");
      document.getElementById("task-id").value = task.id;
      document.getElementById("task-title-input").value = task.title || "";
      document.getElementById("task-notes-input").value = task.notes || "";
      document.getElementById("task-status-input").value = task.status || "pending";
      document.getElementById("task-time-input").value = task.task_time || ""; // scheduled time
      document.getElementById("task-modal-title").textContent = "Edit Task";
      document.getElementById("task-modal-date").textContent = task.task_date || "";
      const taskAssignedTo = document.getElementById("task-assigned-to");
      taskAssignedTo.value = String(task.assigned_to_id);

      // NEW: Hydrate Color & Priority
      const colorInput = document.getElementById("task-color");
      if (colorInput) colorInput.value = task.color || ""; // Default to None if null

      const priorityInput = document.getElementById("task-priority");
      if (priorityInput) priorityInput.value = task.priority ? String(task.priority) : "1";

      // NEW: preselect multi-assignees checkboxes
      const container = document.getElementById("task-assignees-container");
      if (container) {
        container.innerHTML = "";

        let selectedIds = [];
        if (Array.isArray(task.assignees) && task.assignees.length) {
          selectedIds = task.assignees.map(a => String(a.id));
        } else if (task.assigned_to_id != null) {
          selectedIds = [String(task.assigned_to_id)];
        }

        (state.users || []).forEach(u => {
          const lbl = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.value = u.id;
          if (selectedIds.includes(String(u.id))) {
            cb.checked = true;
          }
          lbl.appendChild(cb);
          lbl.appendChild(document.createTextNode(u.name));
          container.appendChild(lbl);
        });
      }


      document.getElementById("task-delete-btn").style.display = "inline-flex";

      // Existing tasks donâ€™t carry a â€œseriesâ€ yet â€“ but you can spin off a new one
      const rt = document.getElementById("task-repeat-type");
      const rs = document.getElementById("task-repeat-start");
      const re = document.getElementById("task-repeat-end");
      if (rt) rt.value = "none";
      if (rs) rs.value = task.task_date || "";
      if (re) re.value = "";

      // Store series_id if this task belongs to a series
      const seriesIdInput = document.getElementById("task-series-id");
      if (seriesIdInput) seriesIdInput.value = task.series_id || "";

      modal.dataset.date = task.task_date || "";
      modal.classList.remove("hidden");
    }


    function closeTaskModal() {
      document.getElementById("task-modal").classList.add("hidden");
    }

    async function onTaskSave() {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return;
      }
      const id = document.getElementById("task-id").value;
      const title = document.getElementById("task-title-input").value.trim();
      const notes = document.getElementById("task-notes-input").value.trim();
      const status = document.getElementById("task-status-input").value;
      const taskTime = document.getElementById("task-time-input").value || null; // "HH:MM" or null
      const assignedToId = parseInt(document.getElementById("task-assigned-to").value, 10);
      const dateStr = document.getElementById("task-modal").dataset.date;

      const repeatTypeEl = document.getElementById("task-repeat-type");
      const repeatStartEl = document.getElementById("task-repeat-start");
      const repeatEndEl = document.getElementById("task-repeat-end");

      const repeatType = repeatTypeEl ? repeatTypeEl.value : "none";
      const repeatStartStr = repeatStartEl ? repeatStartEl.value : "";
      const repeatEndStr = repeatEndEl ? repeatEndEl.value : "";

      const shouldRepeat =
        repeatType && repeatType !== "none" && repeatEndStr;

      if (!title) {
        showToast("Task title is required", true);
        return;
      }

      if (!assignedToId) {
        showToast("Assigned To is required", true);
        return;
      }

      // NEW: collect multi-assignees
      const container = document.getElementById("task-assignees-container");
      let assigneeIds = [];
      if (container) {
        const checked = container.querySelectorAll("input[type='checkbox']:checked");
        assigneeIds = Array.from(checked).map(cb => parseInt(cb.value, 10));
      }

      console.log("Saving task with status:", status); // Debug log for auto-complete issue

      // Always ensure primary assignee is included
      if (assignedToId && !assigneeIds.includes(assignedToId)) {
        assigneeIds.push(assignedToId);
      }

      const basePayload = {
        title,
        notes,
        status,
        task_time: taskTime, // scheduled time for reminders
        assigned_to_id: assignedToId,
        assignee_ids: assigneeIds,
        color: document.getElementById("task-color") ? document.getElementById("task-color").value : "#ffffff",
        priority: document.getElementById("task-priority") ? parseInt(document.getElementById("task-priority").value) : 1
      };

      try {
        if (id) {
          // Editing an existing single task
          await apiSend("/daily-tasks/" + id, "PATCH", basePayload);

          if (shouldRepeat) {
            // Spin off new future tasks based on this date and the series end
            const extraDates = computeRecurringDatesBetween(
              dateStr,
              repeatType,
              repeatStartStr || dateStr,
              repeatEndStr
            );
            if (extraDates.length) {
              // Generate a unique series_id to link these repeated tasks
              const seriesId = crypto.randomUUID();
              const payloads = extraDates.map(d => ({
                ...basePayload,
                task_date: d,
                series_id: seriesId,
                created_by_id: state.currentUser.id,
                assigned_by_id: state.currentUser.id
              }));
              await createMultipleTasks(payloads, {
                main: "Adding repeated tasksâ€¦",
                sub: "Cloning this task into the future"
              });
            }
          }
        } else {
          // Creating new task
          if (!shouldRepeat) {
            await apiSend("/daily-tasks", "POST", {
              ...basePayload,
              task_date: dateStr,
              created_by_id: state.currentUser.id,
              assigned_by_id: state.currentUser.id
            });
          } else {
            const extraDates = computeRecurringDatesBetween(
              dateStr,
              repeatType,
              repeatStartStr || dateStr,
              repeatEndStr
            );
            const allDates = [dateStr, ...extraDates];

            // Generate a unique series_id to link all tasks in this series
            const seriesId = crypto.randomUUID();
            const payloads = allDates.map(d => ({
              ...basePayload,
              task_date: d,
              series_id: seriesId,
              created_by_id: state.currentUser.id,
              assigned_by_id: state.currentUser.id
            }));

            await createMultipleTasks(payloads, {
              main: "Creating repeated tasksâ€¦",
              sub: "Dropping your series onto the Wrap Sheet"
            });
          }
        }

        closeTaskModal();
        await loadDailyTasks();
        showToast(shouldRepeat ? "Task series added" : "Task saved");
      } catch (err) {
        console.error(err);
        showToast("Error saving task", true);
      }
    }




    // Store pending delete info for the modal
    let pendingDeleteInfo = null;

    function onTaskDelete() {
      const id = document.getElementById("task-id").value;
      if (!id) return;

      // Get the task title from the modal for matching
      const taskTitle = document.getElementById("task-title-input").value.trim();

      // Find all tasks with the same title (for potential bulk delete)
      const matchingTasks = (state.dailyTasks || []).filter(t =>
        t.title && t.title.trim().toLowerCase() === taskTitle.toLowerCase()
      );

      // Store info for when user confirms
      pendingDeleteInfo = { id, taskTitle, matchingTasks };

      // Configure and show the delete confirmation modal
      const modal = document.getElementById("delete-confirm-modal");
      const message = document.getElementById("delete-confirm-message");
      const options = document.getElementById("delete-confirm-options");
      const allLabel = document.getElementById("delete-all-label");

      if (matchingTasks.length > 1) {
        // Multiple tasks - show options
        message.textContent = `Found ${matchingTasks.length} tasks named "${taskTitle}".`;
        allLabel.textContent = `Delete all ${matchingTasks.length} matching tasks`;
        options.style.display = "block";
        // Reset to "one" option
        document.querySelector('input[name="delete-choice"][value="one"]').checked = true;
      } else {
        // Single task - simple confirmation
        message.textContent = `Delete task "${taskTitle}"?`;
        options.style.display = "none";
      }

      modal.classList.remove("hidden");
    }

    async function executeTaskDelete(deleteAll) {
      if (!pendingDeleteInfo) return;

      const { id, taskTitle, matchingTasks } = pendingDeleteInfo;
      pendingDeleteInfo = null;

      // Close both modals
      document.getElementById("delete-confirm-modal").classList.add("hidden");
      closeTaskModal();

      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        if (deleteAll && matchingTasks.length > 1) {
          // Delete all tasks with the same title
          showActionLoader({
            main: "Deleting all matching tasksâ€¦",
            sub: `Removing ${matchingTasks.length} tasks named "${taskTitle}"`
          });

          // Delete each matching task
          for (const t of matchingTasks) {
            await fetch(API_BASE + "/daily-tasks/" + t.id, { method: "DELETE" });
          }

          await delayPromise;
          await loadDailyTasks();
          showToast(`Deleted ${matchingTasks.length} tasks named "${taskTitle}"`);
        } else {
          // Delete single task
          showActionLoader({
            main: "Deletingâ€¦",
            sub: "Cleaning up this task"
          });

          const fetchPromise = fetch(API_BASE + "/daily-tasks/" + id, {
            method: "DELETE"
          });

          const res = await Promise.all([fetchPromise, delayPromise]).then(
            ([res]) => res
          );

          if (!res.ok) throw new Error("Delete failed");

          await loadDailyTasks();
          showToast("Task deleted");
        }
      } catch (err) {
        console.error(err);
        showToast("Error deleting task (check Worker)", true);
      } finally {
        hideActionLoader();
      }
    }



    // ===== GOALS RENDERING & CRUD =====
    function renderMonthlyGoals() {
      const grid = document.getElementById("monthly-goals-grid");
      grid.innerHTML = "";

      const ownerFilter = state.monthlyOwnerFilter;
      const goals = state.monthlyGoals.filter(g => {
        if (ownerFilter === "all") return true;
        const filterId = parseInt(ownerFilter, 10);
        const isOwner = g.owner_id === filterId;
        const inAssigneeIds = g.assignee_ids && g.assignee_ids.includes(filterId);
        const inAssignees = g.assignees && g.assignees.some(u => u.id === filterId);
        return isOwner || inAssigneeIds || inAssignees;
      });

      const goalsByCategory = {};
      MONTHLY_CATEGORIES.forEach(cat => goalsByCategory[cat] = []);
      goals.forEach(g => {
        if (!goalsByCategory[g.category]) goalsByCategory[g.category] = [];
        goalsByCategory[g.category].push(g);
      });

      MONTHLY_CATEGORIES.forEach(category => {
        const col = document.createElement("div");
        col.className = "goal-column";

        // Apply Premium Color Design (Glassmorphism + Glow)
        const colorVar = CATEGORY_COLORS[category];
        if (colorVar) {
          // Glassy background with tint
          col.style.background = `linear-gradient(145deg, color-mix(in srgb, ${colorVar}, transparent 92%), rgba(10, 15, 30, 0.4))`;
          // Colored accent border
          col.style.border = `1px solid color-mix(in srgb, ${colorVar}, transparent 60%)`;
          col.style.borderTop = `3px solid ${colorVar}`;
          // Subtle glow
          col.style.boxShadow = `0 8px 30px -15px color-mix(in srgb, ${colorVar}, transparent 70%)`;
        } else {
          // Default styling if no category color matches (shouldn't happen for main list)
        }

        // Editable category title
        const titleInput = document.createElement("input");
        titleInput.type = "text";
        titleInput.className = "goal-column-title-input";
        // Use the color for the text, maybe add a text-shadow for "neon" feel?
        if (colorVar) {
          titleInput.style.color = colorVar;
          titleInput.style.textShadow = `0 0 10px color-mix(in srgb, ${colorVar}, transparent 70%)`;
        }

        titleInput.value = getCustomCategoryName("monthly", category);
        titleInput.dataset.originalCategory = category;
        titleInput.dataset.goalType = "monthly";
        titleInput.addEventListener("blur", () => {
          saveCustomCategoryName("monthly", category, titleInput.value.trim());
        });
        titleInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            titleInput.blur();
          }
        });
        col.appendChild(titleInput);

        const list = document.createElement("div");
        const items = goalsByCategory[category] || [];
        items.forEach(goal => {
          console.log("Rendering Goal:", goal);
          const card = document.createElement("div");
          card.className = "goal-card";
          if (goal.is_complete) card.classList.add("completed");

          const topRow = document.createElement("div");
          topRow.className = "goal-row-top";

          const titleInput = document.createElement("input");
          titleInput.className = "goal-title-input";
          titleInput.value = goal.title || "";
          titleInput.placeholder = "Goal titleâ€¦";
          titleInput.addEventListener("change", () => {
            updateMonthlyGoal(goal.id, { title: titleInput.value.trim() });
          });
          topRow.appendChild(titleInput);

          // Multi-assignee display
          const ownerTag = document.createElement("div");
          ownerTag.className = "goal-owner-tag";
          let names = [];

          // Backend returns 'assignees' array of objects {id, name, email}
          if (goal.assignees && Array.isArray(goal.assignees) && goal.assignees.length > 0) {
            names = goal.assignees.map(u => u.name.split(" ")[0]);
          } else if (goal.assignee_ids && Array.isArray(goal.assignee_ids) && goal.assignee_ids.length > 0) {
            // Fallback for immediate local optimistic update if needed
            names = goal.assignee_ids.map(id => {
              const u = state.users.find(x => x.id === id);
              return u ? u.name.split(" ")[0] : "?";
            });
          } else {
            // Fallback to owner field
            const owner = state.users.find(u => u.id === goal.owner_id);
            if (owner) names.push(owner.name.split(" ")[0]);
          }
          ownerTag.textContent = names.join(", ");
          topRow.appendChild(ownerTag);

          const editBtn = document.createElement("button");
          editBtn.type = "button";
          editBtn.className = "goal-delete-btn";
          editBtn.textContent = "âœŽ";
          editBtn.title = "Edit Details";
          editBtn.style.marginRight = "6px";
          editBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            openGoalEditModal(goal.id, 'monthly');
          });
          topRow.appendChild(editBtn);

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.className = "goal-delete-btn";
          deleteBtn.textContent = "Remove";
          deleteBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            await deleteMonthlyGoal(goal.id);
          });
          topRow.appendChild(deleteBtn);

          // Committee Tag
          if (goal.committee) {
            const commTag = document.createElement("div");
            commTag.className = "chip";
            commTag.style.fontSize = "9px";
            commTag.style.marginLeft = "4px";
            commTag.textContent = goal.committee;
            topRow.appendChild(commTag);
          }

          card.appendChild(topRow);

          const midRow = document.createElement("div");
          midRow.className = "goal-row-middle";

          const progressWrap = document.createElement("div");
          progressWrap.className = "goal-progress";
          const progressLabel = document.createElement("span");
          progressLabel.textContent = "Progress";
          const progressInput = document.createElement("input");
          progressInput.type = "number";
          progressInput.min = "0";
          progressInput.max = "100";
          progressInput.value = goal.progress_percent ?? 0;
          progressInput.addEventListener("change", () => {
            let val = parseFloat(progressInput.value);
            if (isNaN(val)) val = 0;
            if (val < 0) val = 0;
            if (val > 100) val = 100;
            progressInput.value = val;
            updateMonthlyGoal(goal.id, { progress_percent: val });
          });
          const percentSymbol = document.createElement("span");
          percentSymbol.textContent = "%";
          progressWrap.appendChild(progressLabel);
          progressWrap.appendChild(progressInput);
          progressWrap.appendChild(percentSymbol);

          midRow.appendChild(progressWrap);

          const doneLabel = document.createElement("label");
          doneLabel.className = "goal-done-toggle";
          const doneCheckbox = document.createElement("input");
          doneCheckbox.type = "checkbox";
          doneCheckbox.checked = !!goal.is_complete;
          doneCheckbox.addEventListener("change", () => {
            updateMonthlyGoal(goal.id, { is_complete: doneCheckbox.checked ? 1 : 0 });
            if (doneCheckbox.checked) {
              card.classList.add("completed");
            } else {
              card.classList.remove("completed");
            }
          });
          const doneText = document.createElement("span");
          doneText.textContent = "Done";
          doneLabel.appendChild(doneCheckbox);
          doneLabel.appendChild(doneText);
          midRow.appendChild(doneLabel);

          card.appendChild(midRow);

          const noteRow = document.createElement("div");
          noteRow.className = "goal-row-note";
          const noteArea = document.createElement("textarea");
          noteArea.value = goal.progress_note || goal.description || "";
          noteArea.placeholder = "Description / notesâ€¦";
          let noteDebounceTimer = null;
          noteArea.addEventListener("input", () => {
            clearTimeout(noteDebounceTimer);
            noteDebounceTimer = setTimeout(() => {
              updateMonthlyGoal(goal.id, { progress_note: noteArea.value.trim() });
            }, 3000); // Save after 3 seconds of no typing
          });
          noteRow.appendChild(noteArea);
          card.appendChild(noteRow);

          // Add subtasks section
          const subtasksSection = buildGoalSubtasksSection("monthly", goal.id, card);
          card.appendChild(subtasksSection);

          list.appendChild(card);
        });

        col.appendChild(list);

        // Add form for new goals in this category
        const addBtnContainer = document.createElement("div");
        addBtnContainer.className = "goal-add-form"; // reuse class for padding

        const openCreateBtn = document.createElement("button");
        openCreateBtn.textContent = "+ Add Monthly Strategy";
        openCreateBtn.style.width = "100%";
        openCreateBtn.addEventListener("click", () => {
          openGoalCreateModal("monthly", category);
        });
        addBtnContainer.appendChild(openCreateBtn);

        col.appendChild(addBtnContainer);

        grid.appendChild(col);
      });
    }

    async function updateMonthlyGoal(id, patch) {
      try {
        await apiSend("/monthly-goals/" + id, "PATCH", patch);
      } catch (err) {
        console.error(err);
        showToast("Error updating monthly goal", true);
      }
    }

    // ===== GOAL SUBTASKS =====
    async function loadGoalSubtasks(goalType, goalId) {
      try {
        return await apiGet(`/goals/${goalType}/${goalId}/subtasks`);
      } catch (err) {
        console.error("Error loading goal subtasks:", err);
        return [];
      }
    }

    async function createGoalSubtask(goalType, goalId, title) {
      try {
        const subtask = await apiSend(`/goals/${goalType}/${goalId}/subtasks`, "POST", { title });
        return subtask;
      } catch (err) {
        console.error("Error creating goal subtask:", err);
        showToast("Error adding subtask", true);
        return null;
      }
    }

    async function updateGoalSubtask(subtaskId, patch) {
      try {
        await apiSend(`/goal-subtasks/${subtaskId}`, "PATCH", patch);
      } catch (err) {
        console.error("Error updating goal subtask:", err);
        showToast("Error updating subtask", true);
      }
    }

    async function deleteGoalSubtask(subtaskId) {
      try {
        await fetch(API_BASE + `/goal-subtasks/${subtaskId}`, { method: "DELETE" });
      } catch (err) {
        console.error("Error deleting goal subtask:", err);
        showToast("Error deleting subtask", true);
      }
    }

    async function addSubtaskToCalendar(subtaskId, taskDate) {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return null;
      }
      try {
        const result = await apiSend(`/goal-subtasks/${subtaskId}/add-to-calendar`, "POST", {
          task_date: taskDate,
          assigned_to_id: state.currentUser.id,
          assigned_by_id: state.currentUser.id,
          created_by_id: state.currentUser.id
        });
        showToast("Added to calendar!");
        await loadDailyTasks();
        return result;
      } catch (err) {
        console.error("Error adding subtask to calendar:", err);
        showToast("Error adding to calendar", true);
        return null;
      }
    }

    function openAddToCalendarModal(subtaskId, subtaskTitle) {
      // Simple prompt for date
      const today = new Date().toISOString().split('T')[0];
      const dateStr = prompt(`Add "${subtaskTitle}" to calendar.\n\nEnter date (YYYY-MM-DD):`, today);
      if (!dateStr) return;

      // Validate date format
      if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
        showToast("Invalid date format. Use YYYY-MM-DD", true);
        return;
      }

      addSubtaskToCalendar(subtaskId, dateStr);
    }

    function buildGoalSubtasksSection(goalType, goalId, cardElement) {
      const section = document.createElement("div");
      section.className = "goal-subtasks";
      section.dataset.goalType = goalType;
      section.dataset.goalId = goalId;

      // Toggle to expand/collapse
      const toggle = document.createElement("div");
      toggle.className = "goal-subtasks-toggle";
      toggle.innerHTML = "â–¾ Loading..."; // Initial state

      toggle.addEventListener("click", () => {
        // Toggle visibility if loaded
        if (section.dataset.loaded === "true") {
          const list = section.querySelector(".subtasks-list");
          if (list) {
            const isHidden = list.style.display === "none";
            list.style.display = isHidden ? "block" : "none";
            toggle.innerHTML = isHidden
              ? `â–¾ Subtasks (${section.dataset.count || 0})`
              : "â–¸ Subtasks";
          }
        }
      });

      section.appendChild(toggle);

      // Auto-load subtasks immediately
      (async () => {
        try {
          const subtasks = await loadGoalSubtasks(goalType, goalId);
          section.dataset.loaded = "true";
          section.dataset.count = subtasks.length;
          renderGoalSubtasks(section, goalType, goalId, subtasks);
          // Update toggle text to show count and indicate expanded state
          toggle.innerHTML = `â–¾ Subtasks (${subtasks.length})`;
        } catch (err) {
          console.error("Auto-load subtasks failed", err);
          toggle.innerHTML = "â–¸ Subtasks (Error)";
        }
      })();

      return section;
    }

    function renderGoalSubtasks(container, goalType, goalId, subtasks) {
      // Remove old list if exists
      let list = container.querySelector(".subtasks-list");
      if (list) list.remove();

      list = document.createElement("div");
      list.className = "subtasks-list";

      subtasks.forEach(sub => {
        const row = document.createElement("div");
        row.className = "goal-subtask";
        if (sub.status === "done") row.classList.add("completed");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = sub.status === "done";
        checkbox.addEventListener("change", async () => {
          const newStatus = checkbox.checked ? "done" : "pending";
          await updateGoalSubtask(sub.id, { status: newStatus });
          if (checkbox.checked) {
            row.classList.add("completed");
          } else {
            row.classList.remove("completed");
          }
          // Refresh goals to update progress
          if (goalType === "monthly") {
            await loadMonthlyGoals();
          } else {
            await loadAnnualGoals();
          }
        });

        const titleSpan = document.createElement("span");
        titleSpan.className = "goal-subtask-title";
        titleSpan.textContent = sub.title;

        const calBtn = document.createElement("button");
        calBtn.className = "goal-subtask-calendar-btn";
        calBtn.title = sub.linked_task_id ? "Already on calendar" : "Add to calendar";
        calBtn.textContent = "ðŸ“…";
        if (sub.linked_task_id) {
          calBtn.classList.add("linked");
        }
        calBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (sub.linked_task_id) {
            showToast("Already on calendar");
          } else {
            openAddToCalendarModal(sub.id, sub.title);
          }
        });

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "goal-subtask-delete-btn";
        deleteBtn.textContent = "Ã—";
        deleteBtn.title = "Delete subtask";
        deleteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          if (confirm(`Delete subtask "${sub.title}"?`)) {
            await deleteGoalSubtask(sub.id);
            row.remove();
            // Refresh to update progress
            if (goalType === "monthly") {
              await loadMonthlyGoals();
            } else {
              await loadAnnualGoals();
            }
          }
        });

        row.appendChild(checkbox);
        row.appendChild(titleSpan);
        row.appendChild(calBtn);
        row.appendChild(deleteBtn);
        list.appendChild(row);
      });

      // Add subtask form
      const addForm = document.createElement("div");
      addForm.className = "add-subtask-form";

      const addInput = document.createElement("input");
      addInput.type = "text";
      addInput.placeholder = "New subtask...";

      const addBtn = document.createElement("button");
      addBtn.textContent = "+";
      addBtn.addEventListener("click", async () => {
        const title = addInput.value.trim();
        if (!title) return;
        const newSub = await createGoalSubtask(goalType, goalId, title);
        if (newSub) {
          addInput.value = "";
          // Reload subtasks
          const subtasks = await loadGoalSubtasks(goalType, goalId);
          renderGoalSubtasks(container, goalType, goalId, subtasks);
          // Update toggle count
          const toggle = container.querySelector(".goal-subtasks-toggle");
          if (toggle) toggle.innerHTML = `â–¾ Subtasks (${subtasks.length})`;
        }
      });

      addInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          addBtn.click();
        }
      });

      addForm.appendChild(addInput);
      addForm.appendChild(addBtn);
      list.appendChild(addForm);

      container.appendChild(list);
    }



    // ===== JOINT PROJECTS =====
    async function toggleProjectStatus(project) {
      const newStatus = project.status === 'completed' ? 'active' : 'completed';
      const confirmMsg = newStatus === 'completed'
        ? "Mark project as completed? It will move to the 'Completed' section."
        : "Re-open this project?";

      if (!confirm(confirmMsg)) return;

      try {
        showActionLoader();
        // Fix: apiPut is not defined, use apiSend
        await apiSend(`/projects/${project.id}`, "PUT", { status: newStatus });
        loadProjects(); // Reload to refresh lists
        showToast(`Project marked as ${newStatus}`);
      } catch (err) {
        console.error(err);
        showToast("Failed to update status", true);
      } finally {
        hideActionLoader();
      }
    }

    async function loadProjects() {
      try {
        const projects = await apiGet("/projects");
        state.projects = projects;
        renderProjects();
      } catch (err) {
        console.error("Error loading projects:", err);
      }
    }

    function renderProjects() {
      const grid = document.getElementById("projects-grid");
      const section = document.getElementById("section-projects");
      if (!grid) return;

      grid.innerHTML = "";

      // Cleanup old completed section if exists
      const oldCompleted = document.getElementById("completed-projects-container");
      if (oldCompleted) oldCompleted.remove();
      // Cleanup old pagination controls
      const oldControls = grid.parentNode.querySelector(".pagination-controls");
      if (oldControls) oldControls.remove();

      const projects = state.projects || [];

      if (projects.length === 0) {
        grid.innerHTML = '<div style="font-size:11px;color:var(--ink-soft);padding:10px;">No projects yet. Click "+ New Project" to create one.</div>';
        return;
      }

      const activeProjects = projects.filter(p => p.status !== 'completed');
      const completedProjects = projects.filter(p => p.status === 'completed');

      // Pagination for Active Projects
      const PROJECTS_PER_PAGE = 6; // 3x2 grid
      const { data, totalPages } = paginateList(activeProjects, paginationState.projects, PROJECTS_PER_PAGE);

      if (paginationState.projects > totalPages && totalPages > 0) {
        paginationState.projects = totalPages;
        renderProjects();
        return;
      }

      // Render Active Page
      data.forEach(project => {
        const card = buildProjectCard(project);
        grid.appendChild(card);
      });

      renderPaginationControls("projects-grid", paginationState.projects, totalPages, 'projects');

      // Render Completed
      if (completedProjects.length > 0 && section) {
        const details = document.createElement("details");
        details.id = "completed-projects-container";
        details.style.marginTop = "20px";
        details.style.borderTop = "1px solid var(--panel-border)";
        details.style.paddingTop = "15px";
        // Match grid margin quirks if necessary, or just block

        const summary = document.createElement("summary");
        summary.textContent = `Completed Projects (${completedProjects.length})`;
        summary.style.cursor = "pointer";
        summary.style.fontWeight = "600";
        summary.style.color = "var(--ink-soft)";
        summary.style.fontSize = "12px";
        summary.style.userSelect = "none";
        summary.style.outline = "none";
        summary.style.marginBottom = "15px";
        details.appendChild(summary);

        const completedGrid = document.createElement("div");
        // Re-use the grid class for layout
        completedGrid.className = "projects-grid";

        completedProjects.forEach(project => {
          const card = buildProjectCard(project);
          card.style.opacity = "0.75";
          card.style.filter = "grayscale(0.8)";
          // Ensure we can still un-complete them? 
          // buildProjectCard handles edit/delete, so yes.
          completedGrid.appendChild(card);
        });

        details.appendChild(completedGrid);
        section.appendChild(details);
      }
    }

    function buildProjectCard(project) {
      const card = document.createElement("div");
      card.className = "project-card";
      if (project.status === "completed") card.classList.add("completed");
      card.dataset.projectId = project.id;

      // Header
      const header = document.createElement("div");
      header.className = "project-header";

      const titleDiv = document.createElement("div");
      const title = document.createElement("div");
      title.className = "project-title";
      title.textContent = project.title;
      titleDiv.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "project-meta";
      meta.textContent = `by ${project.created_by_name || "Unknown"}`;
      titleDiv.appendChild(meta);

      // Waiting On / Blocking info
      if (project.waiting_on || project.blocking_task) {
        const waitingDiv = document.createElement("div");
        waitingDiv.style.marginTop = "6px";
        waitingDiv.style.fontSize = "11px";
        waitingDiv.style.color = "var(--ink-soft)";

        if (project.waiting_on) {
          const w = document.createElement("div");
          w.innerHTML = `<strong>Waiting On:</strong> ${project.waiting_on}`;
          w.style.color = "#e11d48"; // Danger color for visibility
          waitingDiv.appendChild(w);
        }
        if (project.blocking_task) {
          const b = document.createElement("div");
          b.innerHTML = `<strong>Details:</strong> ${project.blocking_task}`;
          b.style.marginTop = "2px";
          waitingDiv.appendChild(b);
        }
        titleDiv.appendChild(waitingDiv);
      }

      // Edit Button
      const editBtn = document.createElement("button");
      editBtn.textContent = "âœŽ";
      editBtn.title = "Edit Project Details";
      editBtn.style.background = "none";
      editBtn.style.border = "none";
      editBtn.style.cursor = "pointer";
      editBtn.style.fontSize = "12px";
      editBtn.style.marginLeft = "6px";
      editBtn.style.opacity = "0.5";
      editBtn.onclick = (e) => {
        e.stopPropagation();
        editProjectDetails(project);
      };
      title.appendChild(editBtn);

      // Duplicate Button
      const copyBtn = document.createElement("button");
      copyBtn.textContent = "â";
      copyBtn.title = "Duplicate Project (and reset steps)";
      copyBtn.style.background = "none";
      copyBtn.style.border = "none";
      copyBtn.style.cursor = "pointer";
      copyBtn.style.fontSize = "12px";
      copyBtn.style.marginLeft = "4px";
      copyBtn.style.opacity = "0.5";
      copyBtn.onclick = (e) => {
        e.stopPropagation();
        duplicateProject(project);
      };
      title.appendChild(copyBtn);

      const deleteProjBtn = document.createElement("button");
      deleteProjBtn.textContent = "ðŸ—‘";
      deleteProjBtn.title = "Delete Entire Project";
      deleteProjBtn.style.background = "none";
      deleteProjBtn.style.border = "none";
      deleteProjBtn.style.cursor = "pointer";
      deleteProjBtn.style.fontSize = "12px";
      deleteProjBtn.style.marginLeft = "4px";
      deleteProjBtn.style.opacity = "0.5";
      deleteProjBtn.style.color = "var(--danger)";
      deleteProjBtn.onclick = (e) => {
        e.stopPropagation();
        deleteProject(project);
      };
      title.appendChild(deleteProjBtn);

      // Completion Checkmark
      const completeBtn = document.createElement("button");
      const isCompleted = project.status === 'completed';
      completeBtn.textContent = isCompleted ? "â†©" : "âœ…";
      completeBtn.title = isCompleted ? "Re-open Project" : "Mark as Completed";
      completeBtn.style.background = "none";
      completeBtn.style.border = "none";
      completeBtn.style.cursor = "pointer";
      completeBtn.style.fontSize = "14px";
      completeBtn.style.marginLeft = "8px"; // Spacing
      completeBtn.style.color = isCompleted ? "var(--ink-soft)" : "var(--success)";
      completeBtn.onclick = (e) => {
        e.stopPropagation();
        toggleProjectStatus(project);
      };
      title.appendChild(completeBtn);

      const progressLabel = document.createElement("div");
      progressLabel.className = "project-progress-label";
      progressLabel.textContent = `${project.progress_percent || 0}%`;

      header.appendChild(titleDiv);
      header.appendChild(progressLabel);
      card.appendChild(header);

      // Progress bar
      const progressBar = document.createElement("div");
      progressBar.className = "project-progress-bar";

      const progressFill = document.createElement("div");
      progressFill.className = "project-progress-fill";
      if (project.progress_percent >= 100) progressFill.classList.add("complete");
      progressFill.style.width = `${project.progress_percent || 0}%`;
      progressBar.appendChild(progressFill);
      card.appendChild(progressBar);

      // Steps count
      const stepsInfo = document.createElement("div");
      stepsInfo.className = "project-meta";
      stepsInfo.textContent = `${project.completed_steps || 0}/${project.total_steps || 0} steps completed`;
      card.appendChild(stepsInfo);

      // Expandable steps toggle
      const toggle = document.createElement("div");
      toggle.className = "goal-subtasks-toggle";
      // Auto-expanded by default now
      toggle.innerHTML = "â–¾ Hide Steps";
      toggle.style.marginTop = "6px";

      // Render steps immediately if available
      const stepsDiv = document.createElement("div");
      stepsDiv.className = "project-steps";
      // Start visible
      stepsDiv.style.display = "block";
      card.appendChild(stepsDiv);
      renderProjectSteps(card, project);

      toggle.addEventListener("click", () => {
        const sDiv = card.querySelector(".project-steps");
        if (sDiv) {
          const isHidden = sDiv.style.display === "none";
          sDiv.style.display = isHidden ? "block" : "none";
          toggle.innerHTML = isHidden ? "â–¾ Hide Steps" : "â–¸ View Steps";
        }
      });
      card.appendChild(toggle);

      return card;
    }

    function renderProjectSteps(cardElement, project) {
      // Find existing or create new steps container
      let stepsDiv = cardElement.querySelector(".project-steps");
      if (!stepsDiv) {
        stepsDiv = document.createElement("div");
        stepsDiv.className = "project-steps";
        cardElement.appendChild(stepsDiv);
      } else {
        stepsDiv.innerHTML = "";
      }

      const currentUserId = state.currentUser?.id;
      const currentUserName = (state.currentUser?.name || "").toLowerCase();

      // Permission check: Kevin or Meighan or Project Owner
      const isSuperUser = currentUserName.includes("kevin") || currentUserName.includes("meighan");
      const isProjectOwner = project.created_by_id === currentUserId;

      (project.steps || []).forEach(step => {
        const row = document.createElement("div");
        row.className = "project-step";
        if (step.status === "done") row.classList.add("done");

        // Check if user is ONE OF the assignees
        const assignees = step.assignees || [];
        // Fallback for older API responses
        if (assignees.length === 0 && step.assigned_to_id) {
          assignees.push({ id: step.assigned_to_id, name: step.assigned_to_name });
        }

        const isAssigned = assignees.some(a => a.id === currentUserId);

        if (isAssigned && step.status !== "done") {
          row.classList.add("current-assignee");
        }

        // Status icon
        const icon = document.createElement("span");
        icon.className = "step-status-icon";
        if (step.status === "done") {
          icon.textContent = "âœ“";
          icon.style.color = "var(--success)";
        } else if (isAssigned) {
          icon.textContent = "â—";
          icon.style.color = "var(--accent)";
        } else {
          icon.textContent = "â—‹";
        }
        row.appendChild(icon);

        // Title & Metadata
        const contentDiv = document.createElement("div");
        contentDiv.style.flex = "1";
        contentDiv.style.display = "flex";
        contentDiv.style.flexDirection = "column";
        contentDiv.style.justifyContent = "center";

        // Priority Icon
        let priorityIcon = "";
        if (step.priority == 3) priorityIcon = "ðŸ”¥ ";
        else if (step.priority == 2) priorityIcon = "âš¡ ";

        const titleSpan = document.createElement("span");
        titleSpan.className = "step-title";
        titleSpan.textContent = priorityIcon + step.title;
        contentDiv.appendChild(titleSpan);

        if (step.status === "done" && step.completed_at) {
          const metaSpan = document.createElement("span");
          metaSpan.style.fontSize = "10px";
          metaSpan.style.color = "#9ca3af"; // var(--ink-soft) approx
          metaSpan.style.marginTop = "1px";

          const d = new Date(step.completed_at);
          // Short date format: Jan 16, 2:30 PM
          const dateStr = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ", " + d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
          const who = step.completed_by_name ? ` by ${step.completed_by_name.split(' ')[0]}` : "";

          metaSpan.textContent = `âœ“ ${dateStr}${who}`;
          contentDiv.appendChild(metaSpan);
        }

        row.appendChild(contentDiv);

        // Assignees Display
        const assigneeSpan = document.createElement("span");
        assigneeSpan.className = "step-assignee";
        if (assignees.length > 0) {
          assigneeSpan.textContent = assignees.map(a => a.name.split(" ")[0]).join(", ");
        } else {
          assigneeSpan.textContent = "Unassigned";
        }
        row.appendChild(assigneeSpan);

        // Action buttons
        const actionsDiv = document.createElement("div");
        actionsDiv.style.display = "flex";
        actionsDiv.style.gap = "4px";
        actionsDiv.style.marginLeft = "auto";

        // Complete Button (if assigned or super/owner)
        // Complete/Uncomplete Toggle (if assigned or super/owner)
        if (isAssigned || isSuperUser || isProjectOwner) {
          const actionBtn = document.createElement("button");
          actionBtn.className = "step-action-btn";

          if (step.status === "done") {
            actionBtn.textContent = "âœ–"; // Or undo icon
            actionBtn.title = "Mark Incomplete";
            actionBtn.style.opacity = "0.6";
          } else {
            actionBtn.textContent = "âœ“";
            actionBtn.title = "Mark Complete";
            actionBtn.style.fontWeight = "bold";
          }

          actionBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            const newStatus = step.status === "done" ? "pending" : "done";
            await toggleProjectStepStatus(step.id, project.id, newStatus);
          });
          actionsDiv.appendChild(actionBtn);
        }

        // Delete/Edit Button (SuperUser or Owner)
        if (isSuperUser || isProjectOwner) {
          const editBtn = document.createElement("button");
          editBtn.textContent = "âœŽ";
          editBtn.style.color = "var(--accent)";
          editBtn.style.background = "none";
          editBtn.style.border = "none";
          editBtn.style.cursor = "pointer";
          editBtn.style.fontSize = "14px";
          editBtn.title = "Edit Step Title";
          editBtn.onclick = async (e) => {
            e.stopPropagation();
            await editProjectStep(step, project.id);
          };
          actionsDiv.appendChild(editBtn);

          const delBtn = document.createElement("button");
          delBtn.textContent = "Ã—";
          delBtn.style.color = "var(--danger)";
          delBtn.style.background = "none";
          delBtn.style.border = "none";
          delBtn.style.cursor = "pointer";
          delBtn.style.fontSize = "14px";
          delBtn.title = "Delete Step";
          delBtn.onclick = async (e) => {
            e.stopPropagation();
            if (confirm("Delete this step?")) {
              await deleteProjectStep(step.id);
            }
          };
          actionsDiv.appendChild(delBtn);
        }

        row.appendChild(actionsDiv);
        stepsDiv.appendChild(row);
      });

      // Add step form (Multi-assign)
      const addForm = document.createElement("div");
      addForm.className = "add-step-form";
      addForm.style.flexDirection = "column";
      addForm.style.alignItems = "stretch";

      const topRow = document.createElement("div");
      topRow.style.display = "flex";
      topRow.style.gap = "6px";

      const stepInput = document.createElement("input");
      stepInput.type = "text";
      stepInput.placeholder = "New step...";
      stepInput.style.flex = "1";

      const toggleAssigneesBtn = document.createElement("button");
      toggleAssigneesBtn.textContent = "Engage Team";
      toggleAssigneesBtn.className = "button-secondary";
      toggleAssigneesBtn.style.fontSize = "11px";
      toggleAssigneesBtn.style.padding = "4px 8px";

      const assigneesContainer = document.createElement("div");
      assigneesContainer.className = "checkbox-list";
      assigneesContainer.style.display = "none"; // hidden by default
      assigneesContainer.style.marginTop = "6px";

      // Populate checkboxes
      (state.users || []).forEach(u => {
        const lbl = document.createElement("label");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = u.id;
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(u.name));
        assigneesContainer.appendChild(lbl);
      });

      toggleAssigneesBtn.onclick = () => {
        assigneesContainer.style.display = assigneesContainer.style.display === "none" ? "flex" : "none";
      };

      const addBtn = document.createElement("button");
      addBtn.textContent = "+ Add";
      addBtn.className = "button-primary";
      addBtn.style.fontSize = "11px";
      addBtn.addEventListener("click", async () => {
        const title = stepInput.value.trim();
        // Collect checked ids
        const checked = assigneesContainer.querySelectorAll("input:checked");
        const assigneeIds = Array.from(checked).map(c => parseInt(c.value));
        const primaryId = assigneeIds.length > 0 ? assigneeIds[0] : null;

        if (!title) return;

        try {
          await apiSend(`/projects/${project.id}/steps`, "POST", {
            title,
            assigned_to_id: primaryId, // backward compat
            assignee_ids: assigneeIds,
            step_order: (project.steps?.length || 0) + 1
          });
          stepInput.value = "";
          // clear checks
          checked.forEach(c => c.checked = false);
          assigneesContainer.style.display = "none";

          await loadProjects();
          showToast("Step added!");
        } catch (err) {
          console.error(err);
          showToast("Error adding step", true);
        }
      });

      topRow.appendChild(stepInput);
      topRow.appendChild(toggleAssigneesBtn);
      topRow.appendChild(addBtn);

      addForm.appendChild(topRow);
      addForm.appendChild(assigneesContainer);
      stepsDiv.appendChild(addForm);
    }

    async function deleteProjectStep(stepId) {
      try {
        await apiSend(`/project-steps/${stepId}`, "DELETE");
        await loadProjects();
        showToast("Step deleted");
      } catch (err) {
        console.error(err);
        showToast("Error deleting step", true);
      }
    }

    async function editProjectStep(step, projectId) {
      const modal = document.getElementById("project-step-modal");
      document.getElementById("edit-project-step-id").value = step.id;
      document.getElementById("edit-project-step-title-input").value = step.title;

      const container = document.getElementById("edit-project-step-assignees-container");
      container.innerHTML = "";

      const selectedIds = (step.assignees || []).map(a => String(a.id));
      if (selectedIds.length === 0 && step.assigned_to_id) {
        selectedIds.push(String(step.assigned_to_id));
      }

      (state.users || []).forEach(u => {
        const lbl = document.createElement("label");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = u.id;
        if (selectedIds.includes(String(u.id))) cb.checked = true;
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(u.name));
        container.appendChild(lbl);
      });

      modal.classList.remove("hidden");
    }

    async function saveProjectStepFromModal() {
      const stepId = document.getElementById("edit-project-step-id").value;
      const title = document.getElementById("edit-project-step-title-input").value.trim();
      const checkboxes = document.querySelectorAll("#edit-project-step-assignees-container input:checked");
      const assigneeIds = Array.from(checkboxes).map(cb => parseInt(cb.value, 10));

      if (!title) {
        showToast("Title is required", true);
        return;
      }

      try {
        await apiSend(`/project-steps/${stepId}`, "PATCH", {
          title: title,
          assignee_ids: assigneeIds,
          assigned_to_id: assigneeIds[0] || null
        });
        document.getElementById("project-step-modal").classList.add("hidden");
        await loadProjects();
        showToast("Step updated");
      } catch (err) {
        console.error(err);
        showToast("Error updating step", true);
      }
    }

    async function deleteProject(project) {
      if (!confirm(`Are you SURE you want to delete the entire project "${project.title}"? This cannot be undone.`)) return;

      try {
        await apiSend(`/projects/${project.id}`, "DELETE");
        await loadProjects();
        showToast("Project deleted");
      } catch (err) {
        console.error(err);
        showToast("Error deleting project", true);
      }
    }

    async function toggleProjectStepStatus(stepId, projectId, newStatus) {
      try {
        const body = { status: newStatus };
        if (newStatus === "done") {
          body.completed_by_id = state.currentUser.id;
        }

        await apiSend(`/project-steps/${stepId}`, "PATCH", body);
        await loadProjects();

        if (newStatus === "done") showToast("Step completed!");
        else showToast("Step unchecked");
      } catch (err) {
        console.error(err);
        showToast("Error updating step", true);
      }
    }

    async function createNewProject() {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return;
      }

      const title = prompt("Enter project name:");
      if (!title || !title.trim()) return;

      try {
        await apiSend("/projects", "POST", {
          title: title.trim(),
          created_by_id: state.currentUser.id
        });
        await loadProjects();
        showToast("Project created!");
      } catch (err) {
        console.error(err);
        showToast("Error creating project", true);
      }
    }

    async function editProjectDetails(project) {
      const waitingOn = prompt("Who are we waiting on? (Leave empty to clear)", project.waiting_on || "");
      if (waitingOn === null) return; // Cancelled

      const details = prompt("What are the details/blocking task? (Leave empty to clear)", project.blocking_task || "");
      if (details === null) return;

      try {
        await apiSend(`/projects/${project.id}`, "PATCH", {
          waiting_on: waitingOn.trim(),
          blocking_task: details.trim()
        });
        await loadProjects();
        showToast("Project details updated");
      } catch (err) {
        console.error(err);
        showToast("Error updating details", true);
      }
    }


    async function duplicateProject(project) {
      const customTitle = prompt(`Duplicate "${project.title}"? Adjust title if needed:`, `${project.title} (Copy)`);
      if (customTitle === null) return;

      try {
        showToast("Duplicating...");
        await apiSend(`/projects/${project.id}/duplicate`, "POST", { title: customTitle.trim() });
        await loadProjects();
        showToast("Project duplicated!");
      } catch (err) {
        console.error(err);
        showToast("Error duplicating project", true);
      }
    }


    // ===== WEEKLY TASKS (BETA) =====
    function getWeekKey(date = new Date()) {
      const d = new Date(date);
      d.setHours(0, 0, 0, 0);
      // ISO week number calculation
      const thursday = new Date(d.valueOf());
      thursday.setDate(d.getDate() - ((d.getDay() + 6) % 7) + 3);
      const firstThursday = new Date(thursday.getFullYear(), 0, 4);
      const weekNum = 1 + Math.round(
        ((thursday.valueOf() - firstThursday.valueOf()) / 86400000 - 3 +
          ((firstThursday.getDay() + 6) % 7)) / 7
      );
      return `${thursday.getFullYear()}-W${String(weekNum).padStart(2, "0")}`;
    }

    function parseWeekKey(weekKey) {
      const [yearStr, weekPart] = weekKey.split("-W");
      return { year: parseInt(yearStr, 10), week: parseInt(weekPart, 10) };
    }

    function formatWeekLabel(weekKey) {
      const { year, week } = parseWeekKey(weekKey);
      return `Week ${week}, ${year}`;
    }

    function shiftWeek(weekKey, delta) {
      const { year, week } = parseWeekKey(weekKey);
      let newWeek = week + delta;
      let newYear = year;
      if (newWeek < 1) {
        newYear--;
        newWeek = 52; // Approximate, some years have 53 weeks
      } else if (newWeek > 52) {
        newYear++;
        newWeek = 1;
      }
      return `${newYear}-W${String(newWeek).padStart(2, "0")}`;
    }

    async function loadWeeklyTasks() {
      if (!state.currentWeekKey) {
        state.currentWeekKey = getWeekKey();
      }

      try {
        const data = await apiGet(`/weekly-tasks?week=${state.currentWeekKey}&userId=${state.currentUser?.id || ""}`);
        state.weeklyTasks = data.tasks || [];
        renderWeeklyTasks();
      } catch (err) {
        // Silently fail for 404 or other errors to avoid disturbing user
        // console.warn("Error loading weekly tasks:", err); 
        state.weeklyTasks = [];
        renderWeeklyTasks();
      }
    }

    function renderWeeklyTasks() {
      const list = document.getElementById("weekly-tasks-list");
      const weekLabel = document.getElementById("week-label");

      if (!list) return;
      list.innerHTML = "";

      if (weekLabel && state.currentWeekKey) {
        weekLabel.textContent = formatWeekLabel(state.currentWeekKey);
      }

      if (state.weeklyTasks.length === 0) {
        list.innerHTML = '<div style="font-size:11px;color:var(--ink-soft);padding:8px;">No tasks for this week.</div>';
        return;
      }

      state.weeklyTasks.forEach(task => {
        const item = document.createElement("div");
        item.className = "weekly-task-item";
        if (task.status === "done") item.classList.add("done");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "weekly-task-checkbox";
        checkbox.checked = task.status === "done";
        checkbox.addEventListener("change", async () => {
          await toggleWeeklyTask(task.id, checkbox.checked);
        });
        item.appendChild(checkbox);

        const title = document.createElement("span");
        title.className = "weekly-task-title";
        title.textContent = task.title;
        item.appendChild(title);

        const deleteBtn = document.createElement("button");
        deleteBtn.style = "border:none;background:transparent;color:var(--danger);cursor:pointer;font-size:12px;padding:2px 4px;";
        deleteBtn.textContent = "Ã—";
        deleteBtn.addEventListener("click", async () => {
          await deleteWeeklyTask(task.id);
        });
        item.appendChild(deleteBtn);

        list.appendChild(item);
      });
    }

    async function toggleWeeklyTask(taskId, done) {
      try {
        await apiSend(`/weekly-tasks/${taskId}`, "PATCH", { status: done ? "done" : "pending" });
        await loadWeeklyTasks();
        if (done) checkWeeklyCompletion();
      } catch (err) {
        console.error(err);
        showToast("Error updating task", true);
      }
    }

    async function createWeeklyTask(title) {
      if (!title || !state.currentUser) return;

      try {
        await apiSend("/weekly-tasks", "POST", {
          title,
          week_key: state.currentWeekKey,
          assigned_to_id: state.currentUser.id,
          assigned_by_id: state.currentUser.id
        });
        await loadWeeklyTasks();
        showToast("Weekly task added!");
      } catch (err) {
        console.error(err);
        showToast("Error adding weekly task", true);
      }
    }

    async function deleteWeeklyTask(taskId) {
      try {
        await fetch(`${API_BASE}/weekly-tasks/${taskId}`, { method: "DELETE" });
        await loadWeeklyTasks();
        showToast("Task deleted");
      } catch (err) {
        console.error(err);
      }
    }

    function isWeeklyTasksUser() {
      // Show weekly tasks for users with "jenna" in their name or email (case-insensitive)
      if (!state.currentUser) return false;
      const name = (state.currentUser.name || "").toLowerCase();
      const email = (state.currentUser.email || "").toLowerCase();
      return name.includes("jenna") || email.includes("jenna");
    }

    function initWeeklyTasksUI() {
      const section = document.getElementById("section-weekly-tasks");
      if (!section) return;

      // Show only if user qualifies
      if (isWeeklyTasksUser()) {
        section.style.display = "block";
        state.currentWeekKey = getWeekKey();
        loadWeeklyTasks();
      } else {
        section.style.display = "none";
      }
    }

    // ===== USER PREFERENCES D1 SYNC =====
    async function loadUserDbPreferences() {
      if (!state.currentUser) return;

      try {
        const prefs = await apiGet(`/user-preferences/${state.currentUser.id}`);
        state.userDbPrefs = prefs;

        // Apply theme
        if (prefs.theme && prefs.theme !== state.theme) {
          applyTheme(prefs.theme);
        }

        // Apply bird settings
        if (prefs.bird_name) {
          birdName = prefs.bird_name;
          updateBirdNameUI();
        }
        if (prefs.bird_colors) {
          try {
            const colors = typeof prefs.bird_colors === 'string' ? JSON.parse(prefs.bird_colors) : prefs.bird_colors;
            if (colors) {
              currentBirdColors = { ...currentBirdColors, ...colors };
              applyBirdColors(currentBirdColors);
            }
          } catch (e) {
            console.warn("Invalid bird_colors", e);
          }
        }

        // Apply calendar view
        if (prefs.calendar_view && prefs.calendar_view !== state.calendarView) {
          state.calendarView = prefs.calendar_view;

          // Update selector UI
          const viewSelect = document.getElementById("calendar-view-select");
          if (viewSelect) viewSelect.value = state.calendarView;

          // Update view buttons if needed (legacy support)
          document.querySelectorAll(".view-btn").forEach(btn => {
            btn.classList.toggle("active", btn.dataset.view === state.calendarView);
          });

          // Re-render calendar with new view
          await refreshCalendarAndMonthlyGoals();
        }

        // Apply saved section order
        if (prefs.section_order) {
          applySavedSectionOrder();
        }

        // Apply saved section visibility (always call to allow localStorage fallback)
        applySavedSectionVisibility();
      } catch (err) {
        console.warn("Could not load user preferences:", err);
      }
    }

    async function saveUserDbPreference(key, value) {
      if (!state.currentUser) return;

      try {
        const body = { [key]: value };
        await apiSend(`/user-preferences/${state.currentUser.id}`, "PUT", body);
      } catch (err) {
        console.warn("Could not save user preference:", err);
      }
    }


    // ===== DRAGGABLE SECTIONS =====
    let draggedSection = null;

    // --- Button Drag & Drop Logic ---

    function initButtonDragAndDrop() {
      const container = document.getElementById("view-options-bar");
      if (!container) return;

      let draggedBtn = null;

      container.addEventListener("dragstart", (e) => {
        const btn = e.target.closest(".view-option");
        if (!btn) return;

        draggedBtn = btn;
        btn.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", btn.dataset.target);
      });

      container.addEventListener("dragend", (e) => {
        if (draggedBtn) {
          draggedBtn.classList.remove("dragging");
          draggedBtn = null;
        }

        // Sync Sections and Save Order on completion
        syncSectionsToButtons();
      });

      container.addEventListener("dragover", (e) => {
        e.preventDefault();
        const target = e.target.closest(".view-option");

        if (!draggedBtn || !target || target === draggedBtn) return;

        // Live Sort Logic: Move the dragged element in DOM based on cursor position
        const bounding = target.getBoundingClientRect();
        const offset = e.clientX - bounding.left;
        const midpoint = bounding.width / 2;

        if (offset < midpoint) {
          // Hovering Left side -> Insert Before
          container.insertBefore(draggedBtn, target);
        } else {
          // Hovering Right side -> Insert After
          container.insertBefore(draggedBtn, target.nextSibling);
        }
      });

      container.addEventListener("drop", (e) => {
        e.preventDefault();
        // Drop logic handled by dragover (live sort) + dragend (save)
      });
    }

    function syncSectionsToButtons() {
      const btnContainer = document.getElementById("view-options-bar");
      const sectionContainer = document.getElementById("sections-container");
      if (!btnContainer || !sectionContainer) return;

      const buttons = Array.from(btnContainer.querySelectorAll(".view-option"));

      // Reorder sections based on button order
      buttons.forEach(btn => {
        const targetIds = btn.dataset.target.split(',');
        targetIds.forEach(id => {
          const section = document.getElementById(id.trim());
          if (section) {
            sectionContainer.appendChild(section);
          }
        });
      });

      // Save the new section order
      saveSectionOrder();
      showToast("Layout saved!");
    }

    // Call this after loading section order to ensure buttons match
    function syncButtonsToSections() {
      const btnContainer = document.getElementById("view-options-bar");
      const sectionContainer = document.getElementById("sections-container");
      if (!btnContainer || !sectionContainer) return;

      const sections = Array.from(sectionContainer.querySelectorAll(".draggable-section")); // Uses current DOM order
      const processedButtons = new Set();

      sections.forEach(section => {
        // Find button that contains this section ID
        const buttons = Array.from(btnContainer.querySelectorAll(".view-option"));
        const btn = buttons.find(b => {
          const targets = b.dataset.target.split(',').map(s => s.trim());
          return targets.includes(section.id);
        });

        if (btn && !processedButtons.has(btn)) {
          btnContainer.appendChild(btn);
          processedButtons.add(btn);
        }
      });
    }


    function saveSectionOrder() {
      const container = document.getElementById("sections-container");
      if (!container) return;

      const sections = container.querySelectorAll(".draggable-section");
      const order = Array.from(sections).map(s => s.id);

      // Save to D1
      saveUserDbPreference("section_order", order);

      // Also save to localStorage as fallback
      if (state.currentUser) {
        localStorage.setItem(`section-order-${state.currentUser.id}`, JSON.stringify(order));
      }
    }

    function applySavedSectionOrder() {
      const container = document.getElementById("sections-container");
      if (!container || !state.currentUser) return;

      // Try D1 first, then localStorage
      let savedOrder = null;

      if (state.userDbPrefs && state.userDbPrefs.section_order) {
        try {
          savedOrder = typeof state.userDbPrefs.section_order === "string"
            ? JSON.parse(state.userDbPrefs.section_order)
            : state.userDbPrefs.section_order;
        } catch (e) {
          console.warn("Could not parse section order from D1");
        }
      }

      if (!savedOrder) {
        const localOrder = localStorage.getItem(`section-order-${state.currentUser.id}`);
        if (localOrder) {
          try {
            savedOrder = JSON.parse(localOrder);
          } catch (e) {
            console.warn("Could not parse section order from localStorage");
          }
        }
      }

      if (!savedOrder || !Array.isArray(savedOrder)) return;

      // Reorder sections
      savedOrder.forEach(id => {
        const section = document.getElementById(id);
        if (section) {
          container.appendChild(section);
        }
      });

      // Sync buttons to match saved section order
      syncButtonsToSections();
    }

    function initInstructionsHide() {
      const hideBtn = document.getElementById("hide-instructions-btn");
      const instructions = document.getElementById("customize-instructions");

      if (!hideBtn || !instructions) return;

      // Check if already hidden
      const hidden = localStorage.getItem("hide-customize-instructions");
      if (hidden === "true") {
        instructions.style.display = "none";
      }

      hideBtn.addEventListener("click", () => {
        instructions.style.display = "none";
        localStorage.setItem("hide-customize-instructions", "true");
      });
    }


    async function createMonthlyGoal(payload) {
      try {
        await apiSend("/monthly-goals", "POST", payload);
        await loadMonthlyGoals();
      } catch (err) {
        console.error(err);
        throw err;
      }
    }

    function renderAnnualGoals() {
      const grid = document.getElementById("annual-goals-grid");
      grid.innerHTML = "";

      const ownerFilter = state.annualOwnerFilter;
      const goals = state.annualGoals.filter(g => {
        if (ownerFilter === "all") return true;
        return String(g.owner_id) === ownerFilter;
      });

      const goalsByCategory = {};
      ANNUAL_CATEGORIES.forEach(cat => goalsByCategory[cat] = []);
      goals.forEach(g => {
        if (!goalsByCategory[g.category]) goalsByCategory[g.category] = [];
        goalsByCategory[g.category].push(g);
      });

      ANNUAL_CATEGORIES.forEach(category => {
        const col = document.createElement("div");
        col.className = "goal-column";

        // Editable category title
        const titleInput = document.createElement("input");
        titleInput.type = "text";
        titleInput.className = "goal-column-title-input";
        titleInput.value = getCustomCategoryName("annual", category);
        titleInput.dataset.originalCategory = category;
        titleInput.dataset.goalType = "annual";
        titleInput.addEventListener("blur", () => {
          saveCustomCategoryName("annual", category, titleInput.value.trim());
        });
        titleInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            titleInput.blur();
          }
        });
        col.appendChild(titleInput);

        const list = document.createElement("div");
        const items = goalsByCategory[category] || [];

        items.forEach(goal => {
          const card = document.createElement("div");
          card.className = "goal-card";
          if (goal.is_complete) card.classList.add("completed");

          const topRow = document.createElement("div");
          topRow.className = "goal-row-top";

          const titleInput = document.createElement("input");
          titleInput.className = "goal-title-input";
          titleInput.value = goal.title || "";
          titleInput.placeholder = "Goal titleâ€¦";
          titleInput.addEventListener("change", () => {
            updateAnnualGoal(goal.id, { title: titleInput.value.trim() });
          });
          topRow.appendChild(titleInput);

          const ownerTag = document.createElement("div");
          ownerTag.className = "goal-owner-tag";
          const owner = state.users.find(u => u.id === goal.owner_id);
          ownerTag.textContent = owner ? owner.name : "";
          topRow.appendChild(ownerTag);

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.className = "goal-delete-btn";
          deleteBtn.textContent = "Remove";
          deleteBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            await deleteAnnualGoal(goal.id);
          });
          topRow.appendChild(deleteBtn);

          card.appendChild(topRow);

          const midRow = document.createElement("div");
          midRow.className = "goal-row-middle";

          const progressWrap = document.createElement("div");
          progressWrap.className = "goal-progress";
          const progressLabel = document.createElement("span");
          progressLabel.textContent = "Progress";
          const progressInput = document.createElement("input");
          progressInput.type = "number";
          progressInput.min = "0";
          progressInput.max = "100";
          progressInput.value = goal.progress_percent ?? 0;
          progressInput.addEventListener("change", () => {
            let val = parseFloat(progressInput.value);
            if (isNaN(val)) val = 0;
            if (val < 0) val = 0;
            if (val > 100) val = 100;
            progressInput.value = val;
            updateAnnualGoal(goal.id, { progress_percent: val });
          });
          const percentSymbol = document.createElement("span");
          percentSymbol.textContent = "%";
          progressWrap.appendChild(progressLabel);
          progressWrap.appendChild(progressInput);
          progressWrap.appendChild(percentSymbol);

          midRow.appendChild(progressWrap);

          const doneLabel = document.createElement("label");
          doneLabel.className = "goal-done-toggle";
          const doneCheckbox = document.createElement("input");
          doneCheckbox.type = "checkbox";
          doneCheckbox.checked = !!goal.is_complete;
          doneCheckbox.addEventListener("change", () => {
            updateAnnualGoal(goal.id, { is_complete: doneCheckbox.checked ? 1 : 0 });
            if (doneCheckbox.checked) {
              card.classList.add("completed");
            } else {
              card.classList.remove("completed");
            }
          });
          const doneText = document.createElement("span");
          doneText.textContent = "Done";
          doneLabel.appendChild(doneCheckbox);
          doneLabel.appendChild(doneText);
          midRow.appendChild(doneLabel);

          card.appendChild(midRow);

          const noteRow = document.createElement("div");
          noteRow.className = "goal-row-note";
          const noteArea = document.createElement("textarea");
          noteArea.value = goal.progress_note || goal.description || "";
          noteArea.placeholder = "Description / notesâ€¦";
          let noteDebounceTimer = null;
          noteArea.addEventListener("input", () => {
            clearTimeout(noteDebounceTimer);
            noteDebounceTimer = setTimeout(() => {
              updateAnnualGoal(goal.id, { progress_note: noteArea.value.trim() });
            }, 3000); // Save after 3 seconds of no typing
          });
          noteRow.appendChild(noteArea);
          card.appendChild(noteRow);

          // Add subtasks section
          const subtasksSection = buildGoalSubtasksSection("annual", goal.id, card);
          card.appendChild(subtasksSection);

          list.appendChild(card);
        });

        col.appendChild(list);

        const addBtnContainer = document.createElement("div");
        addBtnContainer.className = "goal-add-form"; // reuse class for padding

        const openCreateBtn = document.createElement("button");
        openCreateBtn.textContent = "+ Add Annual Goal";
        openCreateBtn.style.width = "100%";
        openCreateBtn.addEventListener("click", () => {
          openGoalCreateModal("annual", category);
        });
        addBtnContainer.appendChild(openCreateBtn);

        col.appendChild(addBtnContainer);

        grid.appendChild(col);
      });
    }

    async function deleteAnnualGoal(id) {
      if (!id) return;
      if (!confirm("Remove this annual goal?")) return;

      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        showActionLoader({
          main: "Removing goalâ€¦",
          sub: "Updating your annual plan"
        });

        const fetchPromise = fetch(API_BASE + "/annual-goals/" + id, {
          method: "DELETE",
          headers: { "Accept": "application/json" }
        });

        const res = await Promise.all([fetchPromise, delayPromise]).then(
          ([res]) => res
        );

        if (!res.ok && res.status !== 204) {
          throw new Error("Delete failed");
        }

        await loadAnnualGoals();
        showToast("Annual goal removed");
      } catch (err) {
        console.error(err);
        showToast("Error removing annual goal", true);
      } finally {
        hideActionLoader();
      }
    }


    async function deleteMonthlyGoal(id) {
      if (!id) return;
      if (!confirm("Remove this monthly goal?")) return;

      // random delay between 500ms and 2000ms, plus action loader
      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        showActionLoader({
          main: "Removing goalâ€¦",
          sub: "Updating your monthly focuses"
        });

        const fetchPromise = fetch(API_BASE + "/monthly-goals/" + id, {
          method: "DELETE",
          headers: { "Accept": "application/json" }
        });

        const res = await Promise.all([fetchPromise, delayPromise]).then(
          ([res]) => res
        );

        if (!res.ok && res.status !== 204) {
          throw new Error("Delete failed");
        }

        await loadMonthlyGoals();
        showToast("Monthly goal removed");
      } catch (err) {
        console.error(err);
        showToast("Error removing monthly goal", true);
      } finally {
        hideActionLoader();
      }
    }


    async function updateAnnualGoal(id, patch) {
      try {
        await apiSend("/annual-goals/" + id, "PATCH", patch);
      } catch (err) {
        console.error(err);
        showToast("Error updating annual goal", true);
      }
    }

    async function createAnnualGoal(payload) {
      try {
        await apiSend("/annual-goals", "POST", payload);
        await loadAnnualGoals();
      } catch (err) {
        console.error(err);
        throw err;
      }
    }

    // [Fix] User Switcher Logic for Isolation
    function initUserSwitcher() {
      const confirmBtn = document.getElementById("user-select-confirm");
      const select = document.getElementById("user-select");
      const switchBtn = document.getElementById("switch-user-btn");
      const overlay = document.getElementById("user-overlay");

      if (confirmBtn && select) {
        confirmBtn.addEventListener("click", async () => {
          const val = select.value;
          if (!val) return;

          const user = state.users.find(u => String(u.id) === String(val));
          if (!user) return;

          // IMPORTANT: Save current user's coins immediately before switching
          // This prevents race condition where debounced save fires after switch
          if (state.currentUser && state.currentUser.id !== user.id) {
            clearTimeout(coinSaveTimeout); // Cancel any pending debounced save
            await saveCoinBalanceToServer(); // Save current user's coins NOW
          }

          // Force update state
          state.currentUser = user;
          state.activeUser = user;
          state.activeUserId = user.id;

          localStorage.setItem("wrapsheet-user-id", user.id);

          // Reset UI
          document.getElementById("current-user-label").textContent = user.name;
          if (overlay) overlay.style.display = "none";

          // RELOAD ALL DATA
          showActionLoader({ main: "Switching Userâ€¦", sub: "Loading your coins & bird" });

          try {
            // 1. Load Coins (Local + Server)
            await loadCoinBalance();

            // 2. Load Prefs (Bird Colors, etc.)
            await loadUserDbPreferences();

            // 3. Load Pillars & Goals
            await setActiveUser(user.id);

            // 4. Init Bird (Redraw)
            if (typeof initBirdSystem === "function") initBirdSystem();

            // 4b. Load saved bird colors and name from API
            if (typeof loadBirdPreferences === "function") await loadBirdPreferences();

            // 4c. Load shop data and apply equipped items
            await loadShopData();
            applyEquippedItems();

            // Safety retry to ensure items persist after any async bird renders
            setTimeout(() => applyEquippedItems(), 500);

            // 5. Refresh Weekly Tasks
            if (typeof initWeeklyTasksUI === "function") initWeeklyTasksUI();

            showToast(`Welcome, ${user.name.split(" ")[0]}!`);

          } catch (e) {
            console.error("Switch User Error", e);
          } finally {
            hideActionLoader();
          }
        });
      }

      if (switchBtn) {
        switchBtn.addEventListener("click", () => {
          if (overlay) overlay.style.display = "flex";
        });
      }
    }

    // ===== SECTION HELP UI =====
    function initSectionHelp() {
      const sections = {
        "section-daily-tasks": {
          title: "Daily Tasks",
          text: "Your daily action items. <strong>Tip:</strong> Drag tasks here from the Backlog to schedule them for today."
        },
        "section-backlog": {
          title: "Backlog",
          text: "A holding area for future tasks and ideas. <strong>Tip:</strong> Review weekly and drag items to Daily Tasks when ready."
        },
        "section-weekly-strategy": {
          title: "Weekly Strategy",
          text: "High-level goals for the week. <strong>Tip:</strong> Use this to align your Daily Tasks with broader objectives."
        },
        "section-projects": {
          title: "Joint Projects",
          text: "Shared long-term initiatives. <strong>Tip:</strong> Track progress and assign steps to team members."
        },
        "section-goals": {
          title: "Goals & Focus",
          text: "Long-term vision. <strong>Tip:</strong> Set Monthly and Annual goals to keep the big picture in focus."
        },
        "section-pillars": {
          title: "Pillars",
          text: "Company-wide suggestions. <strong>Tip:</strong> Submit ideas and vote on team priorities."
        }
      };

      for (const [id, info] of Object.entries(sections)) {
        const section = document.getElementById(id);
        if (!section) continue;

        // Try to find the title container
        const header = section.querySelector(".panel-title, .section-title, .projects-title");
        if (header) {
          // Avoid duplicates
          if (header.querySelector(".section-header-help")) continue;

          // Create help icon
          const helpIcon = document.createElement("span");
          helpIcon.className = "section-header-help";
          helpIcon.innerHTML = "?";
          helpIcon.title = "Show tip";
          helpIcon.style.cssText = "display:inline-flex; align-items:center; justify-content:center; width:16px; height:16px; border-radius:50%; background:var(--ink-soft); color:var(--bg-main); font-size:10px; font-weight:bold; margin-left:8px; cursor:pointer;";

          helpIcon.onclick = (e) => {
            e.stopPropagation();
            // Toggle tip
            let existingTip = section.querySelector(".tip-box");
            if (existingTip) {
              existingTip.remove();
            } else {
              const tip = document.createElement("div");
              tip.className = "tip-box";
              // Matrix Style: Black bg, white text is handled by CSS .tip-box
              tip.style.cssText = "margin-top:8px; padding:8px 12px; border-radius:6px; font-size:12px; line-height:1.4;";
              tip.innerHTML = info.text;

              // Insert after header
              header.parentNode.insertBefore(tip, header.nextSibling);
            }
          };

          header.appendChild(helpIcon);

          // Auto-show for Pillars (as requested in screenshot)
          if (id === "section-pillars") {
            const tip = document.createElement("div");
            tip.className = "tip-box";
            tip.style.cssText = "margin-top:8px; padding:8px 12px; border-radius:6px; font-size:12px; line-height:1.4;";
            tip.innerHTML = info.text;
            header.parentNode.insertBefore(tip, header.nextSibling);
          }
        }
      }
    }

    // Initialize draggable sections
    document.addEventListener("DOMContentLoaded", () => {
      initButtonDragAndDrop();
      initSectionHelp();
      applySavedSectionOrder();
      initInstructionsHide();
      initTaskReminders(); // Start reminder check loop
      initShop(); // Initialize shop UI
      if (typeof initUserSwitcher === "function") initUserSwitcher();
    });

    // ===== TASK REMINDERS SYSTEM =====
    let reminderChimeInterval = null;
    let audioContext = null;

    function initTaskReminders() {
      // Event listeners are attached dynamically in renderReminders()
      // Check for reminders every 60 seconds
      checkUpcomingReminders();
      setInterval(checkUpcomingReminders, 60000);
    }

    function checkUpcomingReminders() {
      if (!state.currentUser) return;

      // Check if chimes are enabled (defaults to true if not set)
      const chimesEnabled = localStorage.getItem("wrapsheet-reminder-chimes") !== "false";

      const now = new Date();
      const todayStr = now.toISOString().split("T")[0];
      const currentMinutes = now.getHours() * 60 + now.getMinutes();

      // Find tasks for current user with task_time set today
      const myTodayTasks = state.dailyTasks.filter(t =>
        t.task_date === todayStr &&
        t.task_time &&
        t.status !== "done" &&
        t.status !== "could_not_complete" &&
        (t.assigned_to_id === state.currentUser.id ||
          (t.assignees && t.assignees.some(a => a.id === state.currentUser.id)))
      );

      // Check dismissed reminders in localStorage (keyed by date so they reset each day)
      const dismissedKey = `dismissed-reminders-${todayStr}`;
      const dismissed = JSON.parse(localStorage.getItem(dismissedKey) || "[]");
      // Snoozed reminders (temporary hide until next cycle)
      const snoozedKey = `snoozed-reminders-${todayStr}`;
      const snoozed = JSON.parse(sessionStorage.getItem(snoozedKey) || "[]");

      // Collect all tasks within 30 minutes OR overdue that haven't been dismissed
      const upcomingTasks = [];
      for (const task of myTodayTasks) {
        const [h, m] = task.task_time.split(":").map(Number);
        const taskMinutes = h * 60 + m;
        const minutesUntil = taskMinutes - currentMinutes;

        // Show if within 30 minutes upcoming, OR overdue (negative), not dismissed, and not snoozed
        // Cap overdue display at 120 minutes (2 hours) to avoid showing ancient reminders
        if (minutesUntil <= 30 && minutesUntil >= -120 && !dismissed.includes(task.id) && !snoozed.includes(task.id)) {
          upcomingTasks.push({ task, minutesUntil });
        }
      }

      // Render all reminders
      renderReminders(upcomingTasks, chimesEnabled);
    }

    function renderReminders(upcomingTasks, chimesEnabled) {
      const container = document.getElementById("reminder-container");
      if (!container) return;

      // Clear existing reminders
      container.innerHTML = "";

      if (upcomingTasks.length === 0) {
        // Stop chime if no reminders
        if (reminderChimeInterval) {
          clearInterval(reminderChimeInterval);
          reminderChimeInterval = null;
        }
        return;
      }

      // Create a banner for each upcoming task
      upcomingTasks.forEach(({ task, minutesUntil }) => {
        const banner = document.createElement("div");
        banner.className = "reminder-banner";
        if (minutesUntil <= 0) {
          banner.classList.add("overdue"); // Add overdue styling
        }
        banner.dataset.taskId = task.id;

        // Determine the time message
        let timeMessage;
        let icon = "ðŸ””";
        if (minutesUntil > 0) {
          timeMessage = `starts in ${minutesUntil} minute${minutesUntil !== 1 ? "s" : ""}`;
        } else if (minutesUntil === 0) {
          timeMessage = `starting NOW!`;
          icon = "â°";
        } else {
          const lateMinutes = Math.abs(minutesUntil);
          timeMessage = `${lateMinutes} minute${lateMinutes !== 1 ? "s" : ""} LATE!`;
          icon = "âš ï¸";
        }

        banner.innerHTML = `
          <div class="reminder-content">
            <span class="reminder-icon">${icon}</span>
            <div class="reminder-text">
              <div class="reminder-title">${escapeHtml(task.title)}</div>
              <div class="reminder-time">${timeMessage}</div>
            </div>
            <div class="reminder-buttons">
              <button class="reminder-snooze" data-task-id="${task.id}">Snooze</button>
              <button class="reminder-dismiss" data-task-id="${task.id}">Dismiss</button>
            </div>
          </div>
        `;
        container.appendChild(banner);
      });

      // Attach event listeners
      container.querySelectorAll(".reminder-snooze").forEach(btn => {
        btn.addEventListener("click", (e) => snoozeReminder(e.target.dataset.taskId));
      });
      container.querySelectorAll(".reminder-dismiss").forEach(btn => {
        btn.addEventListener("click", (e) => dismissReminder(e.target.dataset.taskId));
      });

      // Determine chime interval based on most urgent task
      // Under 2 min: every 10 seconds | Under 5 min: every 30 seconds | Otherwise: every 5 minutes
      const mostUrgent = Math.min(...upcomingTasks.map(t => t.minutesUntil));
      let chimeIntervalMs;
      if (mostUrgent <= 2) {
        chimeIntervalMs = 10 * 1000; // 10 seconds
      } else if (mostUrgent <= 5) {
        chimeIntervalMs = 30 * 1000; // 30 seconds
      } else {
        chimeIntervalMs = 5 * 60 * 1000; // 5 minutes
      }

      // Play chime if enabled, and restart interval if urgency level changed
      if (chimesEnabled) {
        // Clear old interval if urgency changed
        if (reminderChimeInterval && window.currentChimeIntervalMs !== chimeIntervalMs) {
          clearInterval(reminderChimeInterval);
          reminderChimeInterval = null;
        }

        if (!reminderChimeInterval) {
          playReminderChime();
          reminderChimeInterval = setInterval(playReminderChime, chimeIntervalMs);
          window.currentChimeIntervalMs = chimeIntervalMs;
        }
      }
    }

    // Helper to escape HTML
    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    function dismissReminder(taskId) {
      if (!taskId) return;

      // Add to dismissed list in localStorage (keyed by today's date)
      const todayStr = new Date().toISOString().split("T")[0];
      const dismissedKey = `dismissed-reminders-${todayStr}`;
      const dismissed = JSON.parse(localStorage.getItem(dismissedKey) || "[]");
      dismissed.push(parseInt(taskId, 10));
      localStorage.setItem(dismissedKey, JSON.stringify(dismissed));

      // Re-render to remove this banner
      checkUpcomingReminders();
    }

    function snoozeReminder(taskId) {
      if (!taskId) return;

      // Add to snoozed list in sessionStorage (temporary until next check cycle)
      const todayStr = new Date().toISOString().split("T")[0];
      const snoozedKey = `snoozed-reminders-${todayStr}`;
      const snoozed = JSON.parse(sessionStorage.getItem(snoozedKey) || "[]");
      snoozed.push(parseInt(taskId, 10));
      sessionStorage.setItem(snoozedKey, JSON.stringify(snoozed));

      // Clear snooze after 60 seconds (next check cycle)
      setTimeout(() => {
        const current = JSON.parse(sessionStorage.getItem(snoozedKey) || "[]");
        const filtered = current.filter(id => id !== parseInt(taskId, 10));
        sessionStorage.setItem(snoozedKey, JSON.stringify(filtered));
      }, 60000);

      // Re-render to remove this banner temporarily
      checkUpcomingReminders();
    }

    function playReminderChime() {
      try {
        // Create audio context if not exists
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Simple pleasant chime using oscillators
        const now = audioContext.currentTime;

        // Play two notes for a pleasant notification sound
        [523.25, 659.25].forEach((freq, i) => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();

          osc.type = "sine";
          osc.frequency.value = freq;

          gain.gain.setValueAtTime(0, now + i * 0.15);
          gain.gain.linearRampToValueAtTime(0.3, now + i * 0.15 + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.5);

          osc.connect(gain);
          gain.connect(audioContext.destination);

          osc.start(now + i * 0.15);
          osc.stop(now + i * 0.15 + 0.5);
        });
      } catch (e) {
        console.warn("Could not play reminder chime:", e);
      }
    }

    // Toggle reminder chimes (for user preference)
    function toggleReminderChimes(enabled) {
      localStorage.setItem("wrapsheet-reminder-chimes", enabled ? "true" : "false");
    }

    // ===== BIRD SHOP SYSTEM =====
    let shopItems = [];
    let userInventory = [];
    let equippedItems = {};

    async function loadShopData() {
      if (!state.currentUser) return;

      try {
        // Load all shop items
        const itemsRes = await fetch(`${API_BASE}/shop/items`);
        if (itemsRes.ok) {
          shopItems = await itemsRes.json();
        }

        // Load user's inventory
        const invRes = await fetch(`${API_BASE}/users/${state.currentUser.id}/inventory`);
        if (invRes.ok) {
          userInventory = await invRes.json();
        }

        // Load user's coin balance
        const coinsRes = await fetch(`${API_BASE}/users/${state.currentUser.id}/coins`);
        if (coinsRes.ok) {
          const coinsData = await coinsRes.json();
          state.coinBalance = coinsData.coin_balance || 0;
          updateCoinCounterDisplay();
        }

        // Load equipped items
        const eqRes = await fetch(`${API_BASE}/users/${state.currentUser.id}/equipped`);
        if (eqRes.ok) {
          const data = await eqRes.json();
          equippedItems = data.equipped_items || {};
        }

        applyEquippedItems();
      } catch (err) {
        console.error("Failed to load shop data:", err);
      }
    }

    function openShopModal() {
      const modal = document.getElementById("shop-modal");
      if (modal) {
        modal.classList.remove("hidden");
        updateShopBalance();
        renderShopItems();
      }
    }

    function closeShopModal() {
      const modal = document.getElementById("shop-modal");
      if (modal) modal.classList.add("hidden");
    }

    function updateShopBalance() {
      const el = document.getElementById("shop-balance");
      if (el) {
        el.textContent = `ðŸ’° ${state.coinBalance || 0}`;
      }
    }

    function renderShopItems() {
      const grid = document.getElementById("shop-items-grid");
      if (!grid) return;

      grid.innerHTML = shopItems.map(item => {
        const owned = userInventory.some(inv => inv.item_id === item.id);
        const equipped = Object.values(equippedItems).includes(item.id);

        return `
            <div class="shop-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''}" 
                 data-item-id="${item.id}" onclick="handleShopItemClick(${item.id})">
              ${owned ? `<span class="shop-item-badge owned">Owned</span>` : ''}
              ${equipped ? `<span class="shop-item-badge equipped">Equipped</span>` : ''}
              <div class="shop-item-preview">
                ${item.svg_data ? `<svg viewBox="-25 -25 50 50" style="width:100%;height:100%">${item.svg_data}</svg>` : `<span style="font-size:24px;">${item.category === 'pet' ? 'ðŸ¾' : 'ðŸ‘’'}</span>`}
              </div>
              <div class="shop-item-name">${item.name}</div>
              <div class="shop-item-price">
                ${owned ? 'In Inventory' : `<span class="coin">ðŸ’°</span> ${item.price}`}
              </div>
            </div>
          `;
      }).join("");
    }

    function renderInventory() {
      const grid = document.getElementById("inventory-grid");
      const empty = document.getElementById("inventory-empty");
      if (!grid) return;

      // Filter shop items to only those owned
      const ownedItems = shopItems.filter(item =>
        userInventory.some(inv => (inv.item_id || inv.id) === item.id)
      );

      if (ownedItems.length === 0) {
        grid.innerHTML = "";
        if (empty) empty.style.display = "block";
        return;
      }

      if (empty) empty.style.display = "none";

      grid.innerHTML = ownedItems.map(item => {
        const equipped = Object.values(equippedItems).includes(item.id);

        return `
            <div class="shop-item ${equipped ? 'equipped' : ''}" data-item-id="${item.id}">
              ${equipped ? `<span class="shop-item-badge equipped">Equipped</span>` : ''}
              <div class="shop-item-preview">
                ${item.svg_data ? `<svg viewBox="-25 -25 50 50" style="width:100%;height:100%">${item.svg_data}</svg>` : `<span style="font-size:24px;">${item.category === 'pet' ? 'ðŸ¾' : 'ðŸ‘’'}</span>`}
              </div>
              <div class="shop-item-name">${item.name}</div>
              <button onclick="toggleEquip(${item.id}, '${item.category}')" 
                      style="margin-top:8px;padding:4px 12px;border-radius:20px;border:none;
                             background:${equipped ? '#ef4444' : '#22c55e'};color:#fff;cursor:pointer;">
                ${equipped ? 'Unequip' : 'Equip'}
              </button>
            </div>
          `;
      }).join("");
    }

    async function handleShopItemClick(itemId) {
      const item = shopItems.find(i => i.id === itemId);
      if (!item) return;

      const owned = userInventory.some(inv => inv.item_id === itemId);

      if (owned) {
        // Already owned - show equip option
        const equipped = Object.values(equippedItems).includes(itemId);
        if (equipped) {
          unequipItem(item.category);
        } else {
          equipItem(itemId, item.category);
        }
      } else {
        // Not owned - try to purchase
        await purchaseItem(itemId);
      }
    }

    async function purchaseItem(itemId) {
      if (!state.currentUser) return;

      const item = shopItems.find(i => i.id === itemId);
      if (!item) return;

      if ((state.coinBalance || 0) < item.price) {
        showToast("Not enough coins!", true);
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/users/${state.currentUser.id}/inventory`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ item_id: itemId })
        });

        if (res.ok) {
          const data = await res.json();
          state.coinBalance = data.new_balance;
          userInventory.push({ item_id: itemId, purchased_at: new Date().toISOString() });

          updateShopBalance();
          updateCoinCounterDisplay();
          renderShopItems();
          showToast(`Purchased ${item.name}! ðŸŽ‰`);
        } else {
          const err = await res.json();
          showToast(err.error || "Purchase failed", true);
        }
      } catch (err) {
        console.error("Purchase error:", err);
        showToast("Purchase failed", true);
      }
    }

    async function equipItem(itemId, category) {
      equippedItems[category] = itemId;
      try {
        await saveEquippedItems();
        applyEquippedItems();
        renderShopItems();
        renderInventory();
        showToast("Equipped!");
      } catch (e) {
        // Revert on error
        delete equippedItems[category];
        renderShopItems();
      }
    }

    async function unequipItem(category) {
      const oldItem = equippedItems[category];
      delete equippedItems[category];

      try {
        await saveEquippedItems();
        applyEquippedItems();
        renderShopItems();
        renderInventory();
        showToast("Unequipped!");
      } catch (e) {
        // Revert on error
        if (oldItem) equippedItems[category] = oldItem;
        renderShopItems();
      }
    }

    function toggleEquip(itemId, category) {
      const equipped = Object.values(equippedItems).includes(itemId);
      if (equipped) {
        unequipItem(category);
      } else {
        equipItem(itemId, category);
      }
    }

    async function saveEquippedItems() {
      if (!state.currentUser) return;

      try {
        await fetch(`${API_BASE}/users/${state.currentUser.id}/equipped`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ equipped_items: equippedItems })
        });
      } catch (err) {
        console.error("Failed to save equipped items:", err);
        showToast("Failed to save equipped items", true);
        throw err; // Re-throw to let caller know
      }
    }

    function applyEquippedItems() {
      // Remove existing equipped item overlays
      document.querySelectorAll(".equipped-item-overlay").forEach(el => el.remove());

      const birdSvg = document.getElementById("finch-svg");
      if (!birdSvg) return;

      // Apply each equipped item
      Object.entries(equippedItems).forEach(([category, itemId]) => {
        const item = shopItems.find(i => i.id === itemId);
        if (!item || !item.svg_data) return;

        // Create overlay group
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("equipped-item-overlay");
        g.setAttribute("data-category", category);

        // Position based on category
        const catLower = category.toLowerCase();
        let transform = "";

        console.log(`Applying item: ${category} (id: ${itemId})`);

        switch (catLower) {
          case "hat":
            transform = "translate(100, 25) scale(2.6)";
            break;
          case "glasses":
            transform = "translate(100, 65) scale(2.2)";
            break;
          case "scarf":
            transform = "translate(100, 100) scale(2.2)";
            break;
          case "pet":
          case "companion":
            transform = "translate(225, 140) scale(3.0)";
            // Don't add class here to avoid override, add to inner wrapper
            break;
          default:
            console.warn(`Unknown category: ${category}`);
        }
        g.setAttribute("transform", transform);

        // Wrap content in a group for animation if needed
        const animClass = (catLower === "pet" || catLower === "companion") ? "pet-anim" : "";
        g.innerHTML = `<g class="${animClass}">${item.svg_data}</g>`;

        birdSvg.appendChild(g);
      });
    }

    function initShop() {
      // Shop button in bird container
      /* Shop button moved to header coin counter
      const finchContainer = document.getElementById("finch-container");
      if (finchContainer && !document.querySelector(".shop-bird-btn")) {
        const shopBtn = document.createElement("button");
        shopBtn.className = "shop-bird-btn";
        shopBtn.innerHTML = "ðŸ›’";
        shopBtn.title = "Bird Shop";
        shopBtn.onclick = (e) => {
          e.stopPropagation();
          openShopModal();
        };
        finchContainer.appendChild(shopBtn);
      }
      */

      // Modal close button
      const closeBtn = document.getElementById("shop-modal-close");
      if (closeBtn) {
        closeBtn.onclick = closeShopModal;
      }

      // Tab switching
      document.querySelectorAll(".shop-tab").forEach(tab => {
        tab.onclick = (e) => {
          const tabName = e.target.dataset.tab;

          // Update active tab
          document.querySelectorAll(".shop-tab").forEach(t => t.classList.remove("active"));
          e.target.classList.add("active");

          // Show/hide content
          document.getElementById("shop-tab-content").style.display =
            tabName === "shop" ? "block" : "none";
          document.getElementById("inventory-tab-content").style.display =
            tabName === "inventory" ? "block" : "none";

          if (tabName === "inventory") {
            renderInventory();
          } else {
            renderShopItems();
          }
        };
      });

      // Close modal on backdrop click
      const modal = document.getElementById("shop-modal");
      if (modal) {
        modal.onclick = (e) => {
          if (e.target === modal) closeShopModal();
        };
      }
    }

    // Initialize shop when page loads (add to existing init chain)
    (function () {
      const originalInit = window.onload;
      window.onload = function () {
        if (originalInit) originalInit();
        initShop();
        // Load shop data after a short delay to ensure user is set
        setTimeout(async () => {
          if (state.currentUser) {
            await loadShopData();
          }
        }, 1000);
      };
    })();
    // ===== GOAL CREATE MODAL =====
    let createGoalContext = { type: null, category: null };
    let transientSubtasks = [];

    function initGoalCreateModal() {
      const modal = document.getElementById("goal-create-modal");
      if (!modal) return;

      document.getElementById("goal-create-modal-close").addEventListener("click", () => modal.classList.add("hidden"));
      document.getElementById("goal-create-modal-cancel").addEventListener("click", () => modal.classList.add("hidden"));

      // Subtask adding
      document.getElementById("btn-add-transient-subtask").addEventListener("click", () => {
        const input = document.getElementById("new-subtask-input");
        const val = input.value.trim();
        if (val) {
          transientSubtasks.push(val);
          renderTransientSubtasks();
          input.value = "";
          input.focus();
        }
      });
      document.getElementById("new-subtask-input").addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          document.getElementById("btn-add-transient-subtask").click();
        }
      });

      // Save
      document.getElementById("goal-create-save-btn").addEventListener("click", async () => {
        const title = document.getElementById("create-goal-title").value.trim();
        if (!title) {
          showToast("Please enter a goal name", true);
          return;
        }

        const desc = document.getElementById("create-goal-desc").value.trim();
        const committee = document.getElementById("create-goal-committee").value;
        const parentId = document.getElementById("create-goal-parent").value;

        // Assignees
        const assigneeIds = [];
        document.querySelectorAll("#create-goal-assignees-grid input:checked").forEach(cb => {
          assigneeIds.push(parseInt(cb.value, 10));
        });
        // Ensure current user is assigned if no one else? Or just rely on selection.
        // If "everyone" is selected? (Not implemented here, implied multiselect)

        // If assigneeIds is empty, maybe default to current user? 
        // Let's default to current user if empty in the UI pre-selection, but respect empty if passed.
        if (assigneeIds.length === 0 && state.currentUser) {
          assigneeIds.push(state.currentUser.id);
        }

        try {
          showActionLoader({ main: "Creating Goal...", sub: "Setting up tasks" });

          let newGoalId = null;

          if (createGoalContext.type === "monthly") {
            // Post Monthly
            // Assuming createMonthlyGoal returns the ID or we need to mod it to return ID?
            // existing createMonthlyGoal doesn't return ID. We might need to call API directly here or mod function.
            // Let's mod `createMonthlyGoal` to return the response json.
            // Actually `createMonthlyGoal` calls `apiSend`. `apiSend` returns response data.

            // Auto-add pending subtask if typed but not added
            const pendingSub = document.getElementById("new-subtask-input").value.trim();
            if (pendingSub) {
              transientSubtasks.push(pendingSub);
            }

            // Construct payload
            const payload = {
              title,
              category: createGoalContext.category,
              description: desc,
              committee: committee || null,
              annual_goal_id: parentId ? parseInt(parentId, 10) : null,
              assignee_ids: assigneeIds,
              month_key: monthKeyFromDate(state.currentMonthDate),
              owner_id: assigneeIds[0] || state.currentUser?.id // Primary owner
            };

            // We need to use apiSend directly to get the ID, because createMonthlyGoal swallows return?
            // Let's check createMonthlyGoal. It awaits but doesn't return.
            // I will use apiSend directly here for control.
            console.log("Creating Goal Payload:", payload);
            const res = await apiSend("/monthly-goals", "POST", payload);
            if (res && res.id) newGoalId = res.id;

          } else {
            // Annual
            const payload = {
              title,
              category: createGoalContext.category,
              description: desc,
              assignee_ids: assigneeIds, // If annual supports multi
              owner_id: assigneeIds[0] || state.currentUser?.id,
              year: state.annualYear
            };
            const res = await apiSend("/annual-goals", "POST", payload);
            if (res && res.id) newGoalId = res.id;
          }

          // Create Subtasks
          if (newGoalId && transientSubtasks.length > 0) {
            for (const stTitle of transientSubtasks) {
              await apiSend(`/goals/${createGoalContext.type}/${newGoalId}/subtasks`, "POST", { title: stTitle });
            }
          }

          // Refresh
          if (createGoalContext.type === "monthly") await loadMonthlyGoals();
          else await loadAnnualGoals();

          modal.classList.add("hidden");
          showToast("Goal created successfully");

        } catch (e) {
          console.error(e);
          showToast("Error creating goal", true);
        } finally {
          hideActionLoader();
        }
      });
    }

    function renderTransientSubtasks() {
      const container = document.getElementById("create-goal-subtasks-list");
      container.innerHTML = "";
      transientSubtasks.forEach((txt, idx) => {
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.gap = "6px";
        row.style.alignItems = "center";

        const span = document.createElement("span");
        span.textContent = "â€¢ " + txt;
        span.style.flex = "1";
        span.style.fontSize = "12px";

        const del = document.createElement("button");
        del.textContent = "Ã—";
        del.className = "goal-delete-btn"; // reuse style
        del.onclick = () => {
          transientSubtasks.splice(idx, 1);
          renderTransientSubtasks();
        };

        row.appendChild(span);
        row.appendChild(del);
        container.appendChild(row);
      });
    }

    function openGoalCreateModal(type, category) {
      const modal = document.getElementById("goal-create-modal");
      if (!modal) return;

      createGoalContext = { type, category };
      transientSubtasks = [];
      renderTransientSubtasks();

      document.getElementById("create-goal-title").value = "";
      document.getElementById("create-goal-desc").value = "";
      document.getElementById("new-subtask-input").value = "";
      document.getElementById("create-goal-committee").value = "";

      // Parent Dropdown
      const parentWrap = document.getElementById("create-goal-parent-wrapper");
      const parentSel = document.getElementById("create-goal-parent");
      const committeeWrap = document.getElementById("create-goal-committee-wrapper");

      if (type === "monthly") {
        parentWrap.style.display = "block";
        committeeWrap.style.display = "flex"; // label is flex or block?
        // Populate Annual Goals
        parentSel.innerHTML = '<option value="">(None)</option>';
        state.annualGoals.forEach(ag => {
          if (state.currentUser && ag.owner_id !== state.currentUser.id) return;
          const opt = document.createElement("option");
          opt.value = ag.id;
          opt.textContent = ag.title;
          parentSel.appendChild(opt);
        });
      } else {
        parentWrap.style.display = "none";
        committeeWrap.style.display = "none"; // Hide committee for annual for now
      }

      // Assignees Grid
      const grid = document.getElementById("create-goal-assignees-grid");
      grid.innerHTML = "";
      state.users.forEach(u => {
        const card = document.createElement("label");
        card.className = "assignee-option";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = u.id;

        // Pre-select current user?
        if (state.currentUser && u.id === state.currentUser.id) {
          cb.checked = true;
          card.classList.add("selected");
        }

        cb.addEventListener("change", () => {
          if (cb.checked) card.classList.add("selected");
          else card.classList.remove("selected");
        });

        const name = document.createElement("span");
        name.textContent = u.name.split(" ")[0]; // First name only for compactness

        card.appendChild(cb);
        card.appendChild(name);
        grid.appendChild(card);
      });

      document.getElementById("goal-create-modal-title").textContent = `New ${type === 'monthly' ? 'Monthly Strategy' : 'Annual Goal'}`;
      modal.classList.remove("hidden");
      document.getElementById("create-goal-title").focus();
    }

    // Call init
    document.addEventListener("DOMContentLoaded", initGoalCreateModal);

    // ===== GOAL EDIT MODAL (Advanced) =====
    let currentEditingGoalId = null;
    let currentEditingGoalType = null; // 'monthly' or 'annual'

    function initGoalEditModal() {
      const modal = document.getElementById("goal-edit-modal");
      if (!modal) return;

      document.getElementById("goal-edit-modal-close").addEventListener("click", () => modal.classList.add("hidden"));
      document.getElementById("goal-edit-modal-cancel").addEventListener("click", () => modal.classList.add("hidden"));

      document.getElementById("goal-edit-save-btn").addEventListener("click", async () => {
        if (!currentEditingGoalId || !currentEditingGoalType) return;

        const committee = document.getElementById("goal-edit-committee").value;
        const parentId = document.getElementById("goal-edit-parent").value;
        const parentIdVal = parentId ? parseInt(parentId, 10) : null;

        // Assignees
        const assigneeIds = [];
        document.querySelectorAll(".goal-edit-assignee-cb:checked").forEach(cb => {
          assigneeIds.push(parseInt(cb.value, 10));
        });

        try {
          if (currentEditingGoalType === "monthly") {
            await updateMonthlyGoal(currentEditingGoalId, {
              committee: committee || null,
              annual_goal_id: parentIdVal,
              assignee_ids: assigneeIds
            });
            await loadMonthlyGoals();
          } else {
            // Annual goals logic if needed
          }
          modal.classList.add("hidden");
          showToast("Goal updated");
        } catch (err) {
          console.error(err);
          showToast("Error updating goal", true);
        }
      });
    }

    // Call init on load
    document.addEventListener("DOMContentLoaded", initGoalEditModal);

    function openGoalEditModal(goalId, type) {
      const modal = document.getElementById("goal-edit-modal");
      if (!modal) return;

      currentEditingGoalId = goalId;
      currentEditingGoalType = type;

      // Find goal object
      let goal;
      if (type === "monthly") {
        goal = state.monthlyGoals.find(g => g.id === goalId);
        if (goal) document.getElementById("goal-edit-parent-wrapper").style.display = "block";
      } else {
        goal = state.annualGoals.find(g => g.id === goalId);
        if (goal) document.getElementById("goal-edit-parent-wrapper").style.display = "none";
      }

      if (!goal) return;

      document.getElementById("goal-edit-modal-title").textContent = `Edit ${type === 'monthly' ? 'Strategy' : 'Goal'}`;

      // Populate Committee
      document.getElementById("goal-edit-committee").value = goal.committee || "";

      // Populate Parent Goal (Annual Goals)
      const parentSelect = document.getElementById("goal-edit-parent");
      parentSelect.innerHTML = '<option value="">(None)</option>';
      state.annualGoals.forEach(ag => {
        // Filter: Only show annual goals for current user
        if (state.currentUser && ag.owner_id !== state.currentUser.id) return;

        const opt = document.createElement("option");
        opt.value = ag.id;
        opt.textContent = ag.title;
        if (goal.annual_goal_id === ag.id) opt.selected = true;
        parentSelect.appendChild(opt);
      });

      // Populate Assignees (Grid)
      const list = document.getElementById("goal-edit-assignees-list");
      list.className = "assignee-grid"; // Use grid class
      list.style.maxHeight = ""; // remove inline scroll style if exists
      list.style.overflowY = "";
      list.style.background = "transparent";
      list.innerHTML = "";

      state.users.forEach(u => {
        const label = document.createElement("label");
        label.className = "assignee-option";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.className = "goal-edit-assignee-cb";
        input.value = u.id;

        // Check if assigned
        let isAssigned = false;
        if (goal.assignees && Array.isArray(goal.assignees)) {
          if (goal.assignees.some(a => a.id === u.id)) isAssigned = true;
        } else if (goal.assignee_ids && Array.isArray(goal.assignee_ids)) {
          // fallback if backend sends raw ids
          if (goal.assignee_ids.includes(u.id)) isAssigned = true;
        } else if (goal.owner_id === u.id) {
          // Fallback to checking owner if assignees not hydrated yet
          isAssigned = true;
        }

        if (isAssigned) {
          input.checked = true;
          label.classList.add("selected");
        }

        input.addEventListener("change", () => {
          if (input.checked) label.classList.add("selected");
          else label.classList.remove("selected");
        });

        const span = document.createElement("span");
        span.textContent = u.name.split(" ")[0];

        label.appendChild(input);
        label.appendChild(span);
        list.appendChild(label);
      });

      modal.classList.remove("hidden");
    }

    // ==========================================
    // WEEKLY TEAM PLANNER LOGIC
    // ==========================================


    // Helper to get local YYYY-MM-DD
    function getLocalDateString(d) {
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function getMonday(d) {
      d = new Date(d);
      var day = d.getDay(),
        diff = d.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday
      return new Date(d.setDate(diff));;
    }

    let currentWeeklyStart = getLocalDateString(getMonday(new Date()));

    function initWeeklyPlanner() {
      // Nav Buttons
      const prevBtn = document.getElementById("weekly-prev");
      if (prevBtn) prevBtn.addEventListener("click", () => changeWeeklyWeek(-7));

      const nextBtn = document.getElementById("weekly-next");
      if (nextBtn) nextBtn.addEventListener("click", () => changeWeeklyWeek(7));

      // Initial render
      renderWeeklyPlanner();
    }

    document.addEventListener("DOMContentLoaded", initWeeklyPlanner);

    // View Options Toolbar Logic & Persistence
    document.addEventListener("DOMContentLoaded", () => {
      const toggles = document.querySelectorAll(".view-option");

      toggles.forEach(toggle => {
        const targetIds = toggle.dataset.target.split(',');

        // Check visibility of first target to determine toggle state
        const firstId = targetIds[0].trim();
        const firstSection = document.getElementById(firstId);
        if (!firstSection) return;

        // Initial state logic
        const isVisible = firstSection.style.display !== "none" && !firstSection.classList.contains("hidden");
        if (isVisible) toggle.classList.add("active");

        // Handle click
        toggle.addEventListener("click", () => {
          const isCurrentlyVisible = firstSection.style.display !== "none" && !firstSection.classList.contains("hidden");

          targetIds.forEach(id => {
            const section = document.getElementById(id.trim());
            if (!section) return;

            if (isCurrentlyVisible) {
              section.style.display = "none";
            } else {
              section.style.display = "";
              section.classList.remove("hidden");
            }
          });

          if (isCurrentlyVisible) {
            toggle.classList.remove("active");
          } else {
            toggle.classList.add("active");
          }
          // Save the new state
          saveSectionVisibility();
        });
      });
    });

    // ===== SECTION VISIBILITY PREFS =====
    function saveSectionVisibility() {
      const visibility = {};
      const toggles = document.querySelectorAll(".view-option");
      toggles.forEach(toggle => {
        const targetIds = toggle.dataset.target.split(',');
        targetIds.forEach(id => {
          const section = document.getElementById(id.trim());
          if (section) {
            const isVisible = section.style.display !== "none" && !section.classList.contains("hidden");
            visibility[id.trim()] = isVisible;
          }
        });
      });
      localStorage.setItem("wrapSheet_visibility", JSON.stringify(visibility));

      // Save to D1
      if (typeof saveUserDbPreference === 'function') {
        saveUserDbPreference("section_visibility", visibility);
      }

      // Save to localStorage fallback
      if (state.currentUser) {
        localStorage.setItem(`section-visibility-${state.currentUser.id}`, JSON.stringify(visibility));
      }
    }

    function applySavedSectionVisibility() {
      let prefs = null;

      // Try D1 first
      if (state.userDbPrefs && state.userDbPrefs.section_visibility) {
        prefs = state.userDbPrefs.section_visibility;
      }
      // Fallback to localStorage
      else if (state.currentUser) {
        const local = localStorage.getItem(`section-visibility-${state.currentUser.id}`);
        if (local) prefs = local;
      }

      if (!prefs) return;

      if (typeof prefs === 'string') {
        try { prefs = JSON.parse(prefs); } catch (e) { }
      }

      Object.keys(prefs).forEach(sectionId => {
        const section = document.getElementById(sectionId);
        const toggle = document.querySelector(`.view-option[data-target="${sectionId}"]`);

        // If we have a stored preference for this section
        if (section && toggle && prefs[sectionId] !== undefined) {
          const isVisible = prefs[sectionId];
          if (isVisible) {
            section.style.display = "";
            section.classList.remove("hidden");
            toggle.classList.add("active");
          } else {
            section.style.display = "none";
            toggle.classList.remove("active");
          }
        }
      });
    }

    function changeWeeklyWeek(days) {
      // Parse current string as local date (YYYY-MM-DD)
      const parts = currentWeeklyStart.split("-");
      const d = new Date(parts[0], parts[1] - 1, parts[2]); // Constructor uses local time

      d.setDate(d.getDate() + days);
      currentWeeklyStart = getLocalDateString(d);
      renderWeeklyPlanner();
    }

    async function renderWeeklyPlanner() {
      // Update UI Label
      // Parse YYYY-MM-DD manually to avoid UTC conversion issues
      const parts = currentWeeklyStart.split("-");
      const d = new Date(parts[0], parts[1] - 1, parts[2]);

      const label = `Week of ${d.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' })}`;
      document.getElementById("weekly-current-label").textContent = label;

      // Load Data
      const data = await loadWeeklyPlan(currentWeeklyStart);

      renderPrioritiesGrid(data);
      renderMarketingGrid(data);
      renderProjectsGrid(data);
    }

    async function loadWeeklyPlan(weekStart) {
      try {
        const res = await fetch(`${API_BASE}/weekly-planner?week=${weekStart}`, {
          // headers: { "x-user-id": state.currentUser ? state.currentUser.id : "" } // Not strictly needed for GET if public, but good practice
        });
        if (!res.ok) throw new Error("Failed to load");
        return await res.json();
      } catch (e) {
        console.error(e);
        return [];
      }
    }

    function renderPrioritiesGrid(data) {
      const container = document.getElementById("weekly-priorities-grid");
      container.innerHTML = "";

      const cols = ["", "Erica", "Katie", "Kevin", "Jenna", "Meighan", "Melodie"];
      const rows = ["1", "2", "3", "4", "5"];

      container.style.gridTemplateColumns = `40px repeat(${cols.length - 1}, 1fr)`;

      cols.forEach(c => {
        const div = document.createElement("div");
        div.className = "weekly-cell header";
        div.textContent = c;
        container.appendChild(div);
      });

      rows.forEach(r => {
        const rHead = document.createElement("div");
        rHead.className = "weekly-cell header";
        rHead.textContent = r;
        container.appendChild(rHead);

        cols.slice(1).forEach(c => {
          const cell = document.createElement("div");
          cell.className = "weekly-cell";
          // Add user color class
          cell.classList.add(`user-col-${c.toLowerCase()}`);

          const textarea = document.createElement("textarea");
          const entry = data.find(d => d.category === "priorities" && d.row_key === r && d.col_key === c);
          textarea.value = entry ? entry.value : "";

          let debounce = null;
          textarea.addEventListener("input", (e) => {
            clearTimeout(debounce);
            debounce = setTimeout(() => {
              updateWeeklyEntry("priorities", r, c, e.target.value);
            }, 2000);
          });
          cell.appendChild(textarea);
          container.appendChild(cell);
        });
      });
    }

    function renderMarketingGrid(data) {
      const container = document.getElementById("weekly-marketing-grid");
      container.innerHTML = "";

      const cols = ["Topic", "FB Post", "FB Story", "LinkedIn", "Instagram", "TikTok"];
      const rows = [
        "Microvolunteerism Monday", "Tech Tip Tuesday", "WTK Wednesday",
        "Thoughtful Thursday", "Friday Blast Shorts", "Classes",
        "Office Closures", "Daily FB Story", "Magazine Needs", "Gift Card Promotion"
      ];

      container.style.gridTemplateColumns = `200px repeat(${cols.length - 1}, 1fr)`;

      cols.forEach(c => {
        const div = document.createElement("div");
        div.className = "weekly-cell header";
        div.textContent = c;
        container.appendChild(div);
      });

      rows.forEach(r => {
        const rHead = document.createElement("div");
        rHead.className = "weekly-cell row-header";
        rHead.textContent = r;
        container.appendChild(rHead);

        cols.slice(1).forEach(c => {
          const cell = document.createElement("div");
          cell.className = "weekly-cell";
          const textarea = document.createElement("textarea");
          const entry = data.find(d => d.category === "marketing" && d.row_key === r && d.col_key === c);
          textarea.value = entry ? entry.value : "";

          let debounce = null;
          textarea.addEventListener("input", (e) => {
            clearTimeout(debounce);
            debounce = setTimeout(() => {
              updateWeeklyEntry("marketing", r, c, e.target.value);
            }, 2000);
          });
          cell.appendChild(textarea);
          container.appendChild(cell);
        });
      });
    }

    function renderProjectsGrid(data) {
      const container = document.getElementById("weekly-projects-grid");
      container.innerHTML = "";

      // Configure Grid Columns: Name, Notes, (Delete placeholder if needed later)
      const cols = ["Project / Event", "Notes"];
      container.style.gridTemplateColumns = `250px 1fr`;

      // Render Headers
      cols.forEach(c => {
        const div = document.createElement("div");
        div.className = "weekly-cell header";
        div.textContent = c;
        container.appendChild(div);
      });

      // 1. Identify existing rows from data
      const projectEntries = data.filter(d => d.category === "projects");
      let rowKeys = [...new Set(projectEntries.map(d => d.row_key))];

      // Sort keys to keep order (if they are timestamps or numbered)
      rowKeys.sort();

      // Ensure at least one row exists
      if (rowKeys.length === 0) {
        rowKeys.push(`proj_${Date.now()}`);
      }

      // 2. Render Rows
      rowKeys.forEach(rowKey => {
        renderProjectRow(container, data, rowKey);
      });

      // 3. "Add Row" Button (Outside grid? No, inside is tricky with grid layout. 
      //    We'll append a button AFTER the grid in the container's parent)

      let btnContainer = document.getElementById("projects-add-btn-container");
      if (!btnContainer) {
        btnContainer = document.createElement("div");
        btnContainer.id = "projects-add-btn-container";
        btnContainer.style.marginTop = "-35px"; // Pull up close to bottom of grid
        btnContainer.style.marginBottom = "40px";
        btnContainer.style.textAlign = "right"; // Right align
        container.parentNode.appendChild(btnContainer);
      }
      btnContainer.innerHTML = ""; // Clear old buttons

      const addBtn = document.createElement("button");
      addBtn.textContent = "+ Add Project";
      addBtn.className = "button-secondary";
      addBtn.style.fontSize = "12px";
      addBtn.onclick = () => {
        const newKey = `proj_${Date.now()}`;
        renderProjectRow(container, [], newKey); // Append new row
      };
      btnContainer.appendChild(addBtn);
    }

    function renderProjectRow(container, data, rowKey) {
      // Col 1: Name
      const c1 = document.createElement("div");
      c1.className = "weekly-cell";
      const t1 = document.createElement("textarea");
      t1.placeholder = "Project Name...";
      const e1 = data.find(d => d.category === "projects" && d.row_key === rowKey && d.col_key === "name");
      t1.value = e1 ? e1.value : "";

      let d1 = null;
      t1.addEventListener("input", (e) => {
        clearTimeout(d1);
        d1 = setTimeout(() => {
          updateWeeklyEntry("projects", rowKey, "name", e.target.value);
        }, 2000);
      });
      c1.appendChild(t1);
      container.appendChild(c1);

      // Col 2: Notes
      const c2 = document.createElement("div");
      c2.className = "weekly-cell";
      const t2 = document.createElement("textarea");
      t2.placeholder = "Details & Notes...";
      const e2 = data.find(d => d.category === "projects" && d.row_key === rowKey && d.col_key === "notes");
      t2.value = e2 ? e2.value : "";

      let d2 = null;
      t2.addEventListener("input", (e) => {
        clearTimeout(d2);
        d2 = setTimeout(() => {
          updateWeeklyEntry("projects", rowKey, "notes", e.target.value);
        }, 2000);
      });
      c2.appendChild(t2);
      container.appendChild(c2);
    }

    async function updateWeeklyEntry(category, rowKey, colKey, value) {
      if (!state.currentUser) {
        console.warn("Cannot save: No current user");
        showToast("Error: Please select a user first!", true);
        return;
      }

      // showToast("Saving...", false); // Optional: verbose

      try {
        const res = await fetch(`${API_BASE}/weekly-planner`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            week_start: currentWeeklyStart,
            category,
            row_key: rowKey,
            col_key: colKey,
            value,
            user_id: state.currentUser.id
          })
        });

        if (!res.ok) {
          const err = await res.text();
          console.error("Save failed:", err);
          showToast("Failed to save entry", true);
        } else {
          // Success
          console.log("Entry saved:", category, rowKey, colKey);
          showToast("Saved âœ“");
        }
      } catch (err) {
        console.error("Network error saving entry:", err);
        showToast("Network error: Could not save", true);
      }
    }


    // Start Ticker
    initTicker();
    setInterval(initTicker, 30000);

    let tickerTasks = [];
    let tickerQueue = [];
    let isTickerAnimating = false;
    let isTickerPaused = false;
    let currentTickerCard = null;

    async function initTicker() {
      try {
        const res = await fetch(`${API_BASE}/ticker`);
        if (!res.ok) return;
        tickerTasks = await res.json();

        const container = document.getElementById("header-ticker-container");

        // Clear or update logic? 
        // If empty, just stop
        if (tickerTasks.length === 0) {
          // No default text requested
          if (container) container.innerHTML = "";
          return;
        }

        if (tickerQueue.length === 0) {
          tickerQueue = [...tickerTasks];
        }

        if (!isTickerAnimating && tickerQueue.length > 0) {
          runTickerAnimation();
        }
      } catch (e) {
        console.error("Ticker load error", e);
      }
    }

    function startTickerLoop() {
      // Legacy function from previous replace, mostly unused now as runTickerAnimation handles queuing
      // But let's clean it up to avoid confusion if called
      if (tickerInterval) clearInterval(tickerInterval);
      runTickerAnimation();
    }

    function runTickerAnimation() {
      if (tickerQueue.length === 0) {
        if (tickerTasks.length > 0) {
          tickerQueue = [...tickerTasks];
        } else {
          isTickerAnimating = false;
          return;
        }
      }

      isTickerAnimating = true;
      const task = tickerQueue.shift();

      animateTickerCard(task, () => {
        // Wait a bit before next?
        setTimeout(() => {
          runTickerAnimation();
        }, 500);
      });
    }

    function animateTickerCard(task, onComplete) {
      const container = document.getElementById("header-ticker-container");
      if (!container) return;

      // Ensure container is clear of old cards if somehow stuck
      container.innerHTML = "";

      // Build Card
      const completedDate = new Date(task.completed_at);
      const diffMs = new Date() - completedDate;
      const diffMins = Math.floor(diffMs / 60000);
      const timeText = diffMins <= 0 ? "just now" : `${diffMins}m ago`;

      const card = document.createElement("div");
      card.className = "ticker-card";
      // Fix: Start invisible and far right to prevent "flash" at left:0
      card.style.transform = "translateX(100vw)";
      card.style.opacity = "0";

      card.innerHTML = `
            <span class="ticker-user">${task.user_name || 'Someone'}</span>
            <span style="color:#94a3b8;font-size:10px;">completed</span>
            <span class="ticker-task">${task.title}</span>
            <span class="ticker-time">${timeText}</span>
            <div class="ticker-reactions">
                <button class="ticker-reaction-btn" onclick="reactToTask(${task.id}, 'thumbs_up', this); event.stopPropagation();">
                    ðŸ‘ <span class="ticker-reaction-count">${task.thumbs_up_count || ''}</span>
                </button>
                <button class="ticker-reaction-btn" onclick="reactToTask(${task.id}, 'heart', this); event.stopPropagation();">
                    â¤ï¸ <span class="ticker-reaction-count">${task.heart_count || ''}</span>
                </button>
            </div>
        `;

      container.appendChild(card);
      currentTickerCard = card;

      card.addEventListener("mouseenter", () => isTickerPaused = true);
      card.addEventListener("mouseleave", () => isTickerPaused = false);

      // Calculate Animation
      requestAnimationFrame(() => {
        const cardWidth = card.offsetWidth || 300;
        const containerWidth = container.offsetWidth;

        let posX = containerWidth + 50;
        let state = 'SCROLL_IN';
        let scale = 1;
        let zoomTimer = 0;
        const speed = 4; // Faster entrance

        // Now that we have calculated width, set opacity back to 1 for the loop
        card.style.opacity = "1";

        function step() {
          if (isTickerPaused) {
            requestAnimationFrame(step);
            return;
          }

          const currentContainerWidth = container.offsetWidth;
          const targetCenter = (currentContainerWidth / 2) - (card.offsetWidth / 2);

          if (state === 'SCROLL_IN') {
            posX -= speed;
            if (posX <= targetCenter) {
              posX = targetCenter;
              state = 'ZOOM';
            }
          } else if (state === 'ZOOM') {
            zoomTimer++;
            // Zoom Up (30 frame/0.5s) -> Hold (240 frames/4s) -> Zoom Down (30 frames/0.5s)
            if (zoomTimer < 30) {
              scale = 1 + (0.15 * (zoomTimer / 30));
            } else if (zoomTimer > 300) {
              // Start Zoom Out after 5 seconds (300 frames)
              const outProgress = (zoomTimer - 300) / 30;
              scale = 1.15 - (0.15 * outProgress);
              if (scale < 1) scale = 1;
            }

            if (zoomTimer >= 330) { // End zoom phase
              state = 'SCROLL_OUT';
              scale = 1;
            }
          } else if (state === 'SCROLL_OUT') {
            posX -= speed;
            // Fix: Larger buffer to ensure it is FULLY off screen before removing
            if (posX < -(card.offsetWidth + 200)) {
              card.remove();
              onComplete();
              return;
            }
          }

          card.style.transform = `translateX(${posX}px) scale(${scale})`;
          if (state === 'ZOOM' && scale > 1.05) card.classList.add("zoomed");
          else card.classList.remove("zoomed");

          requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      });
    }

    async function reactToTask(taskId, reaction, btn) {
      if (!state.currentUser) {
        showToast("Please select a user first!", true);
        return;
      }

      const countSpan = btn.querySelector(".ticker-reaction-count");
      let current = parseInt(countSpan.innerText) || 0;
      countSpan.innerText = current + 1;

      btn.style.transform = "scale(1.5)";
      setTimeout(() => btn.style.transform = "scale(1)", 200);

      try {
        await fetch(`${API_BASE}/reactions`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ task_id: taskId, reaction, user_id: state.currentUser.id })
        });
      } catch (e) { console.error(e); }
    }
    // ======================================================
    // TEAM METRICS DASHBOARD
    // ======================================================

    let workloadChart = null;
    let efficiencyChart = null;

    function toggleMetricsView() {
      const dashboard = document.getElementById("team-metrics-dashboard");
      const birdContent = document.getElementById("gamification-content");
      const btn = document.getElementById("toggle-metrics-view");

      if (dashboard.style.display === "none") {
        dashboard.style.display = "block";
        birdContent.style.display = "none";
        renderTeamMetrics();
        if (btn) btn.classList.add("active");
      } else {
        dashboard.style.display = "none";
        birdContent.style.display = "flex";
        if (btn) btn.classList.remove("active");
      }
    }

    function setMetricsRange(range) {
      state.metricsRange = range;
      // Update UI buttons
      ['day', 'week', 'month'].forEach(r => {
        const btn = document.getElementById(`metrics-btn-${r}`);
        if (btn) {
          if (r === range) {
            btn.classList.add('active');
            btn.style.background = 'var(--accent)';
            btn.style.color = 'var(--bg-main)';
          } else {
            btn.classList.remove('active');
            btn.style.background = 'transparent';
            btn.style.color = 'var(--ink-soft)';
          }
        }
      });
      renderTeamMetrics();
    }

    function calculateTeamStats() {
      const allTasks = state.dailyTasks || [];
      const now = new Date();
      const todayStr = now.toISOString().split('T')[0];

      // Current Week Range (visible)
      const [startKey, endKey] = getVisibleDateRange();
      const weekStartObj = new Date(startKey);
      const weekEndObj = new Date(endKey);

      // Month Range (visible)
      const base = state.currentMonthDate;
      const mStart = new Date(base.getFullYear(), base.getMonth(), 1);
      const mEnd = new Date(base.getFullYear(), base.getMonth() + 1, 0);

      const isInRange = (dStr) => {
        if (!dStr) return false;
        const pts = dStr.split('T')[0].split('-').map(Number);
        const dObj = new Date(pts[0], pts[1] - 1, pts[2]);
        const dateKeyOnly = dStr.split('T')[0];

        if (state.metricsRange === 'day') return dateKeyOnly === todayStr;
        if (state.metricsRange === 'week') return dObj >= weekStartObj && dObj <= weekEndObj;
        if (state.metricsRange === 'month') return dObj >= mStart && dObj <= mEnd;
        return true;
      };

      // Group by User
      const userStats = {};
      const ensureUser = (id, fallbackName) => {
        if (!userStats[id]) {
          userStats[id] = {
            name: fallbackName || `User ${id}`,
            todo: 0,
            inprogress: 0,
            completed: 0,
            couldnotcomplete: 0,
            total: 0
          };
        }
        if (fallbackName && userStats[id].name.startsWith("User ")) {
          userStats[id].name = fallbackName;
        }
      };

      const CORE_TEAM = [
        { id: 1, name: "Katie" },
        { id: 2, name: "Kevin" },
        { id: 3, name: "Erica" },
        { id: 4, name: "Jenna" },
        { id: 5, name: "Meighan" },
        { id: 6, name: "Melodie" }
      ];

      CORE_TEAM.forEach(u => ensureUser(u.id, u.name));

      // Workload & Completion Counts
      allTasks.forEach(t => {
        const uid = t.assigned_to_id;
        if (!uid) return;

        // Apply Unified Filter
        if (!isInRange(t.task_date)) return;

        const possibleName = t.user_name || t.assigned_to_name || t.assignee_name;
        ensureUser(uid, possibleName);

        const stats = userStats[uid] || userStats[String(uid)];
        if (stats) {
          stats.total++;
          if (t.status === 'done') stats.completed++;
          else if (t.status === 'could_not_complete') stats.couldnotcomplete++;
          else if (t.status === 'in_progress' || t.status === 'doing') stats.inprogress++;
          else stats.todo++;
        }
      });

      // 2. Efficiency (Completed by Day & User)
      const completedByDay = {}; // Total
      const userEfficiency = {}; // { uid: { dateKey: count } }
      CORE_TEAM.forEach(u => userEfficiency[u.id] = {});

      // Use proper axis days based on range
      const days = [];
      if (state.metricsRange === 'day') {
        days.push(todayStr); // Just today
      } else if (state.metricsRange === 'week' || state.metricsRange === 'month') {
        let loopCurr = new Date(state.metricsRange === 'month' ? mStart : startKey);
        const loopEnd = new Date(state.metricsRange === 'month' ? mEnd : endKey);
        let cap = 0;
        while (loopCurr <= loopEnd && cap < 40) {
          const k = loopCurr.toISOString().split('T')[0];
          days.push(k);
          loopCurr.setDate(loopCurr.getDate() + 1);
          cap++;
        }
      }

      days.forEach(k => completedByDay[k] = 0);

      allTasks.forEach(t => {
        if (t.status === 'done') {
          const uid = t.assigned_to_id;
          const completionDate = t.completed_at || t.task_date;
          if (!isInRange(completionDate)) return;

          const dateKey = completionDate.split('T')[0];
          if (completedByDay.hasOwnProperty(dateKey)) {
            completedByDay[dateKey]++;
            if (userEfficiency[uid]) {
              userEfficiency[uid][dateKey] = (userEfficiency[uid][dateKey] || 0) + 1;
            }
          }
        }
      });

      let teamTotal = 0;
      let teamCompleted = 0;
      Object.values(userStats).forEach(s => {
        teamTotal += s.total;
        teamCompleted += s.completed;
      });

      const teamRate = teamTotal > 0 ? Math.round((teamCompleted / teamTotal) * 100) : 0;
      let mvp = { name: "None", count: -1 };
      Object.values(userStats).forEach(s => {
        if (s.completed > mvp.count) {
          mvp = { name: s.name, count: s.completed };
        }
      });
      if (mvp.count <= 0) mvp.name = "-";

      return {
        userStats,
        dailyEfficiency: days.map(d => ({ date: d, count: completedByDay[d] })),
        userEfficiency: userEfficiency, // New: structured per user
        days: days, // New: helper for chart mapping
        teamTotal,
        teamRate,
        mvp
      };
    }

    function renderTeamMetrics() {
      const stats = calculateTeamStats();

      const rangeLabel = state.metricsRange === 'day' ? 'Daily' : (state.metricsRange === 'month' ? 'Monthly' : 'Weekly');

      // 1. Render Key Stat Cards
      const statsRow = document.getElementById("metrics-stats-row");
      if (statsRow) {
        statsRow.innerHTML = `
            <div class="stat-card" style="background:var(--bg-main); padding:16px; border-radius:12px; flex:1; text-align:center;">
               <div style="font-size:24px; font-weight:800; color:var(--ink);">${stats.teamTotal}</div>
               <div style="font-size:11px; text-transform:uppercase; color:var(--ink-soft); font-weight:600;">Total ${rangeLabel} Tasks</div>
            </div>
            <div class="stat-card" style="background:var(--bg-main); padding:16px; border-radius:12px; flex:1; text-align:center;">
               <div style="font-size:24px; font-weight:800; color:${stats.teamRate >= 80 ? 'var(--success)' : 'var(--accent)'};">${stats.teamRate}%</div>
               <div style="font-size:11px; text-transform:uppercase; color:var(--ink-soft); font-weight:600;">Completion Rate</div>
            </div>
            <div class="stat-card" style="background:var(--bg-main); padding:16px; border-radius:12px; flex:1; text-align:center;">
               <div style="font-size:24px; font-weight:800; color:var(--elevate);">${stats.mvp.name}</div>
               <div style="font-size:11px; text-transform:uppercase; color:var(--ink-soft); font-weight:600;">${rangeLabel} MVP ðŸ†</div>
            </div>
         `;
      }

      // 2. Render Charts
      renderWorkloadChart(stats.userStats);
      renderEfficiencyChart(stats);
    }

    function renderWorkloadChart(userStats) {
      const canvas = document.getElementById('chart-workload');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      // Filter out "User X" entries
      const validStats = Object.values(userStats).filter(s => !s.name.startsWith("User "));

      const aggregated = {};
      validStats.forEach(s => {
        if (!aggregated[s.name]) {
          aggregated[s.name] = { name: s.name, todo: 0, inprogress: 0, completed: 0, couldnotcomplete: 0 };
        }
        aggregated[s.name].todo += (s.todo || 0);
        aggregated[s.name].inprogress += (s.inprogress || 0);
        aggregated[s.name].completed += (s.completed || 0);
        aggregated[s.name].couldnotcomplete += (s.couldnotcomplete || 0);
      });

      const finalStats = Object.values(aggregated);
      const labels = finalStats.map(s => s.name);
      const todoData = finalStats.map(s => s.todo);
      const doingData = finalStats.map(s => s.inprogress);
      const doneData = finalStats.map(s => s.completed);
      const blockedData = finalStats.map(s => s.couldnotcomplete);

      let timeLabel = state.metricsRange.charAt(0).toUpperCase() + state.metricsRange.slice(1);
      if (state.metricsRange === 'month') {
        timeLabel = state.currentMonthDate.toLocaleString("default", { month: "long" });
      }

      if (workloadChart) workloadChart.destroy();

      workloadChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'To Do',
              data: todoData,
              backgroundColor: '#9ca3af', // gray
              borderRadius: 4,
            },
            {
              label: 'In Progress',
              data: doingData,
              backgroundColor: '#3b82f6', // blue
              borderRadius: 4,
            },
            {
              label: 'Done',
              data: doneData,
              backgroundColor: '#10b981', // emerald
              borderRadius: 4,
            },
            {
              label: 'Blocked / Incomplete',
              data: blockedData,
              backgroundColor: '#ef4444', // red
              borderRadius: 4,
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: { display: true, text: `Team Workload (${timeLabel})`, align: 'start', font: { size: 14, weight: 'bold' } },
            legend: { position: 'bottom' }
          },
          scales: {
            x: { stacked: false, grid: { display: false } }, // Changed to false to show side-by-side or true for stack? User didn't specify. Groups are better.
            y: { stacked: false, beginAtZero: true, grid: { color: 'rgba(0,0,0,0.05)' } }
          }
        }
      });
    }

    function renderEfficiencyChart(stats) {
      const dailyData = stats.dailyEfficiency;
      const userEff = stats.userEfficiency;
      const days = stats.days;

      const canvas = document.getElementById('chart-efficiency');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      const labels = days.map(d => {
        const [y, m, day] = d.split('-').map(Number);
        const date = new Date(y, m - 1, day);
        if (state.metricsRange === 'day') return date.toLocaleDateString('en-US', { weekday: 'long' });
        if (state.metricsRange === 'month') return day; // Just day number for month visibility
        return date.toLocaleDateString('en-US', { weekday: 'short' });
      });

      if (efficiencyChart) efficiencyChart.destroy();

      const teamDatasets = [
        { id: 1, label: 'Katie', color: '#ec4899' },
        { id: 2, label: 'Kevin', color: '#3b82f6' },
        { id: 3, label: 'Erica', color: '#10b981' },
        { id: 4, label: 'Jenna', color: '#f59e0b' },
        { id: 5, label: 'Meighan', color: '#8b5cf6' },
        { id: 6, label: 'Melodie', color: '#64748b' }
      ];

      const datasets = [
        {
          label: 'Total',
          data: dailyData.map(d => d.count),
          borderColor: '#000000',
          backgroundColor: 'transparent',
          borderWidth: 3,
          tension: 0.4,
          pointRadius: 4
        }
      ];

      teamDatasets.forEach(u => {
        datasets.push({
          label: u.label,
          data: days.map(d => userEff[u.id] ? (userEff[u.id][d] || 0) : 0),
          borderColor: u.color,
          backgroundColor: 'transparent',
          borderWidth: 2,
          tension: 0.4,
          pointRadius: 3
        });
      });

      efficiencyChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: { display: true, text: `Daily Velocity (${state.metricsRange.charAt(0).toUpperCase() + state.metricsRange.slice(1)})`, align: 'start', font: { size: 14, weight: 'bold' } },
            legend: { display: true, position: 'bottom', labels: { boxWidth: 12, font: { size: 10 } } }
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: { autoSkip: state.metricsRange === 'month', maxTicksLimit: 10 }
            },
            y: { beginAtZero: true, suggestedMax: 5, ticks: { stepSize: 1 }, grid: { color: 'rgba(0,0,0,0.05)' } }
          }
        }
      });
    }

  </script>

  <div id="debug-version"
    style="position:fixed;bottom:0;right:0;background:red;color:white;z-index:99999;padding:5px;cursor:pointer;"
    onclick="alert('Loaded 2026/WrapSheet.html - Fixes Applied - V3')">VERSION DEBUG V3</div>
</body>

</html>