<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>BER Wrap Sheet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      /* Light / “Day” default */
      --ink: #0f172a;
      --ink-soft: #6b7280;
      --bg-main: #f3f4f6;

      --panel: #ffffff;
      --panel-elevated: #ffffff;
      --panel-border: #d1d5db;

      /* BER logo colors */
      --accent: #03aae1;
      /* teal from logo */
      --accent-soft: #fbbf24;
      /* sun */
      --accent-muted: #9ca3af;

      --danger: #e11d48;
      --success: #16a34a;

      --radius-lg: 16px;
      --radius-md: 10px;
      --radius-sm: 6px;

      --shadow-xl: 0 20px 50px rgba(15, 23, 42, 0.15);
      --shadow-md: 0 10px 25px rgba(15, 23, 42, 0.12);

      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;

      /* Board Ideas Pillar Colors */
      --elevate: #f59e0b;
      /* Amber */
      --engage: #3b82f6;
      /* Blue */
      --evolve: #10b981;
      /* Emerald */
      --excite: #ec4899;
      /* Pink */
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      background: var(--bg-main);
      background-attachment: fixed;
      background-size: cover;
      color: var(--ink);
      font-family: var(--font-sans);
      min-height: 100vh;
    }

    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Night mode – basically your current look */
    body[data-theme="dark"] {
      --ink: #e5e7eb;
      --ink-soft: #9ca3af;
      /* Defining the gradient here for reference, but applying strictly to html below */
      --bg-main: radial-gradient(circle at top left, #111827 0, #020617 45%, #000 100%);

      --panel: #020617;
      --panel-elevated: #020617;
      --panel-border: #1f2937;

      --shadow-xl: 0 25px 60px rgba(0, 0, 0, 0.65);
      --shadow-md: 0 12px 30px rgba(0, 0, 0, 0.45);
    }

    /* NUCLEAR OPTION: Force full page background on the WP Parent Site */
    html {
      background: radial-gradient(circle at top left, #111827 0, #020617 45%, #000 100%) fixed !important;
      background-size: cover !important;
      min-height: 100vh !important;
    }

    /* Make standard WP/Elementor containers transparent so background shows through */
    body,
    #page,
    .site-content,
    .app-main,
    header.ber-header,
    footer.elementor-location-footer,
    .elementor-section,
    .elementor-column {
      background: transparent !important;
      box-shadow: none !important;
    }

    /* Ensure footer text is visible if it relies on black bg */
    footer.elementor-location-footer h1,
    footer.elementor-location-footer h2,
    footer.elementor-location-footer h3,
    footer.elementor-location-footer p,
    footer.elementor-location-footer li,
    footer.elementor-location-footer a {
      color: rgba(255, 255, 255, 0.8) !important;
    }

    /* Hide the Parent Header to give Wrap Sheet full real estate */
    header.ber-header,
    .elementor-location-header,
    #masthead,
    .site-header {
      display: none !important;
    }

    .app-shell {
      max-width: 1440px;
      margin: 0 auto;
      padding: 16px 16px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    header.app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-radius: var(--radius-lg);
      background: var(--panel-elevated);
      box-shadow: var(--shadow-md);
      border: 1px solid var(--panel-border);
    }

    .branding {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .branding-mark {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #fbbf24, var(--accent) 60%, #0f172a 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #f9fafb;
      font-weight: 800;
      font-size: 18px;
      letter-spacing: 0.08em;
    }

    .branding-text h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .branding-text span {
      display: block;
      margin-top: 2px;
      font-size: 11px;
      color: var(--ink-soft);
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .user-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(3, 170, 225, 0.06);
      /* light, on white */
      border: 1px solid var(--panel-border);
      font-size: 12px;
      color: var(--ink-soft);
    }

    body[data-theme="dark"] .user-pill {
      background: rgba(15, 23, 42, 0.9);
      border-color: rgba(148, 163, 184, 0.4);
    }

    .user-pill button {
      border: none;
      background: rgba(248, 250, 252, 0.06);
      color: var(--ink);
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
    }

    .user-pill button:hover {
      background: rgba(248, 250, 252, 0.18);
    }

    main.app-main {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .panel {
      background: var(--panel);
      border-radius: var(--radius-lg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow-xl);
      padding: 12px 12px 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(55, 65, 81, 0.9);
    }

    .panel-title {
      font-size: 13px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .chip {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--ink-soft);
    }

    .chip-accent {
      border-color: rgba(248, 113, 113, 0.9);
      color: #fecaca;
    }

    /* Calendar */

    .calendar-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--ink-soft);
    }

    .calendar-controls button {
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.95);
      color: var(--ink);
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
    }

    .calendar-controls button:hover {
      border-color: var(--accent-soft);
    }

    .calendar-controls span.month-label {
      font-size: 13px;
      font-weight: 600;
      color: #f9fafb;
    }

    .calendar-controls select {
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.95);
      color: var(--ink);
      padding: 3px 8px;
      font-size: 11px;
    }

    .calendar-legend {
      margin-left: auto;
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 11px;
    }

    .legend-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      margin-right: 4px;
      display: inline-block;
    }

    .legend-pending {
      background: rgba(248, 250, 252, 0.26);
    }

    .legend-inprogress {
      background: var(--accent-soft);
    }

    .legend-done {
      background: var(--success);
    }

    .legend-blocked {
      background: var(--danger);
    }

    .calendar-grid {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 4px;
      margin-top: 6px;
    }

    .calendar-weekdays {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 4px;
      font-size: 11px;
      color: var(--ink-soft);
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .calendar-weekdays div {
      text-align: center;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
    }

    .calendar-days {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 4px;
      font-size: 11px;
    }

    .day-cell {
      position: relative;
      min-height: 86px;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.98));
      border-radius: var(--radius-md);
      border: 1px solid rgba(55, 65, 81, 0.9);
      padding: 4px 4px 20px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .day-cell.is-today {
      border-color: var(--accent-soft);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    .day-cell-empty {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .day-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
    }

    .day-number {
      font-size: 12px;
      font-weight: 600;
    }

    .add-task-btn {
      border: none;
      background: transparent;
      color: var(--ink-soft);
      font-size: 14px;
      cursor: pointer;
      padding: 0 3px;
    }

    .add-task-btn:hover {
      color: var(--accent-soft);
    }

    .tasks-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
      overflow-y: auto;
      scrollbar-width: thin;
    }

    .task-pill {
      display: flex;
      align-items: flex-start;
      gap: 4px;
      padding: 4px 6px;
      border-radius: var(--radius-sm);
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(75, 85, 99, 0.9);
      cursor: pointer;
      white-space: normal;
      word-wrap: break-word;
      min-height: fit-content;
    }

    .task-quick-actions {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: auto;
      flex-shrink: 0;
    }

    .task-quick-actions input[type="checkbox"] {
      cursor: pointer;
    }

    .task-quick-actions button {
      border: none;
      border-radius: 999px;
      padding: 0 6px;
      font-size: 10px;
      background: rgba(127, 29, 29, 0.9);
      color: #fee2e2;
      cursor: pointer;
    }

    .task-quick-actions button.active {
      background: #b91c1c;
    }


    .task-status-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      flex-shrink: 0;
    }

    .task-status-pending {
      background: rgba(248, 250, 252, 0.3);
    }

    .task-status-in_progress {
      background: var(--accent-soft);
    }

    .task-status-done {
      background: var(--success);
    }

    .task-status-could_not_complete {
      background: var(--danger);
    }

    /* ADD THIS */

    .task-title {
      flex: 1;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .task-assignee {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .calendar-metrics {
      margin-top: 8px;
      display: flex;
      justify-content: flex-end;
    }

    #status-pie {
      max-width: 180px;
      max-height: 180px;
    }

    /* Goals */

    .goals-tabs {
      display: flex;
      gap: 6px;
      border-radius: 999px;
      padding: 2px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(55, 65, 81, 0.9);
      font-size: 11px;
    }

    .goals-tab {
      flex: 1;
      padding: 4px 6px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: var(--ink-soft);
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    .goals-tab.active {
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #f9fafb;
    }

    .goals-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 11px;
      color: var(--ink-soft);
      align-items: center;
    }

    .goals-controls label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .goals-controls input[type="month"],
    .goals-controls select,
    .goals-controls input[type="number"] {
      background: rgba(15, 23, 42, 0.96);
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      color: var(--ink);
      padding: 3px 8px;
      font-size: 11px;
    }

    .goals-grid {
      margin-top: 8px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    @media (max-width: 1200px) {
      .goals-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 780px) {
      .goals-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .goal-column {
      border-radius: var(--radius-md);
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.97), rgba(15, 23, 42, 0.99));
      padding: 6px 6px 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .goal-column-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--ink-soft);
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      padding-bottom: 4px;
    }

    .goal-card {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.97);
      padding: 4px;
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 2px;
      font-size: 11px;
    }

    .goal-card.completed {
      border-color: var(--success);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.4);
    }

    .goal-row-top {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      align-items: center;
    }

    .goal-title-input {
      width: 100%;
      background: transparent;
      border: none;
      color: var(--ink);
      font-size: 11px;
      font-weight: 500;
      padding: 0;
      outline: none;
    }

    .goal-owner-tag {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .goal-row-middle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-top: 2px;
    }

    .goal-progress {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      font-size: 10px;
      color: var(--ink-soft);
    }

    .goal-progress input[type="number"] {
      width: 48px;
      padding: 1px 4px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      font-size: 10px;
    }

    .goal-done-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      cursor: pointer;
    }

    .goal-row-note {
      margin-top: 2px;
    }

    .goal-row-note textarea {
      width: 100%;
      min-height: 36px;
      resize: vertical;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 2px 4px;
      outline: none;
    }

    .goal-add-form {
      margin-top: 4px;
      padding-top: 4px;
      border-top: 1px dashed rgba(55, 65, 81, 0.8);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .goal-add-form input,
    .goal-add-form select {
      width: 100%;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 2px 4px;
    }

    .goal-add-form button {
      align-self: flex-end;
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #f9fafb;
      cursor: pointer;
    }

    /* Editable category header input */
    .goal-column-title-input {
      background: transparent;
      border: none;
      border-bottom: 1px dashed transparent;
      color: var(--ink-soft);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      padding: 0;
      padding-bottom: 4px;
      outline: none;
      width: 100%;
      cursor: text;
    }

    .goal-column-title-input:hover,
    .goal-column-title-input:focus {
      border-bottom-color: var(--accent);
    }

    /* Goal subtasks section */
    .goal-subtasks {
      margin-top: 4px;
      padding-top: 4px;
      border-top: 1px dashed rgba(55, 65, 81, 0.6);
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .goal-subtask {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 0;
      font-size: 10px;
    }

    .goal-subtask input[type="checkbox"] {
      cursor: pointer;
      flex-shrink: 0;
    }

    .goal-subtask-title {
      flex: 1;
      color: var(--ink);
    }

    .goal-subtask.completed .goal-subtask-title {
      text-decoration: line-through;
      opacity: 0.6;
    }

    .goal-subtask-calendar-btn {
      border: none;
      background: transparent;
      color: var(--ink-soft);
      cursor: pointer;
      padding: 0 2px;
      font-size: 12px;
      opacity: 0.7;
      transition: opacity 0.1s;
    }

    .goal-subtask-calendar-btn:hover {
      opacity: 1;
      color: var(--accent);
    }

    .goal-subtask-calendar-btn.linked {
      color: var(--success);
      opacity: 1;
    }

    .goal-subtask-delete-btn {
      border: none;
      background: transparent;
      color: var(--danger);
      cursor: pointer;
      padding: 0 2px;
      font-size: 10px;
      opacity: 0.6;
    }

    .goal-subtask-delete-btn:hover {
      opacity: 1;
    }

    .add-subtask-form {
      display: flex;
      gap: 4px;
      margin-top: 2px;
    }

    .add-subtask-form input {
      flex: 1;
      font-size: 10px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 2px 4px;
    }

    .add-subtask-form button {
      border: none;
      background: rgba(55, 65, 81, 0.8);
      color: var(--ink);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 10px;
      cursor: pointer;
    }

    .add-subtask-form button:hover {
      background: var(--accent);
    }

    /* Goal subtasks toggle */
    .goal-subtasks-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 9px;
      color: var(--ink-soft);
      cursor: pointer;
      margin-top: 3px;
      padding: 2px 0;
    }

    .goal-subtasks-toggle:hover {
      color: var(--accent);
    }

    /* ===== JOINT PROJECTS ===== */
    .projects-section {
      margin-top: 16px;
      padding-top: 14px;
      border-top: 1px dashed rgba(55, 65, 81, 0.45);
    }

    .projects-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .projects-title {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .add-project-btn {
      font-size: 10px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: transparent;
      color: var(--ink);
      cursor: pointer;
    }

    .add-project-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .projects-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 10px;
    }

    .project-card {
      border-radius: var(--radius-md);
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.97);
      padding: 10px;
    }

    .project-card.completed {
      border-color: var(--success);
      opacity: 0.8;
    }

    .project-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .project-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
    }

    .project-meta {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .project-progress-bar {
      height: 8px;
      border-radius: 4px;
      background: rgba(55, 65, 81, 0.6);
      overflow: hidden;
      margin: 6px 0;
    }

    .project-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-soft));
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .project-progress-fill.complete {
      background: var(--success);
    }

    .project-progress-label {
      font-size: 10px;
      color: var(--ink-soft);
      text-align: right;
    }

    .project-steps {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .project-step {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 4px;
      background: rgba(31, 41, 55, 0.5);
      font-size: 11px;
    }

    .project-step.current-assignee {
      background: rgba(3, 170, 225, 0.15);
      border: 1px solid rgba(3, 170, 225, 0.5);
    }

    .project-step.done {
      opacity: 0.6;
    }

    .step-status-icon {
      flex-shrink: 0;
      width: 14px;
      text-align: center;
    }

    .step-title {
      flex: 1;
      color: var(--ink);
    }

    .step-done .step-title {
      text-decoration: line-through;
    }

    .step-assignee {
      font-size: 10px;
      color: var(--ink-soft);
    }

    .step-action-btn {
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
    }

    .step-action-btn:hover {
      background: var(--accent-soft);
    }

    .add-step-form {
      display: flex;
      gap: 4px;
      margin-top: 6px;
    }

    .add-step-form input,
    .add-step-form select {
      flex: 1;
      font-size: 10px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 3px 5px;
    }

    .add-step-form button {
      border: none;
      background: rgba(55, 65, 81, 0.8);
      color: var(--ink);
      border-radius: 4px;
      padding: 3px 8px;
      font-size: 10px;
      cursor: pointer;
    }

    /* Light mode for projects */
    body:not([data-theme="dark"]) .project-card {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .project-title {
      color: #0f172a;
    }

    body:not([data-theme="dark"]) .project-step {
      background: #f9fafb;
    }

    body:not([data-theme="dark"]) .project-step.current-assignee {
      background: rgba(3, 170, 225, 0.1);
    }

    body:not([data-theme="dark"]) .step-title {
      color: #0f172a;
    }

    body:not([data-theme="dark"]) .add-step-form input,
    body:not([data-theme="dark"]) .add-step-form select {
      background: #ffffff;
      border-color: #d1d5db;
      color: #0f172a;
    }

    /* ===== WEEKLY TASKS (BETA) ===== */
    .weekly-tasks-section {
      margin-top: 16px;
      padding-top: 14px;
      border-top: 1px dashed rgba(55, 65, 81, 0.45);
    }

    .weekly-tasks-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .weekly-tasks-title {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .beta-badge {
      font-size: 9px;
      font-weight: 600;
      background: linear-gradient(135deg, #f59e0b, #f97316);
      color: #fff;
      padding: 2px 6px;
      border-radius: 999px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .weekly-tasks-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }

    .weekly-tasks-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .weekly-task-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.97);
    }

    .weekly-task-item.done {
      opacity: 0.6;
    }

    .weekly-task-checkbox {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .weekly-task-title {
      flex: 1;
      font-size: 12px;
      color: var(--ink);
    }

    .weekly-task-item.done .weekly-task-title {
      text-decoration: line-through;
    }

    .add-weekly-task-form {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .add-weekly-task-form input {
      flex: 1;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.9);
      color: var(--ink);
      padding: 6px 8px;
    }

    .add-weekly-task-form button {
      border: none;
      background: var(--accent);
      color: #fff;
      border-radius: 4px;
      padding: 6px 12px;
      font-size: 11px;
      cursor: pointer;
    }

    /* Light mode for weekly tasks */
    body:not([data-theme="dark"]) .weekly-task-item {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .weekly-task-title {
      color: #0f172a;
    }

    body:not([data-theme="dark"]) .add-weekly-task-form input {
      background: #ffffff;
      border-color: #d1d5db;
      color: #0f172a;
    }

    /* ===== DRAGGABLE SECTIONS ===== */
    .draggable-section {
      cursor: default;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .draggable-section.dragging {
      opacity: 0.5;
      transform: scale(0.98);
    }

    .draggable-section.drop-target {
      outline: 2px dashed var(--accent);
      outline-offset: 4px;
    }

    .section-drag-handle {
      cursor: grab;
      padding: 4px 8px;
      margin-right: 8px;
      font-size: 12px;
      color: var(--ink-soft);
      opacity: 0.5;
    }

    .section-drag-handle:hover {
      opacity: 1;
      color: var(--accent);
    }

    .section-drag-handle:active {
      cursor: grabbing;
    }

    /* User chooser overlay */

    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(0, 0, 0, 0.94));
      z-index: 50;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay-panel {
      width: min(360px, 100% - 32px);
      background: rgba(15, 23, 42, 0.98);
      border-radius: 18px;
      padding: 18px 18px 16px;
      border: 1px solid rgba(148, 163, 184, 0.55);
      box-shadow: var(--shadow-xl);
      text-align: left;
    }

    .overlay-panel h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }

    .overlay-panel p {
      margin: 0 0 12px;
      font-size: 13px;
      color: var(--ink-soft);
    }

    .overlay-panel select {
      width: 100%;
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: var(--ink);
      padding: 6px 10px;
      margin-bottom: 10px;
      font-size: 13px;
    }

    .overlay-panel button {
      width: 100%;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #f9fafb;
      padding: 8px 10px;
      font-size: 13px;
      cursor: pointer;
    }

    .overlay-panel small {
      display: block;
      margin-top: 6px;
      font-size: 11px;
      color: var(--ink-soft);
      text-align: center;
    }

    /* Task modal */

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }

    .modal.hidden {
      display: none;
    }

    .modal-panel {
      width: min(420px, 100% - 32px);
      background: rgba(15, 23, 42, 0.98);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: var(--shadow-xl);
      padding: 14px 14px 12px;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
    }

    .modal-close {
      border: none;
      background: transparent;
      color: var(--ink-soft);
      font-size: 18px;
      cursor: pointer;
    }

    .modal-body label {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-bottom: 6px;
      font-size: 11px;
      color: var(--ink-soft);
    }

    .modal-body input,
    .modal-body select,
    .modal-body textarea {
      border-radius: 8px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: var(--ink);
      padding: 5px 7px;
      font-size: 12px;
    }

    .modal-body textarea {
      resize: vertical;
      min-height: 60px;
    }

    .modal-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 4px;
    }

    .button-secondary,
    .button-danger,
    .button-primary {
      border-radius: 999px;
      border: none;
      padding: 5px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .button-secondary {
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(75, 85, 99, 0.9);
      color: var(--ink-soft);
    }

    .button-danger {
      background: rgba(127, 29, 29, 0.9);
      color: #fee2e2;
    }

    .button-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #f9fafb;
    }

    .toast {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.98);
      color: var(--ink);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 11px;
      z-index: 60;
      display: none;
    }

    .toast.show {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .toast span {
      font-size: 12px;
    }

    /* TikTok-style action loader */

    .action-loader {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 80px;
      z-index: 80;
      pointer-events: none;
      opacity: 0;
      transform: translateY(16px);
      transition: opacity 0.18s ease-out, transform 0.18s ease-out;
    }

    .action-loader.show {
      opacity: 1;
      transform: translateY(0);
    }

    .action-loader-inner {
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 999px;
      background: radial-gradient(circle at top left,
          rgba(15, 23, 42, 0.98),
          rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.65);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(16px);
      font-size: 12px;
    }

    .loader-spinner {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid rgba(75, 85, 99, 0.8);
      border-top-color: var(--accent-soft);
      animation: spin 0.7s linear infinite;
    }

    .action-loader-text-main {
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .action-loader-text-sub {
      display: block;
      font-size: 11px;
      color: var(--ink-soft);
      margin-top: 1px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .theme-toggle {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--ink-soft);
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    .theme-toggle select {
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: var(--panel);
      color: var(--ink);
      padding: 3px 8px;
      font-size: 11px;
    }

    .goal-delete-btn {
      border: none;
      background: transparent;
      color: var(--accent-muted);
      font-size: 10px;
      cursor: pointer;
      padding: 0 2px;
      white-space: nowrap;
    }

    .goal-delete-btn:hover {
      color: var(--danger);
    }

    /* ================================
       Light Theme (Day) readability overrides
       ================================ */

    body:not([data-theme="dark"]) .panel-header {
      border-bottom: 1px solid #e5e7eb;
    }

    /* Calendar controls */
    body:not([data-theme="dark"]) .calendar-controls button,
    body:not([data-theme="dark"]) .calendar-controls select {
      background: #ffffff;
      color: #0f172a;
      border-color: #d1d5db;
    }

    body:not([data-theme="dark"]) .calendar-controls span.month-label {
      color: #0f172a;
    }

    /* Weekday row */
    body:not([data-theme="dark"]) .calendar-weekdays div {
      border-bottom: 1px solid #e5e7eb;
    }

    /* Calendar day cells + tasks */
    body:not([data-theme="dark"]) .day-cell {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .task-pill {
      background: #f9fafb;
      border-color: #e5e7eb;
    }

    /* Goals columns & cards */
    body:not([data-theme="dark"]) .goal-column {
      background: #ffffff;
      border-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .goal-card {
      background: #f9fafb;
      border-color: #e5e7eb;
    }

    /* Inputs in goals area */
    body:not([data-theme="dark"]) .goals-controls input[type="month"],
    body:not([data-theme="dark"]) .goals-controls select,
    body:not([data-theme="dark"]) .goals-controls input[type="number"],
    body:not([data-theme="dark"]) .goal-progress input[type="number"],
    body:not([data-theme="dark"]) .goal-row-note textarea,
    body:not([data-theme="dark"]) .goal-add-form input,
    body:not([data-theme="dark"]) .goal-add-form select {
      background: #ffffff;
      border-color: #d1d5db;
      color: #0f172a;
    }

    /* Overlay & modal surfaces */
    body:not([data-theme="dark"]) .overlay {
      background: rgba(15, 23, 42, 0.3);
    }

    body:not([data-theme="dark"]) .overlay-panel,
    body:not([data-theme="dark"]) .modal-panel {
      background: #ffffff;
      border-color: #e5e7eb;
      color: #0f172a;
    }

    body:not([data-theme="dark"]) .overlay-panel select,
    body:not([data-theme="dark"]) .modal-body input,
    body:not([data-theme="dark"]) .modal-body select,
    body:not([data-theme="dark"]) .modal-body textarea {
      background: #ffffff;
      border-color: #d1d5db;
      color: #0f172a;
    }

    body:not([data-theme="dark"]) .modal {
      background: rgba(15, 23, 42, 0.3);
    }

    /* Secondary buttons + toast */
    body:not([data-theme="dark"]) .button-secondary {
      background: #f9fafb;
      border-color: #d1d5db;
      color: #374151;
    }

    body:not([data-theme="dark"]) .toast {
      background: #111827;
      color: #f9fafb;
    }

    /* Goal subtasks - light mode */
    body:not([data-theme="dark"]) .goal-subtasks {
      border-top-color: #e5e7eb;
    }

    body:not([data-theme="dark"]) .goal-subtask-title {
      color: #0f172a;
    }

    body:not([data-theme="dark"]) .goal-subtask-calendar-btn {
      color: #6b7280;
    }

    body:not([data-theme="dark"]) .goal-subtask-calendar-btn:hover {
      color: #03aae1;
    }

    body:not([data-theme="dark"]) .goal-subtask-calendar-btn.linked {
      color: #16a34a;
    }

    body:not([data-theme="dark"]) .goal-subtasks-toggle {
      color: #6b7280;
    }

    body:not([data-theme="dark"]) .goal-subtasks-toggle:hover {
      color: #03aae1;
    }

    body:not([data-theme="dark"]) .add-subtask-form input {
      background: #ffffff;
      border-color: #d1d5db;
      color: #0f172a;
    }

    body:not([data-theme="dark"]) .add-subtask-form button {
      background: #e5e7eb;
      color: #374151;
    }

    body:not([data-theme="dark"]) .add-subtask-form button:hover {
      background: #03aae1;
      color: #ffffff;
    }

    body:not([data-theme="dark"]) .goal-column-title-input {
      color: #6b7280;
    }

    /* Drag & drop feedback */
    .task-pill.dragging {
      opacity: 0.45;
    }

    .day-cell.drop-target {
      outline: 2px dashed var(--accent-soft);
      outline-offset: 2px;
    }

    #task-repeat-count-wrapper {
      transition: opacity 0.12s ease-out;
    }

    .modal-repeat-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .modal-repeat-row label {
      flex: 1 1 150px;
    }

    .modal-help-text,
    .field-hint {
      font-size: 10px;
      color: var(--ink-soft);
      margin-top: 2px;
    }

    .task-pill.completed .task-title {
      text-decoration: line-through;
      opacity: 0.7;
    }

    /* ===== Core Pillars (Elevate / Engage / Evolve / Excite) ===== */
    .draggable-section {
      margin-bottom: 15px;
    }

    .pillars-section {
      margin-top: 14px;
      padding-top: 10px;
      border-top: 1px dashed rgba(55, 65, 81, 0.45);
    }

    .pillars-header {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 12px;
      padding: 6px 2px 10px;
    }

    .pillars-kicker {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .pillars-sub {
      margin-top: 3px;
      font-size: 11px;
      color: var(--ink-soft);
    }

    .pillar-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 12px;
    }

    @media (max-width: 1100px) {
      .pillar-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 640px) {
      .pillar-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .pillar-card {
      background: var(--panel);
      border-radius: var(--radius-md);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow-md);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 400px;
    }

    .pillar-card-header {
      padding: 1.25rem;
      border-bottom: 1px solid var(--panel-border);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Top Borders matching BoardIdeas */
    .pillar-card.elevate {
      border-top: 4px solid var(--elevate);
    }

    .pillar-card.engage {
      border-top: 4px solid var(--engage);
    }

    .pillar-card.evolve {
      border-top: 4px solid var(--evolve);
    }

    .pillar-card.excite {
      border-top: 4px solid var(--excite);
    }

    .pillar-card.elevate .pillar-name {
      color: var(--elevate);
    }

    .pillar-card.engage .pillar-name {
      color: var(--engage);
    }

    .pillar-card.evolve .pillar-name {
      color: var(--evolve);
    }

    .pillar-card.excite .pillar-name {
      color: var(--excite);
    }

    .pillar-name {
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0.05em;
    }

    .pillar-add {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
      color: var(--ink);
    }

    .pillar-add:hover {
      opacity: 1;
    }

    .pillar-box {
      flex: 1;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      background: transparent;
      /* Removed the yellow block */
    }

    .pillar-task-row {
      background: rgba(2, 6, 23, 0.22);
      border: 1px solid rgba(15, 23, 42, 0.18);
      border-radius: 10px;
      padding: 8px 8px;
      cursor: pointer;
    }

    body[data-theme="dark"] .pillar-task-row {
      background: rgba(2, 6, 23, 0.28);
      border-color: rgba(2, 6, 23, 0.35);
    }

    .pillar-task-title {
      font-size: 12px;
      font-weight: 700;
      color: #0f172a;
      line-height: 1.2;
    }

    .pillar-task-meta {
      margin-top: 4px;
      font-size: 11px;
      color: rgba(15, 23, 42, 0.85);
      line-height: 1.25;
    }

    .pillar-empty {
      margin: auto 0;
      font-size: 12px;
      color: rgba(15, 23, 42, 0.8);
      text-align: center;
      padding: 10px 6px;
    }

    .pillar-circle-wrap {
      margin-top: auto;
      padding: 4px 12px 14px;
      display: flex;
      justify-content: center;
    }

    .pillar-circle {
      width: 150px;
      height: 150px;
      border-radius: 999px;
      background: var(--accent-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      color: #0f172a;
      border: 1px solid rgba(15, 23, 42, 0.18);
    }

    .pillar-circle strong {
      display: block;
      font-size: 28px;
      line-height: 1;
      margin-bottom: 6px;
    }

    .pillar-circle span {
      display: block;
      font-size: 12px;
      line-height: 1.2;
    }

    .pillar-task-row {
      background: rgba(255, 255, 255, 0.5);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .pillar-task-row:hover {
      background: rgba(255, 255, 255, 0.8);
    }

    .pillar-task-row.promo {
      background: #f0f9ff;
      border-left: 3px solid var(--accent);
    }

    .pillar-task-row.promo:hover {
      background: #e0f2fe;
    }
  </style>
  <!-- Fireworks Library -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <style>
    /* Gamification Overlay */
    .celebration-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      background: rgba(255, 255, 255, 0.95);
      padding: 24px 48px;
      border-radius: 24px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      text-align: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .celebration-overlay.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .celebration-emoji {
      font-size: 48px;
      margin-bottom: 12px;
      display: block;
      animation: bounce 1s infinite;
    }

    .celebration-text {
      font-size: 28px;
      font-weight: 800;
      background: linear-gradient(135deg, #03aae1 0%, #a855f7 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 4px;
      letter-spacing: -0.02em;
    }

    .celebration-sub {
      font-size: 15px;
      font-weight: 500;
      color: var(--ink-soft);
    }

    body[data-theme="dark"] .celebration-overlay {
      background: rgba(15, 23, 42, 0.95);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-10px);
      }
    }

    /* ===== COIN REWARD SYSTEM ===== */
    .coin-counter-wrap {
      display: none;
      /* Hidden by default */
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .coin-counter-wrap.visible {
      display: flex;
    }

    .coin-counter {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      border: 2px solid #d97706;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      font-size: 14px;
      font-weight: 700;
      color: #78350f;
      cursor: default;
      user-select: none;
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .coin-caps {
      display: flex;
      gap: 8px;
      font-size: 10px;
      color: var(--ink-soft);
      opacity: 0.8;
    }

    .coin-caps span {
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
    }

    body[data-theme="dark"] .coin-caps span {
      background: rgba(255, 255, 255, 0.1);
    }

    .coin-counter:hover {
      transform: scale(1.05);
    }

    .coin-counter:hover {
      transform: scale(1.05);
    }

    .coin-counter.pulse {
      animation: coinPulse 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .coin-icon {
      font-size: 18px;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
    }

    .coin-amount {
      min-width: 24px;
      text-align: center;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    @keyframes coinPulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.15);
      }

      100% {
        transform: scale(1);
      }
    }

    /* Shake animation for coin deduction */
    .coin-counter.shake {
      animation: coinShake 0.4s ease-in-out;
    }

    @keyframes coinShake {

      0%,
      100% {
        transform: translateX(0);
      }

      20% {
        transform: translateX(-5px);
      }

      40% {
        transform: translateX(5px);
      }

      60% {
        transform: translateX(-3px);
      }

      80% {
        transform: translateX(3px);
      }
    }

    /* --- BIRD SYSTEM CSS --- */
    .bird-system-container {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      padding: 0 5px 5px;
      gap: 15px;
      height: 160px;
      /* Force height to accommodate bird and pie */
    }

    .bird-wrapper {
      position: relative;
      width: 110px;
      height: 120px;
      cursor: grab;
      flex-shrink: 0;
      /* background: rgba(0,0,0,0.02); Debug area */
      border-radius: 50%;
    }

    .bird-wrapper:active {
      cursor: grabbing;
    }

    /* Hearts for petting */
    .pet-heart {
      position: absolute;
      font-size: 20px;
      color: #ec4899;
      /* Excite pink */
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
      opacity: 0;
      z-index: 10;
    }

    @keyframes floatUp {
      0% {
        transform: translateY(0) scale(0.5);
        opacity: 1;
      }

      @keyframes floatUp {
        0% {
          transform: translateY(0) scale(0.5);
          opacity: 1;
        }

        100% {
          transform: translateY(-40px) scale(1.2);
          opacity: 0;
        }
      }

      /* Edit Bird Button */
      .edit-bird-btn {
        position: absolute;
        bottom: -15px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--panel-elevated);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s, transform 0.2s;
        box-shadow: var(--shadow-md);
        z-index: 20;
      }

      .bird-wrapper:hover .edit-bird-btn {
        opacity: 1;
        bottom: -5px;
      }

      .edit-bird-btn:hover {
        transform: translateX(-50%) scale(1.1);
        background: var(--bg-main);
      }

      /* Bird Editor Modal */
      .bird-editor-layout {
        display: flex;
        gap: 20px;
        padding: 10px;
      }

      .bird-preview-col {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: var(--bg-main);
        border-radius: var(--radius-md);
        padding: 20px;
      }

      .bird-controls-col {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 12px;
        max-height: 400px;
        overflow-y: auto;
      }

      .color-control-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .color-control-group label {
        font-size: 11px;
        font-weight: 600;
        color: var(--ink-soft);
        text-transform: uppercase;
      }

      .color-picker-row {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .color-input-styled {
        -webkit-appearance: none;
        border: none;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        overflow: hidden;
        cursor: pointer;
        padding: 0;
        background: none;
      }

      .color-input-styled::-webkit-color-swatch-wrapper {
        padding: 0;
      }

      .color-input-styled::-webkit-color-swatch {
        border: 2px solid var(--panel-border);
        border-radius: 50%;
      }

      /* Daily Energy Meter */
      /* Daily Energy Meter - Horizontal */
      .coin-meter-container {
        flex: 1;
        margin: 0 15px 25px;
        /* Align with bird feet */
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
      }

      .coin-meter {
        width: 100%;
        height: 24px;
        background: rgba(0, 0, 0, 0.06);
        border-radius: 12px;
        position: relative;
        overflow: hidden;
      }

      body[data-theme="dark"] .coin-meter {
        background: rgba(255, 255, 255, 0.1);
      }

      .coin-meter-fill {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0%;
        /* Horizontal fill */
        background: linear-gradient(to right, #fbbf24, #f59e0b);
        border-radius: 12px;
        transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
      }

      .coin-meter-label {
        text-align: center;
        font-size: 11px;
        font-weight: 600;
        color: var(--ink-soft);
        margin-top: 4px;
      }

      /* Flying coin sprites - use JS animation instead of CSS */
      .flying-coin {
        position: fixed;
        font-size: 28px;
        z-index: 10001;
        pointer-events: none;
        filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.4));
        transition: none;
      }

      @keyframes coinFly {
        0% {
          transform: translate(0, 0) scale(1) rotate(0deg);
          opacity: 1;
        }

        30% {
          transform: translate(calc(var(--dx) * 0.3), calc(var(--dy) * 0.3 - 40px)) scale(1.2) rotate(180deg);
          opacity: 1;
        }

        100% {
          transform: translate(var(--dx), var(--dy)) scale(0.5) rotate(720deg);
          opacity: 0.8;
        }
      }

      @keyframes coinBurst {
        0% {
          transform: scale(0) rotate(0deg);
          opacity: 0;
        }

        50% {
          transform: scale(1.3) rotate(180deg);
          opacity: 1;
        }

        100% {
          transform: scale(1) rotate(360deg);
          opacity: 1;
        }
      }

      .coin-burst {
        animation: coinBurst 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      /* Task Reminder Container - fixed position, stacks children vertically */
      .reminder-container {
        position: fixed;
        top: 80px;
        right: 16px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 360px;
      }

      /* Individual reminder banner */
      .reminder-banner {
        background: linear-gradient(135deg, #fef3c7, #fde68a);
        border: 2px solid #f59e0b;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(245, 158, 11, 0.3);
        animation: slideInRight 0.3s ease-out;
      }

      /* Overdue reminder style */
      .reminder-banner.overdue {
        background: linear-gradient(135deg, #fee2e2, #fecaca);
        border: 2px solid #ef4444;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(239, 68, 68, 0.3);
      }

      .reminder-banner.hidden {
        display: none;
      }

      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }

        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .reminder-content {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
      }

      .reminder-icon {
        font-size: 28px;
        animation: shake 0.5s ease-in-out infinite;
      }

      @keyframes shake {

        0%,
        100% {
          transform: rotate(0deg);
        }

        25% {
          transform: rotate(-10deg);
        }

        75% {
          transform: rotate(10deg);
        }
      }

      .reminder-text {
        flex: 1;
      }

      .reminder-title {
        font-weight: 700;
        font-size: 14px;
        color: #92400e;
        margin-bottom: 2px;
      }

      .reminder-time {
        font-size: 12px;
        color: #b45309;
      }

      .reminder-buttons {
        display: flex;
        gap: 6px;
      }

      .reminder-snooze {
        background: rgba(146, 64, 14, 0.2);
        color: #92400e;
        border: 1px solid #92400e;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .reminder-snooze:hover {
        background: rgba(146, 64, 14, 0.3);
      }

      .reminder-dismiss {
        background: #f59e0b;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .reminder-dismiss:hover {
        background: #d97706;
      }

      /* Checkbox list for assignees */
      .checkbox-list {
        border: 1px solid #d1d5db;
        border-radius: 6px;
        padding: 8px;
        max-height: 120px;
        overflow-y: auto;
        background: #fff;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .checkbox-list label {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        cursor: pointer;
        margin: 0;
        font-weight: normal;
        white-space: nowrap;
      }

      .checkbox-list label input[type="checkbox"] {
        margin: 0;
        flex-shrink: 0;
      }


      /* Bird System Layout */
      .bird-system-container {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-start;
        justify-content: center;
        gap: 20px;
        padding: 15px;
        background: var(--panel);
        border-radius: 8px;
        margin: 10px;
      }

      .bird-wrapper {
        position: relative;
        width: 100px;
        height: 100px;
        flex-shrink: 0;
      }

      #finch-svg {
        width: 100%;
        height: 100%;
      }

      /* Coin Meter (Horizontal) */
      .coin-meter-container {
        width: 200px;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }

      .coin-meter {
        width: 100%;
        height: 12px !important;
        min-height: 12px !important;
        background: rgba(0, 0, 0, 0.1) !important;
        border-radius: 999px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .coin-meter-fill {
        height: 100%;
        width: 0%;
        background: #eab308;
        /* Fallback */
        background: linear-gradient(90deg, #facc15, #eab308);
        border-radius: 999px;
        transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        min-width: 4px;
        /* Ensure visibility even at near-0 */
      }

      .coin-meter-label {
        font-size: 11px;
        color: var(--ink-soft);
        font-weight: 600;
        font-variant-numeric: tabular-nums;
      }

      /* Coin Sprite Animation - FIXED OVERRIDE */
      .flying-coin {
        position: fixed !important;
        width: 32px !important;
        height: 32px !important;
        pointer-events: none;
        z-index: 2147483647 !important;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        will-change: transform, left, top;
        left: 0;
        top: 0;
      }

      /* Bird Speech Bubble */
      .speech-bubble {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        border: 2px solid var(--ink-soft);
        color: var(--ink);
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 600;
        white-space: nowrap;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s, transform 0.3s;
        margin-bottom: 25px;
        /* Space above bird */
      }

      .speech-bubble.visible {
        opacity: 1;
        transform: translateX(-50%) translateY(-5px);
      }

      .speech-bubble::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -6px;
        border-width: 6px;
        border-style: solid;
        border-color: var(--ink-soft) transparent transparent transparent;
      }

      /* Mute Button */
      .bird-mute-btn {
        position: absolute;
        bottom: 5px;
        right: 5px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid rgba(0, 0, 0, 0.1);
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0.5;
        transition: opacity 0.2s, transform 0.1s;
        z-index: 10;
        padding: 0;
      }

      .bird-mute-btn:hover {
        opacity: 1;
        background: #fff;
      }

      .bird-mute-btn.muted {
        opacity: 0.8;
        background: #fee2e2;
        color: #ef4444;
        border-color: #fca5a5;
      }
  </style>
</head>

<body>
  <!-- User chooser -->
  <div id="user-overlay" class="overlay">
    <div class="overlay-panel">
      <h2>Who’s on the Wrap?</h2>
      <p>Select your name so we know who’s assigning and completing tasks.</p>
      <select id="user-select">
        <option value="">Loading team...</option>
      </select>
      <button id="user-select-confirm">Open Wrap Sheet</button>
      <small>This is internal for BER: Meighan, Kevin, Erica, Jenna &amp; Katie.</small>
    </div>
  </div>

  <!-- Bird Editor Modal -->
  <div class="overlay" id="bird-editor-modal" style="display:none;">
    <div class="modal-panel" style="width: 600px; max-width: 90vw;">
      <div class="modal-header">
        <div class="modal-title">Customize Your Bird</div>
        <button class="modal-close" id="close-bird-editor">×</button>
      </div>
      <div class="bird-editor-layout">
        <!-- Left: Preview -->
        <div class="bird-preview-col">
          <div style="width:180px; height:180px;">
            <svg id="bird-editor-preview" viewBox="0 0 200 200" style="width:100%; height:100%; overflow:visible;">
              <!-- JS will copy bird SVG here -->
            </svg>
          </div>
          <div style="margin-top:10px; font-size:11px; color:var(--ink-soft); text-align:center;">
            Preview
          </div>
        </div>

        <!-- Right: Controls -->
        <div class="bird-controls-col">
          <label class="bird-name-label">
            Name Your Bird
            <input type="text" id="bird-name-input" placeholder="e.g. Chirpy" maxlength="15"
              style="width:100%; padding:8px; border:1px solid #d1d5db; border-radius:6px; font-size:14px; margin-bottom:15px; text-transform:capitalize;">
          </label>
          <div id="bird-color-controls">
            <!-- JS will inject color pickers here -->
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button-secondary" id="cancel-bird-editor">Cancel</button>
        <button class="button-primary" id="save-bird-editor">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Task modal -->
  <div id="task-modal" class="modal hidden">
    <div class="modal-panel">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="task-modal-title">New Task</div>
          <div id="task-modal-date" style="font-size:11px;color:#9ca3af;"></div>
        </div>
        <button class="modal-close" id="task-modal-close">&times;</button>
      </div>

      <div class="modal-body">
        <input type="hidden" id="task-id" />

        <label>
          Title
          <input id="task-title-input" placeholder="e.g., TTT: Market Reports video" />
        </label>

        <label>
          Notes
          <textarea id="task-notes-input" placeholder="Optional details…"></textarea>
        </label>

        <label>
          Scheduled Time <span style="font-weight:normal;color:#9ca3af;">(optional)</span>
          <input id="task-time-input" type="time" style="width:150px;" />
          <div class="field-hint">Set a time to get a reminder 30 minutes before.</div>
        </label>

        <!-- Repeat controls – simplified -->
        <label>
          Repeat
          <select id="task-repeat-type">
            <option value="none">Do not repeat</option>
            <option value="daily">Daily (Mon–Fri)</option>
            <option value="weekly">Weekly (same weekday)</option>
            <option value="monthly_date">Monthly – same date (1st, 14th…)</option>
            <option value="monthly_weekday">Monthly – same weekday pattern (1st Monday)</option>
          </select>
        </label>

        <div class="modal-repeat-row">
          <label>
            Series start
            <input id="task-repeat-start" type="date" />
          </label>
          <label>
            Series end
            <input id="task-repeat-end" type="date" />
          </label>
        </div>

        <div class="modal-help-text">
          For monthly repeats, create the first task on the date you want
          (e.g. the 1st or the 1st Monday), then set an end date for the series.
          If the monthly date lands on a weekend, it will shift to a nearby weekday.
        </div>

        <label>
          Assigned To
          <select id="task-assigned-to"></select>
        </label>

        <label>
          Additional Assignees
          <div id="task-assignees-container" class="checkbox-list"></div>
          <div class="field-hint">
            Check multiple people to share this task.
          </div>
        </label>

        <label>
          Status
          <select id="task-status-input">
            <option value="pending">Pending</option>
            <option value="in_progress">In Progress</option>
            <option value="done">Done</option>
            <option value="could_not_complete">Could not complete</option>
          </select>
        </label>
      </div>

      <div class="modal-footer">
        <button class="button-secondary" id="task-modal-cancel">Cancel</button>
        <div style="display:flex;gap:6px;align-items:center;">
          <button class="button-danger" id="task-delete-btn" style="display:none;">Delete</button>
          <button class="button-primary" id="task-save-btn">Save Task</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Project Step Edit Modal -->
  <div id="project-step-modal" class="modal hidden">
    <div class="modal-panel">
      <div class="modal-header">
        <div class="modal-title">Edit Project Step</div>
        <button class="modal-close" id="project-step-modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <input type="hidden" id="edit-project-step-id">
        <label>
          Title
          <input id="edit-project-step-title-input" placeholder="Step title..." />
        </label>
        <label>
          Assign To
          <div id="edit-project-step-assignees-container" class="checkbox-list"></div>
          <div class="field-hint">Select all people responsible for this step.</div>
        </label>
      </div>
      <div class="modal-footer">
        <button class="button-secondary" id="project-step-modal-cancel">Cancel</button>
        <button class="button-primary" id="project-step-save-btn">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Task Reminder Container (holds multiple stacked reminders) -->
  <div id="reminder-container" class="reminder-container"></div>

  <div class="toast" id="toast"></div>

  <!-- TikTok-style action loader -->
  <div id="action-loader" class="action-loader">
    <div class="action-loader-inner">
      <div class="loader-spinner"></div>
      <div>
        <div class="action-loader-text-main" id="action-loader-main">Syncing…</div>
        <div class="action-loader-text-sub" id="action-loader-sub">
          Saving your change to the Wrap Sheet
        </div>
      </div>
    </div>
  </div>

  <div class="app-shell">
    <header class="app-header">
      <div class="branding">
        <div class="branding-mark">W</div>
        <div class="branding-text">
          <h1>Wrap Sheet</h1>
          <span>BER • DAILY TASKS • GOALS</span>
        </div>
      </div>

      <div class="header-controls">
        <div id="sync-indicator" style="font-size:11px;color:var(--ink-soft);display:flex;align-items:center;gap:4px;">
          <span style="font-size:12px;">🔄</span>
          <span id="last-sync-time">—</span>
        </div>

        <div class="theme-toggle">
          <label for="theme-select">Theme</label>
          <select id="theme-select">
            <option value="light">Day</option>
            <option value="dark">Night</option>
          </select>
        </div>

        <!-- Coin Counter (for Kevin) -->
        <div class="coin-counter-wrap" id="coin-counter-wrap">
          <div class="coin-counter" id="coin-counter" title="Your coin balance">
            <span class="coin-icon">🪙</span>
            <span class="coin-amount" id="coin-amount">0</span>
          </div>
          <div class="coin-caps" id="coin-caps">
            <span id="coin-day-progress">0/50 today</span>
            <span id="coin-week-progress">0/250 week</span>
          </div>
        </div>

        <div class="user-pill">
          <span id="current-user-label">Not signed in</span>
          <button id="switch-user-btn">Switch</button>
        </div>
      </div>
    </header>

    <main class="app-main">
      <!-- Customization Instructions -->
      <div id="customize-instructions"
        style="background:linear-gradient(90deg,rgba(3,170,225,0.1),transparent);border-radius:8px;padding:8px 12px;margin-bottom:12px;display:flex;align-items:center;gap:10px;font-size:11px;color:var(--ink-soft);">
        <span style="font-size:16px;">⚙️</span>
        <span><strong>Customize your layout:</strong> Drag sections by their handle (⋮⋮) to reorder. Your arrangement is
          saved automatically.</span>
        <button id="hide-instructions-btn"
          style="margin-left:auto;background:none;border:none;color:var(--ink-soft);cursor:pointer;font-size:14px;">×</button>
      </div>

      <!-- Draggable Sections Container -->
      <div id="sections-container">
        <!-- Calendar (Daily Tasks) -->
        <section class="panel draggable-section" id="section-daily-tasks" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">⋮⋮</span>
            <div class="panel-title">Daily Tasks</div>
            <div class="calendar-controls">
              <button id="month-prev">&larr;</button>
              <span class="month-label" id="month-label">Month YYYY</span>
              <button id="month-next">&rarr;</button>

              <select id="calendar-view-select">
                <option value="month">Month</option>
                <option value="week">Full Week</option>
                <option value="workweek">Work Week</option>
                <option value="jointweek">Joint Weekly</option>
              </select>

              <select id="calendar-owner-select">
                <option value="">My Tasks</option>
              </select>

              <div class="calendar-legend">
                <span><span class="legend-dot legend-pending"></span>Pending</span>
                <span><span class="legend-dot legend-inprogress"></span>In Progress</span>
                <span><span class="legend-dot legend-done"></span>Done</span>
                <span><span class="legend-dot legend-blocked"></span>Could Not Complete</span>
              </div>



            </div>
          </div>
          <div class="calendar-grid">
            <div class="calendar-weekdays" id="calendar-weekdays"></div>
            <div class="calendar-days" id="calendar-days"></div>
          </div>
          <div class="calendar-metrics bird-system-container"
            style="display:flex; flex-direction:column; padding:15px 15px 20px 15px; margin:10px 10px 15px 10px; background:var(--panel); border-radius:8px; height:auto !important;">
            <!-- Top Row: Bird and Pie -->
            <div
              style="display:flex; justify-content:space-between; align-items:flex-start; width:100%; margin-bottom:15px;">
              <!-- Bird Container -->
              <div id="finch-container" class="bird-wrapper" title="Pet me!"
                style="position:relative; width:100px; height:100px; flex-shrink:0;">
                <!-- Speech Bubble -->
                <div id="bird-speech-bubble" class="speech-bubble hidden"></div>

                <!-- Mute Button -->
                <button id="bird-mute-btn" class="bird-mute-btn" title="Toggle Squeaks">🔊</button>

                <!-- Bird Name Display -->
                <div id="bird-name-display"
                  style="position:absolute; top:-20px; width:100%; text-align:center; font-size:12px; font-weight:700; color:var(--ink-soft); text-shadow:0 1px 2px rgba(255,255,255,0.8);">
                </div>

                <svg id="finch-svg" viewBox="0 0 200 200" style="width:100%; height:100%; overflow:visible;">
                  <!-- Bird Logic will inject SVG here -->
                </svg>
                <div id="finch-hearts"
                  style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>

                <!-- Edit Button -->
                <button class="edit-bird-btn" id="edit-bird-trigger" title="Edit Colors">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                  </svg>
                </button>
              </div>

              <!-- Existing Pie -->
              <canvas id="status-pie" width="150" height="150"></canvas>
            </div>

            <!-- Bottom Row: Full Width Coin Energy Bar -->
            <div class="coin-meter-container"
              style="width:100%; display:flex; flex-direction:column; align-items:center; gap:4px;">
              <div class="coin-meter" title="Daily Energy: 50 Coins"
                style="width:100%; height:20px; min-height:20px; background:#e5e7eb; border-radius:999px; overflow:hidden; position:relative; display:block; box-sizing:border-box; box-shadow:inset 0 1px 3px rgba(0,0,0,0.2);">
                <div class="coin-meter-fill" id="bird-energy-fill"
                  style="width: 0%; height:20px; min-height:20px; background:linear-gradient(90deg, #facc15, #eab308); border-radius:999px; display:block;">
                </div>
              </div>
              <div class="coin-meter-label" id="bird-energy-text" style="font-size:11px; font-weight:600;">0/50</div>
            </div>
          </div>
        </section>

        <!-- Task Backlog Section -->
        <section class="panel draggable-section" id="section-backlog" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">⋮⋮</span>
            <div class="panel-title">Task Backlog</div>
            <div class="header-hint" style="font-size:11px;color:var(--ink-soft);margin-left:auto;">
              Drag here to park tasks · Drag to calendar to schedule
            </div>
          </div>
          <div class="backlog-container" id="backlog-container"
            style="padding:10px;min-height:80px;background:rgba(0,0,0,0.03);border-radius:6px;margin:10px;">
            <div id="backlog-list" style="display:grid;grid-template-columns:repeat(3, 1fr);gap:8px;"></div>
            <div id="backlog-empty"
              style="font-size:11px;color:var(--ink-soft);text-align:center;padding:10px;width:100%;grid-column:1/-1;display:none;">
              No parked tasks.
            </div>
          </div>
          <div class="add-backlog-form" style="padding:0 10px 10px;display:flex;gap:6px;">
            <input type="text" id="new-backlog-input" placeholder="Add to backlog..."
              style="flex:1;font-size:11px;padding:5px;border-radius:4px;border:1px solid var(--panel-border);background:var(--panel);">
            <button id="add-backlog-btn"
              style="border:none;background:var(--accent);color:#fff;border-radius:4px;padding:5px 10px;font-size:11px;cursor:pointer;">Add</button>
          </div>
        </section>

        <!-- Goals Section -->
        <section class="panel draggable-section" id="section-goals" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">⋮⋮</span>
            <div class="panel-title">Goals & Focus</div>
            <div class="goals-tabs">
              <button class="goals-tab active" data-tab="monthly">Monthly Strategies</button>
              <button class="goals-tab" data-tab="annual">Annual Goals</button>
            </div>
          </div>

          <!-- Monthly Goals -->
          <div id="monthly-goals-panel">
            <div class="goals-controls">
              <label>
                Month
                <input type="month" id="monthly-month-input" />
              </label>
              <label>
                Owner
                <select id="monthly-owner-filter">
                  <option value="all">Everyone</option>
                </select>
              </label>
            </div>
            <div class="goals-grid" id="monthly-goals-grid"></div>
          </div>

          <!-- Annual Goals -->
          <div id="annual-goals-panel" style="display:none;">
            <div class="goals-controls">
              <label>
                Year
                <select id="annual-year-input"></select>
              </label>
              <label>
                Owner
                <select id="annual-owner-filter">
                  <option value="all">Everyone</option>
                </select>
              </label>
            </div>
            <div class="goals-grid" id="annual-goals-grid"></div>
          </div>

        </section>

        <!-- Joint Projects Section -->
        <section class="panel draggable-section" id="section-projects" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">⋮⋮</span>
            <div class="panel-title">Joint Projects</div>
            <button class="add-project-btn" id="add-project-btn">+ New Project</button>
          </div>
          <div class="projects-grid" id="projects-grid"></div>
        </section>

        <!-- Weekly Tasks (BETA - Jenna only) -->
        <section class="panel draggable-section" id="section-weekly-tasks" draggable="true" style="display: none;">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">⋮⋮</span>
            <div class="panel-title">
              Weekly Tasks <span class="beta-badge">BETA</span>
            </div>
            <div class="weekly-tasks-controls">
              <button id="week-prev"
                style="background:none;border:none;font-size:14px;cursor:pointer;color:var(--ink);">←</button>
              <span id="week-label" style="font-size:11px;color:var(--ink-soft);min-width:80px;text-align:center;">Week
                52</span>
              <button id="week-next"
                style="background:none;border:none;font-size:14px;cursor:pointer;color:var(--ink);">→</button>
            </div>
          </div>
          <div class="weekly-tasks-list" id="weekly-tasks-list"></div>
          <div class="add-weekly-task-form">
            <input type="text" id="new-weekly-task-input" placeholder="Add weekly task...">
            <button id="add-weekly-task-btn">Add</button>
          </div>
        </section>

        <!-- Core Pillars (per-user) -->
        <section class="panel draggable-section" id="section-pillars" draggable="true">
          <div class="panel-header">
            <span class="section-drag-handle" title="Drag to reorder">⋮⋮</span>
            <div class="panel-title">Core Pillars</div>
            <div class="pillars-sub" id="pillars-subtitle"
              style="margin-left:auto;font-size:11px;color:var(--ink-soft);">Personal to you</div>
          </div>
          <!-- Subheader removed in favor of panel-header layout -->

          <div class="pillar-grid" id="pillar-grid"></div>
        </section>
      </div> <!-- End sections-container -->

      <!-- Pillar Task Modal -->
      <div id="pillar-modal" class="modal hidden">
        <div class="modal-panel">
          <div class="modal-header">
            <div>
              <div class="modal-title" id="pillar-modal-title">New Pillar Task</div>
              <div id="pillar-modal-meta" style="font-size:11px;color:#9ca3af;"></div>
            </div>
            <button class="modal-close" id="pillar-modal-close">&times;</button>
          </div>

          <div class="modal-body">
            <input type="hidden" id="pillar-task-id" />
            <input type="hidden" id="pillar-key" />

            <label>
              Task Title
              <input id="pillar-task-title" placeholder="e.g., Launch new onboarding email" />
            </label>

            <label>
              Assigned to who?
              <select id="pillar-task-assigned-to"></select>
            </label>

            <label>
              What is the benchmark?
              <input id="pillar-task-benchmark" placeholder="e.g., Draft approved by Friday" />
            </label>

            <div class="modal-repeat-row">
              <label>
                Percentage Complete
                <input id="pillar-task-percent" type="number" min="0" max="100" placeholder="0–100" />
                <div class="field-hint">This drives the circle % for the pillar.</div>
              </label>

              <label>
                Estimated date of completion
                <input id="pillar-task-eta" type="date" />
              </label>
            </div>

            <label>
              Staff Update / Notes
              <textarea id="pillar-task-notes" rows="2" placeholder="Share a progress update..."></textarea>
            </label>
          </div>

          <div class="modal-footer">
            <button class="button-secondary" id="pillar-modal-cancel">Cancel</button>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="button-danger" id="pillar-task-delete" style="display:none;">Delete</button>
              <button class="button-primary" id="pillar-task-save">Save</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Suggestion Modal (Board Ideas) -->
      <div id="suggestion-modal" class="modal hidden">
        <div class="modal-panel">
          <div class="modal-header">
            <div>
              <div class="modal-title">Update Board Idea</div>
              <div id="suggestion-modal-title"
                style="font-size:12px;color:var(--ink-soft);max-width:300px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
              </div>
            </div>
            <button class="modal-close" id="suggestion-modal-close">&times;</button>
          </div>

          <div class="modal-body">
            <input type="hidden" id="suggestion-id" />

            <label>
              Progress Percentage
              <div style="display:flex;align-items:center;gap:10px;">
                <input type="range" id="suggestion-percent" min="0" max="100" step="5" style="flex:1"
                  oninput="document.getElementById('suggestion-percent-val').textContent = this.value + '%'">
                <span id="suggestion-percent-val"
                  style="font-weight:600;width:40px;text-align:right;font-size:12px;">0%</span>
              </div>
            </label>

            <label>
              Progress Notes (Visible to Board)
              <textarea id="suggestion-notes" placeholder="Update the board on status..."></textarea>
            </label>

            <label>
              Status
              <select id="suggestion-status">
                <option value="suggested">Suggested (Pending)</option>
                <option value="active">Active (In Progress)</option>
                <option value="completed">Completed</option>
              </select>
            </label>

            <label>
              Estimated Completion
              <input type="date" id="suggestion-eta" />
            </label>
          </div>

          <div class="modal-footer">
            <button class="button-secondary" id="suggestion-modal-cancel">Cancel</button>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="button-primary" id="suggestion-save-btn">Update Idea</button>
            </div>
          </div>
        </div>
      </div>




    </main>

    <!-- Gamification Overlay -->
    <div id="celebration-overlay" class="celebration-overlay">
      <span class="celebration-emoji" id="celebration-emoji">🎉</span>
      <div class="celebration-text" id="celebration-text">Good work!</div>
      <div class="celebration-sub" id="celebration-sub">Task Completed</div>
    </div>
  </div>

  <script>
    // ===== CONFIG =====
    const API_BASE = "https://wrapsheet.bonitaspringsrealtors.workers.dev/api";

    const MONTHLY_CATEGORIES = [
      "Compliance/Audit",
      "Marketing",
      "Products & Tools",
      "Personal Focus",
      "Moving the Needle",
      "Team Work"
    ];

    const ANNUAL_CATEGORIES = [
      "Compliance/Audit",
      "Marketing",
      "Products & Tools",
      "Personal Focus",
      "Moving the Needle",
      "Team Work"
    ];

    const BACKLOG_DATE = "1900-01-01";

    const state = {
      users: [],
      currentUser: null,
      promotedSuggestions: [],
      currentMonthDate: new Date(),
      dailyTasks: [],
      backlogTasks: [], // NEW
      monthlyGoals: [],
      annualGoals: [],
      monthlyOwnerFilter: "all",
      annualOwnerFilter: "all",
      annualYear: new Date().getFullYear(),
      calendarView: "month",
      calendarOwnerId: null,
      theme: "light",
      pillars: {
        elevate: [],
        engage: [],
        evolve: [],
        excite: []
      },
      projects: [],               // Joint projects list
      weeklyTasks: [],           // Weekly tasks for current week
      currentWeekKey: null,      // '2025-W52' format
      userDbPrefs: null,         // User preferences from D1
      coinBalance: 0,            // Coin reward balance (Finch-style)
      activeUserId: null,     // who we are currently "working on" (driven by calendar owner select)
      activeUser: null,
      userPrefs: null,        // prefs for activeUserId (titles, category labels, etc.)
      monthlyCategoryDefs: null, // [{key,label}]
      annualCategoryDefs: null,
    };


    const DEFAULT_MONTHLY_KEYS = [
      "Compliance/Audit", "Marketing", "Products & Tools", "Personal Focus", "Moving the Needle", "Team Work"
    ];
    const DEFAULT_ANNUAL_KEYS = [...DEFAULT_MONTHLY_KEYS];

    function defaultCategoryDefs(keys) {
      return keys.map(k => ({ key: k, label: k }));
    }

    // Get custom category name from user preferences (or return original)
    function getCustomCategoryName(goalType, originalCategory) {
      if (!state.userPrefs) return originalCategory;
      const customNames = state.userPrefs.customCategoryNames || {};
      const key = `${goalType}-${originalCategory}`;
      return customNames[key] || originalCategory;
    }

    // Save custom category name to database
    async function saveCustomCategoryName(goalType, originalCategory, customName) {
      if (!state.activeUser) return;

      const prefs = state.userPrefs || {};
      const newCustomNames = { ...(prefs.customCategoryNames || {}) };

      const key = `${goalType}-${originalCategory}`;

      // If custom name is same as original or empty, remove the override
      if (!customName || customName === originalCategory) {
        delete newCustomNames[key];
      } else {
        newCustomNames[key] = customName;
      }

      const newPrefs = { ...prefs, customCategoryNames: newCustomNames };
      state.userPrefs = newPrefs; // Optimistic update

      try {
        await apiSend("/user-prefs", "POST", {
          userId: state.activeUser.id,
          prefs: newPrefs
        });
      } catch (err) {
        console.error("Error saving user prefs:", err);
        showToast("Error saving header", true);
      }
    }

    async function loadUserPrefsForActiveUser() {
      if (!state.activeUser) {
        state.userPrefs = {};
        return;
      }

      try {
        // Load from DB
        const res = await apiSend(`/user-prefs?userId=${state.activeUser.id}`);
        state.userPrefs = res || {};
      } catch (err) {
        console.error("Error loading user preferences:", err);
        state.userPrefs = {}; // fallback
      }
    }

    async function setActiveUser(userIdOrNull) {
      state.activeUserId = userIdOrNull ? Number(userIdOrNull) : null;
      state.activeUser = getActiveUserSafe();

      // Sync goals filters to match active user (or "Everyone" if null)
      const ownerVal = state.activeUserId ? String(state.activeUserId) : "all";
      state.monthlyOwnerFilter = ownerVal;
      state.annualOwnerFilter = ownerVal;

      const mo = document.getElementById("monthly-owner-filter");
      const ao = document.getElementById("annual-owner-filter");
      if (mo) mo.value = ownerVal;
      if (ao) ao.value = ownerVal;

      // Load prefs + pillars for whoever we're working on
      await Promise.all([
        loadUserPrefsForActiveUser(),
        loadPillarsForActiveUser()
      ]);

      renderMonthlyGoals();
      renderAnnualGoals();
      renderPillars();
    }


    async function loadPillarsForActiveUser() {
      if (!state.activeUser) {
        console.error("No active user found");
        return;
      }

      // NOTE: state.userPrefs is loaded by loadUserPrefsForActiveUser() from the DB
      // Do NOT overwrite it with localStorage here

      const pillarsKey = `wrapsheet-pillars-v1:${state.activeUser.id}`;
      try {
        const raw = localStorage.getItem(pillarsKey);
        if (!raw) {
          state.pillars = { elevate: [], engage: [], evolve: [], excite: [] };
        } else {
          const parsed = JSON.parse(raw);
          state.pillars = parsed || { elevate: [], engage: [], evolve: [], excite: [] };
        }
      } catch (err) {
        console.error("Error loading pillars:", err);
        state.pillars = { elevate: [], engage: [], evolve: [], excite: [] };
      }

      renderPillars(); // Ensure pillars are rendered after loading
    }


    function getActiveUserSafe() {
      return state.users.find(u => String(u.id) === String(state.activeUserId)) || null;
    }


    // ===== DRAG & DROP STATE =====
    const dragState = {
      taskId: null,
      fromDate: null
    };

    function onTaskDragStart(e) {
      e.stopPropagation(); // Prevent section drag
      const pill = e.currentTarget;
      const taskId = pill.dataset.taskId;
      const fromDate = pill.dataset.date;

      if (!taskId || !fromDate) return;

      dragState.taskId = taskId;
      dragState.fromDate = fromDate;

      e.dataTransfer.effectAllowed = "move";
      // Needed for Firefox / some browsers
      e.dataTransfer.setData("text/plain", taskId);

      pill.classList.add("dragging");
    }

    function onTaskDragEnd(e) {
      const pill = e.currentTarget;
      pill.classList.remove("dragging");
      dragState.taskId = null;
      dragState.fromDate = null;
    }

    function onDayDragOver(e) {
      if (!dragState.taskId) return;
      // Allow drop
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    }

    function onDayDragEnter(e) {
      if (!dragState.taskId) return;
      e.preventDefault();
      e.currentTarget.classList.add("drop-target");
    }

    function onDayDragLeave(e) {
      e.currentTarget.classList.remove("drop-target");
    }

    function onDayDrop(e) {
      if (!dragState.taskId) return;
      e.preventDefault();

      const cell = e.currentTarget;
      cell.classList.remove("drop-target");

      const newDateKey = cell.dataset.dateKey;
      if (!newDateKey) return;

      // If same date, ignore
      if (state.dailyTasks.find(t => String(t.id) === String(dragState.taskId))?.task_date === newDateKey) return;

      moveTaskToDate(dragState.taskId, newDateKey);
    }

    async function moveTaskToDate(taskId, newDateKey) {
      // Search in both lists
      let task = state.dailyTasks.find(t => String(t.id) === String(taskId));
      const sourceList = task ? "daily" : "backlog";

      if (!task) {
        task = state.backlogTasks.find(t => String(t.id) === String(taskId));
      }

      if (!task) return;

      const oldDate = task.task_date;
      if (oldDate === newDateKey) return;

      // Optimistic Update
      task.task_date = newDateKey;

      if (newDateKey === BACKLOG_DATE) {
        // Moved TO Backlog
        // Remove from dailyTasks if there
        state.dailyTasks = state.dailyTasks.filter(t => t.id !== task.id);
        // Add to backlogTasks if not there
        if (!state.backlogTasks.find(t => t.id === task.id)) {
          state.backlogTasks.push(task);
        }
      } else {
        // Moved TO Calendar
        // Remove from backlogTasks if there
        state.backlogTasks = state.backlogTasks.filter(t => t.id !== task.id);
        // Add to dailyTasks if not there (and if it matches visible range, but for now just add it)
        if (!state.dailyTasks.find(t => t.id === task.id)) {
          state.dailyTasks.push(task);
        }
      }

      renderCalendar();
      if (typeof renderBacklog === "function") renderBacklog();

      try {
        await apiSend("/daily-tasks/" + taskId, "PATCH", { task_date: newDateKey });
        if (newDateKey === BACKLOG_DATE) {
          showToast("Moved to Backlog");
        } else {
          showToast("Scheduled for " + newDateKey);
        }
        // Reload to be safe and sync sorting/etc
        // await Promise.all([loadDailyTasks(), loadBacklogTasks()]); 
      } catch (err) {
        console.error(err);
        // Revert
        task.task_date = oldDate;
        if (sourceList === "daily") {
          if (!state.dailyTasks.find(t => t.id === task.id)) state.dailyTasks.push(task);
          state.backlogTasks = state.backlogTasks.filter(t => t.id !== task.id);
        } else {
          if (!state.backlogTasks.find(t => t.id === task.id)) state.backlogTasks.push(task);
          state.dailyTasks = state.dailyTasks.filter(t => t.id !== task.id);
        }
        renderCalendar();
        if (typeof renderBacklog === "function") renderBacklog();
        showToast("Error moving task", true);
      }
    }
    // ===== GAMIFICATION & FIREWORKS =====
    const AFFIRMATIONS = [
      "Good work! :)", "Awesome job!", "You're on fire! 🔥", "Way to go!",
      "Keep it up!", "Slaying it! ✨", "Productivity genius :D",
      "One step closer!", "Boom! Done.", "Excellent work!", "Victory! ✌️"
    ];

    function getRandomAffirmation() {
      return AFFIRMATIONS[Math.floor(Math.random() * AFFIRMATIONS.length)];
    }

    function showCelebration(text, subtext = "Task Completed") {
      const overlay = document.getElementById("celebration-overlay");
      const textEl = document.getElementById("celebration-text");
      const subEl = document.getElementById("celebration-sub");
      const emojiEl = document.getElementById("celebration-emoji");

      if (!overlay) return;

      textEl.textContent = text;
      subEl.textContent = subtext;
      emojiEl.textContent = "🎉"; // Could randomize emojis too

      overlay.classList.add("show");
      setTimeout(() => overlay.classList.remove("show"), 2500);
    }

    // Trigger fireworks
    // type: 'small' (single task), 'medium' (day complete), 'huge' (week complete)
    function triggerFireworks(type = 'small') {
      const duration = type === 'huge' ? 30 * 1000 : (type === 'medium' ? 3 * 1000 : 800);
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 9995 };

      function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      if (type === 'small') {
        // Single burst
        confetti({
          ...defaults,
          particleCount: 50,
          scalar: 1.2,
          origin: { y: 0.8 }
        });
      } else if (type === 'medium') {
        // Daily complete: couple of bursts
        const interval = setInterval(function () {
          const timeLeft = animationEnd - Date.now();
          if (timeLeft <= 0) return clearInterval(interval);

          confetti({
            ...defaults,
            particleCount: 50,
            origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
          });
          confetti({
            ...defaults,
            particleCount: 50,
            origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
          });
        }, 250);
      } else {
        // Huge (Week Complete): 30 seconds of pure joy
        const interval = setInterval(function () {
          const timeLeft = animationEnd - Date.now();
          if (timeLeft <= 0) return clearInterval(interval);

          const particleCount = 50 * (timeLeft / duration);
          confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } });
          confetti({ ...defaults, particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } });
        }, 250);

        showCelebration("CONGRATULATIONS!", "You finished ALL weekly tasks!");
      }

      if (type === 'small') {
        showCelebration(getRandomAffirmation());
      } else if (type === 'medium') {
        showCelebration("Daily Goals Crushed!", "All tasks done for today");
      }
    }

    function checkDailyCompletion(dateKey) {
      if (!dateKey) return;
      const tasks = state.dailyTasks.filter(t => t.task_date === dateKey);
      if (tasks.length === 0) return;

      const allDone = tasks.every(t => t.status === "done" || t.status === "could_not_complete");
      // Check if we just completed the last one is tricky without previous state, 
      // but triggering it every time the last one is clicked is acceptable gamification/affirmation.
      // Better: check if > 0 tasks are done.
      const doneCount = tasks.filter(t => t.status === "done").length;

      if (allDone && doneCount > 0) {
        triggerFireworks('medium');
        // Bonus coins for completing ALL daily tasks
        if (isRewardEligible()) {
          setTimeout(() => {
            awardCoins(25, null);
            playCoinBurstSound();
          }, 600);
        }
      } else {
        triggerFireworks('small');
      }
    }

    function checkWeeklyCompletion() {
      if (!state.weeklyTasks || state.weeklyTasks.length === 0) return;

      const allDone = state.weeklyTasks.every(t => t.status === "done");
      if (allDone) {
        triggerFireworks('huge');
      } else {
        triggerFireworks('small');
      }
    }

    // ===== COIN REWARD SYSTEM (Finch-style) =====
    const COIN_DAILY_CAP = 50;
    const COIN_WEEKLY_CAP = 250;

    // Check if current user is eligible for coin rewards
    function isRewardEligible() {
      if (!state.currentUser) return false;
      const name = (state.currentUser.name || "").toLowerCase();
      // Currently only enabled for Kevin - add more names here to scale
      return name.includes("kevin");
    }

    // Get current day/week keys for cap tracking
    function getCoinDayKey() {
      return new Date().toISOString().split("T")[0]; // "2026-01-20"
    }
    function getCoinWeekKey() {
      const now = new Date();
      const startOfYear = new Date(now.getFullYear(), 0, 1);
      const days = Math.floor((now - startOfYear) / 86400000);
      const weekNum = Math.ceil((days + startOfYear.getDay() + 1) / 7);
      return `${now.getFullYear()}-W${String(weekNum).padStart(2, "0")}`;
    }

    let coinSaveTimeout;

    // Load coin balance from API with local fallback
    async function loadCoinBalance() {
      if (!state.currentUser) return;

      // 1. Initial load from local storage for speed
      loadCoinBalanceLocal();
      updateCoinCounterDisplay();

      // 2. Fetch authoritative data from server
      try {
        const data = await apiSend(`/users/${state.currentUser.id}/coins`);
        if (data) {
          state.coinBalance = data.coin_balance || 0;
          state.coinDayEarned = data.coin_day_earned || 0;
          state.coinDayKey = data.coin_day_key || "";
          state.coinWeekEarned = data.coin_week_earned || 0;
          state.coinWeekKey = data.coin_week_key || "";

          // Sync back to local storage
          saveCoinBalanceLocal();
        }
      } catch (e) {
        console.warn("Could not load coins from API, using local backup", e);
      }

      // Reset daily/weekly counters if needed
      checkCoinRollovers();

      updateCoinCounterDisplay();

      // Show the coin counter wrapper for eligible users
      const wrapper = document.getElementById("coin-counter-wrap");
      if (wrapper && isRewardEligible()) {
        wrapper.classList.add("visible");
      }
    }

    function checkCoinRollovers() {
      // Reset daily counter if new day
      const today = getCoinDayKey();
      if (state.coinDayKey !== today) {
        state.coinDayKey = today;
        state.coinDayEarned = 0;
      }
      // Reset weekly counter if new week
      const thisWeek = getCoinWeekKey();
      if (state.coinWeekKey !== thisWeek) {
        state.coinWeekKey = thisWeek;
        state.coinWeekEarned = 0;
      }
      saveCoinBalanceLocal();
    }

    function loadCoinBalanceLocal() {
      try {
        const prefix = `wrapsheet-coins-${state.currentUser.id}`;
        state.coinBalance = parseInt(localStorage.getItem(`${prefix}-balance`) || "0", 10);
        state.coinDayKey = localStorage.getItem(`${prefix}-dayKey`) || "";
        state.coinDayEarned = parseInt(localStorage.getItem(`${prefix}-dayEarned`) || "0", 10);
        state.coinWeekKey = localStorage.getItem(`${prefix}-weekKey`) || "";
        state.coinWeekEarned = parseInt(localStorage.getItem(`${prefix}-weekEarned`) || "0", 10);
      } catch (e) { }
    }

    // Save coin balance locally and sync to server
    function saveCoinBalance() {
      saveCoinBalanceLocal();

      // Debounce server save
      clearTimeout(coinSaveTimeout);
      coinSaveTimeout = setTimeout(saveCoinBalanceToServer, 2000);
    }

    function saveCoinBalanceLocal() {
      if (!state.currentUser) return;
      try {
        const prefix = `wrapsheet-coins-${state.currentUser.id}`;
        localStorage.setItem(`${prefix}-balance`, String(state.coinBalance));
        localStorage.setItem(`${prefix}-dayKey`, state.coinDayKey);
        localStorage.setItem(`${prefix}-dayEarned`, String(state.coinDayEarned));
        localStorage.setItem(`${prefix}-weekKey`, state.coinWeekKey);
        localStorage.setItem(`${prefix}-weekEarned`, String(state.coinWeekEarned));
      } catch (e) {
        console.warn("Could not save coin balance:", e);
      }
    }

    async function saveCoinBalanceToServer() {
      if (!state.currentUser) return;
      try {
        await apiSend(`/users/${state.currentUser.id}/coins`, "PATCH", {
          coin_balance: state.coinBalance,
          coin_day_earned: state.coinDayEarned,
          coin_day_key: state.coinDayKey,
          coin_week_earned: state.coinWeekEarned,
          coin_week_key: state.coinWeekKey
        });
        // console.log("Coins saved to server");
      } catch (e) {
        console.warn("Error saving coins to server:", e);
      }
    }

    // Update the coin counter display and cap progress
    function updateCoinCounterDisplay() {
      const amountEl = document.getElementById("coin-amount");
      if (amountEl) {
        amountEl.textContent = state.coinBalance || 0;
      }
      // Update cap progress display
      const dayProgress = document.getElementById("coin-day-progress");
      const weekProgress = document.getElementById("coin-week-progress");
      if (dayProgress) {
        dayProgress.textContent = `${state.coinDayEarned || 0}/${COIN_DAILY_CAP} today`;
      }
      if (weekProgress) {
        weekProgress.textContent = `${state.coinWeekEarned || 0}/${COIN_WEEKLY_CAP} week`;
      }

      // Update Bird Energy Meter
      if (typeof updateBirdEnergy === "function") {
        updateBirdEnergy();
      }
    }

    // Check how many coins can be awarded (respecting caps)
    function getAwardableCoins(requested) {
      const dayRemaining = COIN_DAILY_CAP - (state.coinDayEarned || 0);
      const weekRemaining = COIN_WEEKLY_CAP - (state.coinWeekEarned || 0);
      return Math.max(0, Math.min(requested, dayRemaining, weekRemaining));
    }

    // Award coins - Logic Decoupled from Animation
    function awardCoins(amount, sourceElement) {
      if (!isRewardEligible() || amount <= 0) return;

      // Apply caps logic overrides
      const actualAmount = getAwardableCoins(amount);
      if (actualAmount <= 0) {
        showToast("Daily coin cap reached! 🪙");
        return;
      }

      // 1. Update State IMMEDIATELY
      state.coinBalance = (state.coinBalance || 0) + actualAmount;
      state.coinDayEarned = (state.coinDayEarned || 0) + actualAmount;
      state.coinWeekEarned = (state.coinWeekEarned || 0) + actualAmount;
      saveCoinBalance();
      updateCoinCounterDisplay();

      // 2. Play Sound/Animation
      playChaChingSound(0);

      // Bird Personality Reactions
      if (typeof squeak === "function") squeak(); // Happy squeak
      if (typeof speak === "function" && Math.random() > 0.6) {
        const praises = ["Great job!", "You did it!", "Keep going!", "Awesome!", "Woohoo!", "So productive!", "Proud of you!"];
        speak(praises[Math.floor(Math.random() * praises.length)]);
      }

      const counterEl = document.getElementById("coin-counter");
      if (counterEl) {
        counterEl.classList.add("pulse");
        setTimeout(() => counterEl.classList.remove("pulse"), 150);
      }

      // 3. Spawn Visuals (Fire and forget)
      if (counterEl && sourceElement) {
        // Pass 0 as coinsPerVisual because we already updated the balance
        spawnFlyingCoinsWithLanding(sourceElement.getBoundingClientRect(), counterEl.getBoundingClientRect(), Math.min(actualAmount, 8), 0, counterEl);
      }
    }

    // Deduct coins when unchecking a task
    function deductCoins(amount) {
      if (!isRewardEligible() || amount <= 0) return;

      // 1. Always decrement the "earned" counters so user can re-earn towards cap
      state.coinDayEarned = Math.max(0, (state.coinDayEarned || 0) - amount);
      state.coinWeekEarned = Math.max(0, (state.coinWeekEarned || 0) - amount);

      // 2. Decrement balance (floor at 0)
      const oldBalance = state.coinBalance;
      state.coinBalance = Math.max(0, oldBalance - amount);

      saveCoinBalance();
      updateCoinCounterDisplay(); // updates caps text and meter width

      // Play sad sound
      playDeductSound();

      // Animate counter if balance changed
      const counterEl = document.getElementById("coin-counter");
      if (counterEl && state.coinBalance !== oldBalance) {
        animateCoinCounter(oldBalance, state.coinBalance, 300);
        counterEl.classList.add("shake");
        setTimeout(() => counterEl.classList.remove("shake"), 400);
      }
    }

    // Spawn flying coins - use requestAnimationFrame for visible arc flight
    function spawnFlyingCoinsWithLanding(fromRect, toRect, count, coinsPerVisual, counterEl) {
      // Use viewport stats (Fixed positioning)
      const startX = fromRect.left + fromRect.width / 2;
      const startY = fromRect.top + fromRect.height / 2;
      const endX = toRect.left + toRect.width / 2;
      const endY = toRect.top + toRect.height / 2;

      for (let i = 0; i < count; i++) {
        const spawnDelay = i * 80; // Faster stagger

        setTimeout(() => {
          const coin = document.createElement("div");
          coin.className = "flying-coin";
          coin.textContent = "🪙";
          coin.style.transform = "scale(0)";

          // Force styles in JS to ensure visibility
          coin.style.position = "fixed";
          coin.style.zIndex = "2147483647";

          // Randomize start position slightly
          const offsetX = (Math.random() - 0.5) * 40;
          const offsetY = (Math.random() - 0.5) * 40;
          const coinStartX = startX + offsetX;
          const coinStartY = startY + offsetY;

          coin.style.left = coinStartX + "px";
          coin.style.top = coinStartY + "px";
          document.body.appendChild(coin);

          // Flight parameters
          const duration = 600 + Math.random() * 200;
          const arcHeight = Math.min(150, Math.abs(endY - coinStartY) * 0.5 + 50);
          const startTime = performance.now();

          // Animate with requestAnimationFrame
          function animate(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Ease out cubic for smooth deceleration
            const eased = 1 - Math.pow(1 - progress, 3);

            // Calculate position with arc (parabolic curve)
            const x = coinStartX + (endX - coinStartX) * eased;
            // Arc: goes up then down using sine curve
            const arcOffset = Math.sin(progress * Math.PI) * arcHeight;
            const y = coinStartY + (endY - coinStartY) * eased - arcOffset;

            // Scale and rotation
            const scale = progress < 0.2
              ? progress * 5  // Pop in (0 to 1)
              : progress > 0.9
                ? 1 - (progress - 0.9) * 5  // Shrink at end
                : 1;
            const rotation = progress * 720;

            coin.style.left = x + "px";
            coin.style.top = y + "px";
            coin.style.transform = `scale(${scale}) rotate(${rotation}deg)`;

            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Coin landed!
              playChaChingSound(i);

              // Increment balance
              state.coinBalance += coinsPerVisual;

              // Only save if meaningful
              if (coinsPerVisual > 0) saveCoinBalance();

              // Update counter with pulse
              if (typeof updateCoinCounterDisplay === "function") updateCoinCounterDisplay();

              if (counterEl) {
                counterEl.classList.add("pulse");
                setTimeout(() => counterEl.classList.remove("pulse"), 150);
              }

              // Remove coin
              coin.remove();
            }
          }

          requestAnimationFrame(animate);
        }, spawnDelay);
      }
    }

    // Animate coin counter from old to new value
    function animateCoinCounter(from, to, duration) {
      const amountEl = document.getElementById("coin-amount");
      if (!amountEl) return;

      const startTime = performance.now();
      const diff = to - from;

      function step(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        const current = Math.round(from + diff * eased);
        amountEl.textContent = current;
        if (progress < 1) {
          requestAnimationFrame(step);
        }
      }
      requestAnimationFrame(step);
    }

    // Play cha-ching coinslot sound using Web Audio API
    function playChaChingSound(index) {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        const now = audioContext.currentTime;

        // Create metallic "cha-ching" sound with multiple harmonics
        const fundamentalFreq = 1200 + (index * 80);

        // Main tone
        const osc1 = audioContext.createOscillator();
        const gain1 = audioContext.createGain();
        osc1.type = "square";
        osc1.frequency.setValueAtTime(fundamentalFreq, now);
        osc1.frequency.exponentialRampToValueAtTime(fundamentalFreq * 0.5, now + 0.15);
        gain1.gain.setValueAtTime(0, now);
        gain1.gain.linearRampToValueAtTime(0.12, now + 0.01);
        gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc1.connect(gain1);
        gain1.connect(audioContext.destination);
        osc1.start(now);
        osc1.stop(now + 0.2);

        // High metallic ping
        const osc2 = audioContext.createOscillator();
        const gain2 = audioContext.createGain();
        osc2.type = "sine";
        osc2.frequency.setValueAtTime(fundamentalFreq * 2, now);
        osc2.frequency.exponentialRampToValueAtTime(fundamentalFreq * 1.5, now + 0.1);
        gain2.gain.setValueAtTime(0, now);
        gain2.gain.linearRampToValueAtTime(0.08, now + 0.005);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc2.connect(gain2);
        gain2.connect(audioContext.destination);
        osc2.start(now);
        osc2.stop(now + 0.15);

        // Low "clunk" for slot machine feel
        const osc3 = audioContext.createOscillator();
        const gain3 = audioContext.createGain();
        osc3.type = "triangle";
        osc3.frequency.setValueAtTime(200, now);
        osc3.frequency.exponentialRampToValueAtTime(80, now + 0.05);
        gain3.gain.setValueAtTime(0.1, now);
        gain3.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc3.connect(gain3);
        gain3.connect(audioContext.destination);
        osc3.start(now);
        osc3.stop(now + 0.1);

      } catch (e) {
        // Silently fail
      }
    }

    // --- BIRD SYSTEM LOGIC ---

    let birdState = {
      isHappy: false,
      pettingScore: 0,
      lastMouseX: 0,
      blinkTimer: null
    };

    function initBirdSystem() {
      const svgContainer = document.getElementById("finch-svg");
      if (!svgContainer) return;

      // Render Bird SVG (Refined "Round Blob" Finch Style)
      // Reference Colors: Pink Body (#f9a8d4), Yellow Cap/Wings (#fde047), Blue Tummy (#60a5fa)
      svgContainer.innerHTML = `
        <g id="bird-whole" transform="translate(100, 110) scale(1.4)">
           <!-- Legs (Orange) -->
           <path class="bird-foot-l" d="M -20 70 Q -30 75 -40 70 L -35 60 L -20 50" fill="#f97316" stroke="#ea580c" stroke-width="2.5" stroke-linecap="round" />
           <path class="bird-foot-r" d="M 20 70 Q 30 75 40 70 L 35 60 L 20 50" fill="#f97316" stroke="#ea580c" stroke-width="2.5" stroke-linecap="round" />

           <!-- Body (Large Pink Blob) -->
           <!-- Rounder, fuller bottom -->
           <path class="bird-body" d="M -55 20 C -65 -20 -40 -60 0 -60 C 40 -60 65 -20 55 20 C 50 70 -50 70 -55 20 Z" fill="#f9a8d4" />

           <!-- Head Cap (Yellow) -->
           <!-- Follows top contour of body, comes down to forehead -->
           <path class="bird-head" d="M -48 -25 C -40 -50 -20 -60 0 -60 C 20 -60 40 -50 48 -25 C 25 -10 -25 -10 -48 -25 Z" fill="#fde047" />

           <!-- Tummy (Blue) -->
           <!-- Large round oval -->
           <ellipse class="bird-tummy" cx="0" cy="35" rx="38" ry="32" fill="#60a5fa" />

           <!-- Wings (Yellow) - Bigger and Rounder -->
           <!-- Sticking out more noticeably -->
           <path class="bird-wing-l" d="M -53 10 Q -85 15 -75 45 Q -60 50 -50 35" fill="#fde047" stroke="#eab308" stroke-width="1.5" />
           <path class="bird-wing-r" d="M 53 10 Q 85 15 75 45 Q 60 50 50 35" fill="#fde047" stroke="#eab308" stroke-width="1.5" />

           <!-- Face -->
           <g id="bird-face" transform="translate(0, -25)">
             <!-- Cheeks (Pinker) -->
             <circle cx="-32" cy="15" r="9" fill="#f472b6" opacity="0.6" />
             <circle cx="32" cy="15" r="9" fill="#f472b6" opacity="0.6" />

             <!-- Beak (Orange/Yellow) -->
             <path class="bird-beak" d="M -8 10 Q 0 18 8 10 L 0 4 Z" fill="#facc15" stroke="#ca8a04" stroke-width="1.5" />

             <!-- Eyes -->
             <g id="eyes-open">
               <circle cx="-18" cy="0" r="7.5" fill="#1f2937" />
               <circle cx="18" cy="0" r="7.5" fill="#1f2937" />
               <circle cx="-15" cy="-3" r="2.5" fill="#fff" />
               <circle cx="21" cy="-3" r="2.5" fill="#fff" />
             </g>
             
             <!-- Eyes Closed/Happy -->
             <g id="eyes-closed" style="display:none">
               <path d="M -24 5 Q -18 10 -12 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
               <path d="M 12 5 Q 18 10 24 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
             </g>
             <g id="eyes-happy" style="display:none">
                <path d="M -24 5 Q -18 -5 -12 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
                <path d="M 12 5 Q 18 -5 24 5" fill="none" stroke="#1f2937" stroke-width="3" stroke-linecap="round" />
             </g>
           </g>
        </g>
      `;

      // Start interactions
      startBlinking();
      setupPetting();
      updateBirdEnergy(); // Init meter

      // Init Personality (Audio/Speech)
      initBirdPersonality();
    }

    // --- Bird Personality System ---
    let birdName = null;
    let squeaksMuted = localStorage.getItem("bird_squeaks_muted") === "true";
    let speechTimer = null;

    function initBirdPersonality() {
      // 1. Mute Button
      const muteBtn = document.getElementById("bird-mute-btn");
      if (muteBtn) {
        updateMuteUI();
        muteBtn.addEventListener("click", toggleMute);
      }

      // 2. Random Encouragement Loop
      if (speechTimer) clearInterval(speechTimer);
      speechTimer = setInterval(() => {
        // 10% chance every minute to show a random message
        if (Math.random() < 0.1) {
          const idleMessages = [
            // Original messages
            "Tweet?", "I believe in you!", "*hop*", "Don't give up!", "You got this!", "*flutter*",
            // Wellness reminders
            "Did you stretch today?", "Did you drink enough water?", "Are you protecting your peace today?",
            "Take a deep breath! 🌬️", "Have you taken a break recently?", "How's your posture right now?",
            "Remember to blink! 👀", "Stand up and stretch!", "You're doing amazing!",
            "What's one thing you're grateful for?", "Smile! Even if no one's watching.", "Your goals matter!",
            "Small steps = big progress!", "Be kind to yourself today.", "Celebrate your wins! 🎉"
          ];
          const msg = idleMessages[Math.floor(Math.random() * idleMessages.length)];
          squeak(); // Chirp before speaking
          speak(msg);
        }
      }, 60000);

      // 3. Update Name UI
      updateBirdNameUI();
    }

    function updateMuteUI() {
      const muteBtn = document.getElementById("bird-mute-btn");
      if (muteBtn) {
        muteBtn.textContent = squeaksMuted ? "🔇" : "🔊";
        muteBtn.classList.toggle("muted", squeaksMuted);
        muteBtn.title = squeaksMuted ? "Unmute Squeaks" : "Mute Squeaks";
      }
    }

    function toggleMute() {
      squeaksMuted = !squeaksMuted;
      localStorage.setItem("bird_squeaks_muted", squeaksMuted);
      updateMuteUI();
      if (!squeaksMuted) squeak(); // Confirmation squeak
    }

    // Web Audio API Context
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();

    function squeak() {
      if (squeaksMuted) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();

      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      // Finch-like chirp: high pitch, rapid drop
      // Start high
      const now = audioCtx.currentTime;
      osc.type = 'sine';
      osc.frequency.setValueAtTime(2000 + Math.random() * 500, now);
      osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);

      // Envelope
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(0.1, now + 0.02);
      gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

      osc.start(now);
      osc.stop(now + 0.2);
    }

    function speak(text) {
      const bubble = document.getElementById("bird-speech-bubble");
      if (!bubble) return;

      bubble.textContent = text;
      bubble.classList.remove("hidden");
      // Trigger reflow/animation
      requestAnimationFrame(() => {
        bubble.classList.add("visible");
      });

      // Play sound if acceptable? Squeak on speak?
      // squeak(); 

      // Hide after 4 seconds
      setTimeout(() => {
        bubble.classList.remove("visible");
        setTimeout(() => bubble.classList.add("hidden"), 300);
      }, 4000);
    }

    function updateBirdNameUI() {
      const display = document.getElementById("bird-name-display");
      if (display) {
        display.textContent = birdName || "";
      }
    }

    function startBlinking() {
      // Random blink interval between 2s and 6s
      const nextBlink = 2000 + Math.random() * 4000;

      birdState.blinkTimer = setTimeout(() => {
        if (!birdState.isHappy) { // Don't blink if happy (closed eyes)
          toggleEyes(false); // Close
          setTimeout(() => toggleEyes(true), 150); // Open
        }
        startBlinking();
      }, nextBlink);
    }

    function toggleEyes(isOpen) {
      const open = document.getElementById("eyes-open");
      const closed = document.getElementById("eyes-closed");
      if (open && closed) {
        open.style.display = isOpen ? "block" : "none";
        closed.style.display = isOpen ? "none" : "block";
      }
    }

    function setExpression(type) { // 'normal', 'happy'
      const open = document.getElementById("eyes-open");
      const closed = document.getElementById("eyes-closed");
      const happy = document.getElementById("eyes-happy");

      if (!open || !happy) return;

      if (type === 'happy') {
        open.style.display = "none";
        closed.style.display = "none";
        happy.style.display = "block";
      } else {
        open.style.display = "block";
        closed.style.display = "none";
        happy.style.display = "none";
      }
    }

    function setupPetting() {
      const wrapper = document.getElementById("finch-container");
      if (!wrapper) return;

      wrapper.addEventListener("mousemove", (e) => {
        // Calculate movement speed/distance
        const dist = Math.abs(e.movementX) + Math.abs(e.movementY);

        if (dist > 5) {
          birdState.pettingScore += dist;

          if (birdState.pettingScore > 300 && !birdState.isHappy) {
            triggerHappyBird();
          }
        }
      });

      wrapper.addEventListener("mouseleave", () => {
        birdState.pettingScore = 0;
        if (birdState.isHappy) {
          stopHappyBird();
        }
      });
    }

    function triggerHappyBird() {
      birdState.isHappy = true;
      setExpression('happy');

      // Happy chirp when petted!
      squeak();

      // Bounce animation
      const bird = document.getElementById("bird-whole");
      if (bird) {
        bird.style.transition = "transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)";
        bird.style.transform = "translate(100, 125) scale(1.05)"; // Bounce up
        setTimeout(() => {
          bird.style.transform = "translate(100, 130) scale(1)";
        }, 200);
      }

      // Spawn hearts
      spawnHeart();
    }

    function stopHappyBird() {
      birdState.isHappy = false;
      setExpression('normal');
    }

    function spawnHeart() {
      if (!birdState.isHappy) return;

      const container = document.getElementById("finch-hearts");
      if (!container) return;

      const heart = document.createElement("div");
      heart.className = "pet-heart";
      heart.textContent = "❤️";
      // Random position near head
      const left = 30 + Math.random() * 60; // Roughly centered
      const top = 20 + Math.random() * 20;

      heart.style.left = left + "%";
      heart.style.top = top + "%";

      container.appendChild(heart);

      // Clean up
      setTimeout(() => heart.remove(), 1000);

      // Continue spawning if still happy and moving
      if (birdState.pettingScore > 0) {
        setTimeout(spawnHeart, 400 + Math.random() * 400);
      }
    }

    function updateBirdEnergy() {
      const fill = document.getElementById("bird-energy-fill");
      if (fill) {
        const earned = state.coinDayEarned || 0;
        const pct = Math.min(100, (earned / COIN_DAILY_CAP) * 100);
        fill.style.width = pct + "%";

        // Update label
        const txt = document.getElementById("bird-energy-text");
        if (txt) txt.textContent = `${earned}/${COIN_DAILY_CAP}`;
      }
    }

    // --- BIRD EDITOR LOGIC ---

    // Default Colors
    const DEFAULT_BIRD_COLORS = {
      head: "#fde047",
      body: "#f9a8d4",
      tummy: "#60a5fa",
      wings: "#fde047",
      beak: "#facc15",
      feet: "#f97316"
    };

    let currentBirdColors = { ...DEFAULT_BIRD_COLORS };

    async function loadBirdPreferences() {
      // 1. Try to load from local storage first for speed
      if (state.currentUser) {
        try {
          // Attempt to fetch from API
          // Endpoint: /api/users/:id/prefs
          const prefs = await apiSend(`/users/${state.currentUser.id}/prefs`);

          let savedColors = prefs ? (prefs.bird_colors || prefs.birdColors) : null;
          if (typeof savedColors === 'string') {
            try { savedColors = JSON.parse(savedColors); } catch (e) { }
          }

          // Load Name
          birdName = prefs ? prefs.bird_name : null;
          updateBirdNameUI();

          if (savedColors) {
            currentBirdColors = { ...DEFAULT_BIRD_COLORS, ...savedColors };
            applyBirdColors(currentBirdColors);
          }
        } catch (e) {
          console.warn("Could not load bird prefs", e);
        }
      }
    }

    function applyBirdColors(colors, targetSvgId = "bird-whole") {
      // Apply colors to specific elements via CSS selection
      // Target can be main bird or preview bird
      const root = document.getElementById(targetSvgId);
      if (!root) return;

      const setFill = (cls, val) => {
        root.querySelectorAll(`.${cls}`).forEach(el => el.setAttribute("fill", val));
      };
      const setStroke = (cls, val) => {
        // For beak/wings, we might also want to darken stroke automatically?
        // For now just fill, we kept strokes hardcoded or could derive them.
        root.querySelectorAll(`.${cls}`).forEach(el => el.setAttribute("fill", val));
      };

      setFill("bird-head", colors.head);
      setFill("bird-body", colors.body);
      setFill("bird-tummy", colors.tummy);
      setFill("bird-wing-l", colors.wings);
      setFill("bird-wing-r", colors.wings);
      setFill("bird-beak", colors.beak);
      setFill("bird-foot-l", colors.feet);
      setFill("bird-foot-r", colors.feet);
    }

    function openBirdEditor() {
      const modal = document.getElementById("bird-editor-modal");
      const previewSvg = document.getElementById("bird-editor-preview");
      const controls = document.getElementById("bird-color-controls");
      const nameInput = document.getElementById("bird-name-input");

      if (!modal || !previewSvg || !controls) return;

      // Pre-fill name
      if (nameInput) nameInput.value = birdName || "";

      // 1. Clone current bird to preview
      const mainBirdGroup = document.getElementById("bird-whole");
      if (mainBirdGroup) {
        previewSvg.innerHTML = ""; // Clear
        const clone = mainBirdGroup.cloneNode(true);
        clone.id = "bird-preview-group";
        // Scale up significantly (2.2) to fill the modal box
        clone.setAttribute("transform", "translate(100, 110) scale(2.2)");
        previewSvg.appendChild(clone);
      }

      // 2. Render Color Controls
      const parts = [
        { id: "head", label: "Head Cap" },
        { id: "body", label: "Body" },
        { id: "tummy", label: "Tummy" },
        { id: "wings", label: "Wings" },
        { id: "beak", label: "Beak" },
        { id: "feet", label: "Feet" }
      ];

      controls.innerHTML = parts.map(part => `
         <div class="color-control-group">
            <label>${part.label}</label>
            <div class="color-picker-row">
               <input type="color" class="color-input-styled" 
                      data-part="${part.id}" 
                      value="${currentBirdColors[part.id]}"
                      oninput="handleColorChange('${part.id}', this.value)">
            </div>
         </div>
       `).join("");

      modal.style.display = "flex";
      applyBirdColors(currentBirdColors, "bird-preview-group");
    }

    window.handleColorChange = (part, value) => {
      // Update preview only
      const previewColors = { ...currentBirdColors }; // Base
      // Collect all current inputs
      document.querySelectorAll(".color-input-styled").forEach(input => {
        previewColors[input.dataset.part] = input.value;
      });
      applyBirdColors(previewColors, "bird-preview-group");
    };

    function closeBirdEditor() {
      document.getElementById("bird-editor-modal").style.display = "none";
    }

    async function saveBirdColors() {
      const newColors = { ...currentBirdColors };
      document.querySelectorAll(".color-input-styled").forEach(input => {
        newColors[input.dataset.part] = input.value;
      });

      // 1. Update State
      currentBirdColors = newColors;

      // 2. Apply to Real Bird
      applyBirdColors(currentBirdColors, "bird-whole");

      // 3. Persist to DB
      if (state.currentUser) {
        birdName = document.getElementById("bird-name-input").value.trim() || null;
        updateBirdNameUI();

        try {
          await apiSend(`/users/${state.currentUser.id}/prefs`, "PATCH", {
            userId: state.currentUser.id,
            birdColors: currentBirdColors,
            bird_name: birdName
          });
          showToast("Bird saved!");
        } catch (e) {
          console.warn("Save failed", e);
          showToast("Saved locally (Server error)", true);
        }
      }

      closeBirdEditor();
    }




    // Initialize Editor Listeners
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => {
        initBirdSystem();
        loadBirdPreferences(); // visual init
      }, 1000);

      const editBtn = document.getElementById("edit-bird-trigger");
      if (editBtn) editBtn.addEventListener("click", openBirdEditor);

      const closeBtn = document.getElementById("close-bird-editor");
      const cancelBtn = document.getElementById("cancel-bird-editor");
      const saveBtn = document.getElementById("save-bird-editor");

      if (closeBtn) closeBtn.addEventListener("click", closeBirdEditor);
      if (cancelBtn) cancelBtn.addEventListener("click", closeBirdEditor);
      if (saveBtn) saveBtn.addEventListener("click", saveBirdColors);
    });

    // --- END BIRD EDITOR LOGIC ---

    // Play sad deduct sound
    function playDeductSound() {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const now = audioContext.currentTime;

        // Descending sad tone
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.start(now);
        osc.stop(now + 0.35);
      } catch (e) { }
    }

    // Play burst sound for bonus
    function playCoinBurstSound() {
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const now = audioContext.currentTime;

        // Play ascending chord for jackpot feel
        [523, 659, 784, 880, 1047].forEach((freq, i) => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          osc.type = "sine";
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, now + i * 0.04);
          gain.gain.linearRampToValueAtTime(0.08, now + i * 0.04 + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.04 + 0.5);
          osc.connect(gain);
          gain.connect(audioContext.destination);
          osc.start(now + i * 0.04);
          osc.stop(now + i * 0.04 + 0.6);
        });
      } catch (e) { }
    }

    async function quickUpdateTaskStatus(task, newStatus) {
      const oldStatus = task.status || "pending";
      if (oldStatus === newStatus) return;

      // Optimistic UI
      task.status = newStatus;
      renderCalendar();

      try {
        await apiSend("/daily-tasks/" + task.id, "PATCH", { status: newStatus });

        if (newStatus === "done") {
          showToast("Task marked complete");
          checkDailyCompletion(task.task_date);

          // Award coins for task completion
          if (isRewardEligible()) {
            const pillEl = document.querySelector(`[data-task-id="${task.id}"]`);
            awardCoins(5, pillEl);
          }
        } else if (newStatus === "could_not_complete") {
          showToast("Task marked as could not complete");
          // Deduct coins if was previously done
          if (oldStatus === "done" && isRewardEligible()) {
            deductCoins(5);
          }
        } else {
          showToast("Task updated");
          // Deduct coins if was previously done (unchecked)
          if (oldStatus === "done" && isRewardEligible()) {
            deductCoins(5);
          }
        }

        // Reload to ensure we pick up any server-side changes (emails, timestamps, assignees)
        await loadDailyTasks();
      } catch (err) {
        console.error(err);
        // Revert on error
        task.status = oldStatus;
        renderCalendar();
        showToast("Error updating task status", true);
      }
    }


    const LOADER_MESSAGES = [
      {
        main: "Syncing…",
        sub: "Saving your change to the Wrap Sheet"
      },
      {
        main: "Updating tasks…",
        sub: "Pushing your edits to HQ"
      },
      {
        main: "Locking it in…",
        sub: "Your goals are being updated"
      },
      {
        main: "Polishing your wrap…",
        sub: "Making everything look just right"
      },
      {
        main: "Checking it twice…",
        sub: "Confirming those changes with the cloud"
      }
    ];

    function pickLoaderMessage() {
      return LOADER_MESSAGES[
        Math.floor(Math.random() * LOADER_MESSAGES.length)
      ];
    }

    function showActionLoader(customMessage) {
      const loader = document.getElementById("action-loader");
      if (!loader) return;

      const mainEl = document.getElementById("action-loader-main");
      const subEl = document.getElementById("action-loader-sub");

      const msg = customMessage || pickLoaderMessage();

      if (typeof msg === "string") {
        mainEl.textContent = msg;
        subEl.textContent = "One sec while we save that…";
      } else {
        mainEl.textContent = msg.main || "Syncing…";
        subEl.textContent = msg.sub || "Saving your change…";
      }

      loader.classList.add("show");
    }

    function hideActionLoader() {
      const loader = document.getElementById("action-loader");
      if (!loader) return;
      loader.classList.remove("show");
    }


    // ===== UTILITIES =====
    function pad2(n) {
      return String(n).padStart(2, "0");
    }

    function monthKeyFromDate(d) {
      return d.getFullYear() + "-" + pad2(d.getMonth() + 1);
    }

    function dateKey(y, mIndexZeroBased, day) {
      return y + "-" + pad2(mIndexZeroBased + 1) + "-" + pad2(day);
    }

    function addDays(date, days) {
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      d.setDate(d.getDate() + days);
      return d;
    }

    function parseDateKey(key) {
      const [y, m, d] = key.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function formatDateKeyFromDate(d) {
      return dateKey(d.getFullYear(), d.getMonth(), d.getDate());
    }

    // Move a date to a nearby weekday if it falls on a weekend.
    // Sat -> Friday, Sun -> Monday.
    function adjustToBusinessDay(d) {
      const weekday = d.getDay();
      if (weekday === 6) {
        // Saturday -> Friday
        d.setDate(d.getDate() - 1);
      } else if (weekday === 0) {
        // Sunday -> Monday
        d.setDate(d.getDate() + 1);
      }
      return d;
    }

    // e.g. "2nd Tuesday of the month"
    function nthWeekdayOfMonth(year, monthIndex0, weekday, nth) {
      const first = new Date(year, monthIndex0, 1);
      const offset = (weekday - first.getDay() + 7) % 7;
      const day = 1 + offset + (nth - 1) * 7;

      const daysInMonth = new Date(year, monthIndex0 + 1, 0).getDate();
      if (day > daysInMonth) return null;

      return new Date(year, monthIndex0, day);
    }

    /**
     * Compute future dates for a repeated task between a start & end date.
     *
     * baseDateStr: the date of the task in the modal, "YYYY-MM-DD"
     * repeatType: "weekly" | "monthly_date" | "monthly_weekday"
     * seriesStartStr: "YYYY-MM-DD" (when the series is allowed to start)
     * seriesEndStr: "YYYY-MM-DD" (inclusive)
     *
     * Returns array of "YYYY-MM-DD" strings for FUTURE dates only (not including base).
     */
    function computeRecurringDatesBetween(baseDateStr, repeatType, seriesStartStr, seriesEndStr) {
      if (!baseDateStr || repeatType === "none" || !seriesEndStr) return [];

      const base = parseDateKey(baseDateStr);
      const seriesStart = seriesStartStr ? parseDateKey(seriesStartStr) : base;
      const seriesEnd = parseDateKey(seriesEndStr);

      // If end is before base, nothing to do
      if (seriesEnd < base) return [];

      const results = [];
      const maxOccurrences = 120; // safety cap so you don't accidentally spam the year

      if (repeatType === "daily") {
        // Daily (Mon-Fri): create task for each weekday between base and end
        let current = new Date(base);
        while (true) {
          current = addDays(current, 1);
          if (current > seriesEnd || results.length >= maxOccurrences) break;
          const dayOfWeek = current.getDay();
          // Only include weekdays (1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri)
          if (dayOfWeek >= 1 && dayOfWeek <= 5 && current >= seriesStart) {
            results.push(formatDateKeyFromDate(current));
          }
        }
      } else if (repeatType === "weekly") {
        let current = new Date(base);
        while (true) {
          current = addDays(current, 7);
          if (current > seriesEnd || results.length >= maxOccurrences) break;
          if (current >= seriesStart) {
            results.push(formatDateKeyFromDate(current));
          }
        }
      } else if (repeatType === "monthly_date") {
        const dayOfMonth = base.getDate();
        let y = base.getFullYear();
        let m = base.getMonth();

        while (true) {
          m++;
          if (m > 11) {
            m = 0;
            y++;
          }
          const daysInMonth = new Date(y, m + 1, 0).getDate();
          const safeDay = Math.min(dayOfMonth, daysInMonth);
          let cand = new Date(y, m, safeDay);
          cand = adjustToBusinessDay(cand);
          if (cand > seriesEnd || results.length >= maxOccurrences) break;
          if (cand >= seriesStart && cand > base) {
            results.push(formatDateKeyFromDate(cand));
          }
        }
      } else if (repeatType === "monthly_weekday") {
        const weekday = base.getDay(); // 0–6
        const nth = Math.floor((base.getDate() - 1) / 7) + 1; // 1st, 2nd, 3rd…

        let y = base.getFullYear();
        let m = base.getMonth();

        while (true) {
          m++;
          if (m > 11) {
            m = 0;
            y++;
          }

          const cand = nthWeekdayOfMonth(y, m, weekday, nth);
          if (!cand) continue;

          if (cand > seriesEnd || results.length >= maxOccurrences) break;
          if (cand >= seriesStart && cand > base) {
            results.push(formatDateKeyFromDate(cand));
          }
        }
      }

      return results;
    }



    function getWeekStart(date, weekStartsOnMonday = false) {
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      const day = d.getDay(); // 0–6 (Sun–Sat)
      let diff;
      if (weekStartsOnMonday) {
        diff = day === 0 ? -6 : 1 - day;
      } else {
        diff = -day;
      }
      d.setDate(d.getDate() + diff);
      return d;
    }

    function getVisibleDateRange() {
      const base = state.currentMonthDate;
      const year = base.getFullYear();
      const month = base.getMonth();

      if (state.calendarView === "month") {
        const first = dateKey(year, month, 1);
        const lastDay = new Date(year, month + 1, 0).getDate();
        const last = dateKey(year, month, lastDay);
        return [first, last];
      }

      const isWorkweek = state.calendarView === "workweek" || state.calendarView === "jointweek";
      const weekStart = getWeekStart(base, isWorkweek);
      const daysCount = isWorkweek ? 4 : 6; // inclusive end
      const startKey = dateKey(
        weekStart.getFullYear(),
        weekStart.getMonth(),
        weekStart.getDate()
      );
      const weekEnd = addDays(weekStart, daysCount);
      const endKey = dateKey(
        weekEnd.getFullYear(),
        weekEnd.getMonth(),
        weekEnd.getDate()
      );
      return [startKey, endKey];
    }

    function showToast(message, isError = false) {
      const toast = document.getElementById("toast");
      toast.textContent = "";
      const span = document.createElement("span");
      span.textContent = message;
      toast.appendChild(span);
      toast.style.borderColor = isError ? "#f97373" : "rgba(148,163,184,0.7)";
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 2800);
    }

    async function apiGet(path) {
      const res = await fetch(API_BASE + path, {
        headers: { "Accept": "application/json" }
      });
      if (!res.ok) throw new Error("GET " + path + " failed");
      return res.json();
    }

    async function apiSend(path, method, body) {
      showActionLoader(); // TikTok-style popup

      // random delay between 500ms and 2000ms
      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        const fetchPromise = fetch(API_BASE + path, {
          method,
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          body: JSON.stringify(body)
        });

        // Wait for BOTH: the network AND the fake delay
        const res = await Promise.all([fetchPromise, delayPromise]).then(
          ([res]) => res
        );

        if (!res.ok) {
          const text = await res.text().catch(() => "");
          throw new Error(method + " " + path + " failed: " + text);
        }

        // Handle empty responses (common for DELETE with 204 No Content)
        const text = await res.text();
        if (!text || text.trim() === "") {
          return null;
        }
        const data = JSON.parse(text);
        return data;
      } finally {
        hideActionLoader();
      }
    }

    async function createMultipleTasks(payloads, loaderMessage) {
      if (!payloads || !payloads.length) return;

      showActionLoader(
        loaderMessage || {
          main: "Creating repeated tasks…",
          sub: "Adding them to your Wrap Sheet"
        }
      );

      const delayMs = 600 + Math.random() * 1200;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        const fetches = payloads.map(p =>
          fetch(API_BASE + "/daily-tasks", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
            },
            body: JSON.stringify(p)
          })
        );

        const responsesPlusDelay = await Promise.all([...fetches, delayPromise]);
        const responses = responsesPlusDelay.slice(0, -1); // strip delay

        for (const res of responses) {
          if (!res.ok) {
            const text = await res.text().catch(() => "");
            throw new Error("POST /daily-tasks failed: " + text);
          }
        }
      } finally {
        hideActionLoader();
      }
    }


    function applyTheme(theme) {
      const safeTheme = theme === "dark" ? "dark" : "light";
      state.theme = safeTheme;
      document.body.dataset.theme = safeTheme;

      const select = document.getElementById("theme-select");
      if (select && select.value !== safeTheme) {
        select.value = safeTheme;
      }

      try {
        localStorage.setItem("wrapsheet-theme", safeTheme);
        saveUserDbPreference("theme", safeTheme);
      } catch {
        // ignore storage errors
      }
    }

    function initTheme() {
      let stored = null;
      try {
        stored = localStorage.getItem("wrapsheet-theme");
      } catch {
        stored = null;
      }
      const initial = stored === "dark" ? "dark" : "light";
      applyTheme(initial);
    }


    // ===== LIVE SYNC =====
    const LIVE_SYNC_INTERVAL_MS = 300000; // 5 minutes
    const TYPING_COOLDOWN_MS = 30000; // 30 seconds after typing before sync
    let liveSyncIntervalId = null;
    let lastUserTypingTime = 0;

    // Track user typing activity
    document.addEventListener("input", () => {
      lastUserTypingTime = Date.now();
    });

    function startLiveSync() {
      if (liveSyncIntervalId) return; // Already running
      console.log("[LiveSync] Starting with interval:", LIVE_SYNC_INTERVAL_MS, "ms");
      liveSyncIntervalId = setInterval(() => {
        if (document.visibilityState === "visible") {
          // Check if user was typing recently
          const timeSinceTyping = Date.now() - lastUserTypingTime;
          if (timeSinceTyping < TYPING_COOLDOWN_MS) {
            console.log("[LiveSync] Skipping - user was typing recently (", Math.round(timeSinceTyping / 1000), "s ago)");
            return;
          }
          console.log("[LiveSync] Refreshing data...");
          refreshAllData(true); // silent=true to avoid toasts
        }
      }, LIVE_SYNC_INTERVAL_MS);
      // Also refresh immediately when tab becomes visible after being hidden
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    function onVisibilityChange() {
      if (document.visibilityState === "visible" && liveSyncIntervalId) {
        // Check if user was typing recently before syncing on visibility change
        const timeSinceTyping = Date.now() - lastUserTypingTime;
        if (timeSinceTyping < TYPING_COOLDOWN_MS) {
          console.log("[LiveSync] Tab visible but skipping sync - user was typing recently");
          return;
        }
        console.log("[LiveSync] Tab visible again, refreshing...");
        refreshAllData(true);
      }
    }
    function stopLiveSync() {
      if (liveSyncIntervalId) {
        clearInterval(liveSyncIntervalId);
        liveSyncIntervalId = null;
        document.removeEventListener("visibilitychange", onVisibilityChange);
        console.log("[LiveSync] Stopped");
      }
    }

    // ===== INITIAL LOAD =====
    document.addEventListener("DOMContentLoaded", async () => {
      attachEventHandlers();

      initTheme();

      try {
        await loadUsers();
      } catch (err) {
        console.error(err);
        showToast("Error loading users", true);
      }
      restoreUserFromStorage();
      if (state.currentUser) {
        document.getElementById("user-overlay").classList.add("hidden");
        document.getElementById("user-overlay").classList.add("hidden");
        await refreshAllData();
        initBacklogUI(); // Initialize backlog event listeners
        startLiveSync(); // Start live sync after successful login
      }
    });

    async function refreshAllData(silent = false) {
      await refreshCalendarAndMonthlyGoals();
      updateLastSyncTime();
      // Any other global refresh
    }

    function updateLastSyncTime() {
      const el = document.getElementById("last-sync-time");
      if (el) {
        const now = new Date();
        const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        el.textContent = `Synced ${timeStr}`;
      }
    }

    function pillarsStorageKey(userId) {
      return `wrapsheet-pillars-v1:${userId}`;
    }

    function getEmptyPillars() {
      return { elevate: [], engage: [], evolve: [], excite: [] };
    }

    function loadPillarsForCurrentUser() {
      if (!state.currentUser) {
        state.pillars = getEmptyPillars();
        renderPillars();
        return;
      }

      const key = pillarsStorageKey(state.currentUser.id);
      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          state.pillars = getEmptyPillars();
        } else {
          const parsed = JSON.parse(raw);
          state.pillars = { ...getEmptyPillars(), ...(parsed || {}) };
        }
      } catch {
        state.pillars = getEmptyPillars();
      }

      renderPillars();
    }

    function savePillarsForCurrentUser() {
      if (!state.currentUser) return;
      try {
        localStorage.setItem(pillarsStorageKey(state.currentUser.id), JSON.stringify(state.pillars));
      } catch {
        // ignore
      }
    }

    function clampPercent(n) {
      const v = Number(n);
      if (Number.isNaN(v)) return 0;
      return Math.max(0, Math.min(100, v));
    }

    function computePillarPercent(tasks) {
      if (!Array.isArray(tasks) || !tasks.length) return 0;
      const vals = tasks.map(t => clampPercent(t.progress_percent !== undefined ? t.progress_percent : (t.percent ?? 0)));
      const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
      return Math.round(avg);
    }

    function pillarDisplayName(key) {
      const map = { elevate: "Elevate", engage: "Engage", evolve: "Evolve", excite: "Excite" };
      return map[key] || key;
    }


    function renderPillars() {
      const grid = document.getElementById("pillar-grid");
      if (!grid) return;

      const subtitle = document.getElementById("pillars-subtitle");
      subtitle.textContent = state.currentUser
        ? `Synced for ${state.currentUser.name}`
        : "Pick a user to edit your pillars";

      grid.innerHTML = "";

      const keys = ["elevate", "engage", "evolve", "excite"];

      keys.forEach(pKey => {
        const card = document.createElement("div");
        card.className = `pillar-card ${pKey}`; // Add pillar class for coloring

        const header = document.createElement("div");
        header.className = "pillar-card-header";

        const name = document.createElement("div");
        name.className = "pillar-name";
        name.textContent = pillarDisplayName(pKey);

        const addBtn = document.createElement("button");
        addBtn.className = "pillar-add";
        addBtn.innerHTML = "+";
        addBtn.title = "Add Task";
        addBtn.disabled = !state.currentUser;
        addBtn.addEventListener("click", () => openPillarModal(pKey));

        header.appendChild(name);
        header.appendChild(addBtn);

        const box = document.createElement("div");
        box.className = "pillar-box";

        // 1. Legacy Tasks (Local Storage)
        const legacy = (state.pillars && state.pillars[pKey]) ? state.pillars[pKey] : [];

        // 2. API Tasks (Promoted/Active)
        // Filter by pillar. Show all active + suggested that were returned.
        // Use lowercase comparison to handle DB case mismatches
        const apiTasks = state.promotedSuggestions ? state.promotedSuggestions.filter(s => (s.pillar || "").toLowerCase() === pKey) : [];

        // Combine (Legacy first so they sit at top until deleted/migrated, or bottom? Let's put API first as they are "real")
        // User asked for "Erica's pillars", which are likely API grounded now.
        const allTasks = [...apiTasks, ...legacy];

        if (!allTasks.length) {
          const empty = document.createElement("div");
          empty.className = "pillar-empty";
          empty.textContent = "No tasks yet.\nClick + Add to create one.";
          box.appendChild(empty);
        } else {
          allTasks.forEach(t => {
            const row = document.createElement("div");
            row.className = "pillar-task-row";
            if (t.status === 'suggested') row.classList.add("promo"); // visual distinction

            const title = document.createElement("div");
            title.className = "pillar-task-title";
            title.textContent = t.title || "(Untitled)";

            // Determine fields
            const assignedId = t.assigned_to_id;
            const assignedUser = state.users.find(u => String(u.id) === String(assignedId));

            const isApi = !!t.status;
            const voteTxt = t.vote_count ? ` · Votes: ${t.vote_count}` : "";
            const statusTxt = t.status ? ` · ${t.status.toUpperCase()}` : "";

            const pct = clampPercent(t.progress_percent !== undefined ? t.progress_percent : (t.percent || 0));
            const eta = t.eta_date || t.eta || "—";
            const bench = t.description || t.benchmark || "—";

            // Meta Line
            const meta = document.createElement("div");
            meta.className = "pillar-task-meta";

            if (isApi) {
              // API Style: Status, Votes, Progress
              meta.innerHTML = `Assigned: <b>${assignedUser ? assignedUser.name : "—"}</b>${statusTxt}${voteTxt}<br>` +
                `Progress: ${pct}% · ETA: ${eta}`;
            } else {
              // Legacy Style
              meta.innerHTML = `Assigned: <b>${assignedUser ? assignedUser.name : "—"}</b><br>` +
                `Benchmark: ${bench}<br>` +
                `Percent: ${pct}% · ETA: ${eta}`;
            }

            row.appendChild(title);
            row.appendChild(meta);

            row.addEventListener("click", () => openPillarModal(pKey, t));
            box.appendChild(row);
          });
        }

        const circleWrap = document.createElement("div");
        circleWrap.className = "pillar-circle-wrap";

        const circle = document.createElement("div");
        circle.className = "pillar-circle";

        const pct = computePillarPercent(allTasks);
        circle.innerHTML = `<div><strong>${pct}%</strong><span>Percentage of goal<br>complete</span></div>`;

        circleWrap.appendChild(circle);

        card.appendChild(header);
        card.appendChild(box);
        card.appendChild(circleWrap);

        grid.appendChild(card);
      });
    }

    function populatePillarAssignedToSelect() {
      const sel = document.getElementById("pillar-task-assigned-to");
      if (!sel) return;
      sel.innerHTML = "";
      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = String(u.id);
        opt.textContent = u.name;
        sel.appendChild(opt);
      });
    }

    function editPromotedTask(task) {
      if (!task) return;
      // Simple interaction for now. Could be a full modal.
      const action = prompt(`Edit Board Idea: "${task.title}"\n\nEnter new progress notes (or keep existing).\nPrefix with [COMPLETE] to mark done.`);
      if (action === null) return;

      let status = task.status === 'suggested' ? 'active' : task.status;
      let notes = action;

      if (action.startsWith("[COMPLETE]")) {
        status = 'completed';
        notes = action.replace("[COMPLETE]", "").trim();
      }

      showActionLoader();
      apiSend(`/pillar-suggestions/${task.id}`, "PATCH", {
        progress_notes: notes,
        status: status
      }).then(() => {
        showToast("Board Idea updated");
        refreshAllData();
      }).catch(err => {
        console.error(err);
        showToast("Error updating idea", true);
      }).finally(hideActionLoader);
    }

    function populatePillarAssignedToSelect() {
      const select = document.getElementById("pillar-task-assigned-to");
      if (!select) return;
      // Only repopulate if empty or needed, but straightforward to just wipe
      select.innerHTML = "";
      if (state.users && state.users.length) {
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = u.id;
          opt.textContent = u.name;
          select.appendChild(opt);
        });
      }
    }

    function openPillarModal(pillarKey, task = null) {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return;
      }

      populatePillarAssignedToSelect();

      const modal = document.getElementById("pillar-modal");
      const idEl = document.getElementById("pillar-task-id");
      const keyEl = document.getElementById("pillar-key");
      const titleEl = document.getElementById("pillar-task-title");
      const assignedEl = document.getElementById("pillar-task-assigned-to");
      const benchEl = document.getElementById("pillar-task-benchmark");
      const percentEl = document.getElementById("pillar-task-percent");
      const etaEl = document.getElementById("pillar-task-eta");
      const deleteBtn = document.getElementById("pillar-task-delete");

      keyEl.value = pillarKey;

      if (task) {
        idEl.value = task.id;
        titleEl.value = task.title || "";
        assignedEl.value = String(task.assigned_to_id || state.currentUser.id);

        // Unified field mapping (API uses description/progress_percent/eta_date)
        benchEl.value = task.description || task.benchmark || "";
        percentEl.value = clampPercent(task.progress_percent !== undefined ? task.progress_percent : task.percent);
        etaEl.value = task.eta_date || task.eta || "";
        document.getElementById("pillar-task-notes").value = task.progress_notes || "";

        document.getElementById("pillar-modal-title").textContent = "Edit Pillar Task";
        // Show status if available
        const statusTxt = task.status ? ` · ${task.status.toUpperCase()}` : "";
        document.getElementById("pillar-modal-meta").textContent = `${pillarDisplayName(pillarKey)} • ${task.id}${statusTxt}`;
        deleteBtn.style.display = "inline-flex";
      } else {
        idEl.value = "";
        titleEl.value = "";
        assignedEl.value = String(state.currentUser.id);
        benchEl.value = "";
        percentEl.value = "0";
        etaEl.value = "";
        document.getElementById("pillar-task-notes").value = "";

        document.getElementById("pillar-modal-title").textContent = "New Pillar Task";
        document.getElementById("pillar-modal-meta").textContent = pillarDisplayName(pillarKey);
        deleteBtn.style.display = "none";
      }

      modal.classList.remove("hidden");
    }

    function closePillarModal() {
      document.getElementById("pillar-modal").classList.add("hidden");
    }

    function getPillarTasks(pillarKey) {
      if (!state.pillars) state.pillars = getEmptyPillars();
      if (!Array.isArray(state.pillars[pillarKey])) state.pillars[pillarKey] = [];
      return state.pillars[pillarKey];
    }

    function genPillarTaskId() {
      return "pt_" + Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    async function savePillarTaskFromModal() {
      const id = document.getElementById("pillar-task-id").value;
      const pillarKey = document.getElementById("pillar-key").value;

      const title = document.getElementById("pillar-task-title").value.trim();
      const assignedToId = document.getElementById("pillar-task-assigned-to").value; // Keep as string or int
      const benchmark = document.getElementById("pillar-task-benchmark").value.trim();
      const percent = clampPercent(document.getElementById("pillar-task-percent").value);
      const eta = document.getElementById("pillar-task-eta").value;
      const notes = document.getElementById("pillar-task-notes").value.trim();

      if (!title) {
        showToast("Task title is required", true);
        return;
      }
      if (!assignedToId) {
        showToast("Assigned to is required", true);
        return;
      }

      const payload = {
        title: title || "",
        description: benchmark || "",
        category: "General", // Ensure field exists for DB binding
        pillar: (pillarKey || "").toLowerCase(),
        status: 'active',
        source: 'staff', // Mark as staff-created (shows in Staff Core Pillars, not Board Ideas)
        assigned_to_id: assignedToId || null,
        created_by_id: (state.currentUser && state.currentUser.id) ? state.currentUser.id : null,
        progress_percent: percent || 0,
        eta_date: eta || null,
        progress_notes: notes || ""
      };

      try {
        if (id && !id.startsWith("pt_")) {
          // Edit API Item
          await apiSend(`/pillar-suggestions/${id}`, "PATCH", payload);
        } else {
          // Create New (or ignore legacy ID if we can't migrate easily, assume create new)
          // If it was a legacy item (pt_), we create a new DB item. 
          // Realistically we should delete the local one too, but let's just create new for now.
          payload.created_by_id = state.currentUser.id;
          await apiSend("/pillar-suggestions", "POST", payload);
        }

        await refreshAllData(); // Reloads promoted suggestions
        closePillarModal();
        showToast("Pillar task saved to DB");
      } catch (e) {
        console.error(e);
        showToast("Error saving task", true);
      }
    }

    async function deletePillarTaskFromModal() {
      const id = document.getElementById("pillar-task-id").value;
      const pillarKey = document.getElementById("pillar-key").value;
      if (!id) return;

      if (!confirm("Delete this pillar task?")) return;

      try {
        if (id.startsWith("pt_")) {
          // Legacy local delete
          const tasks = getPillarTasks(pillarKey);
          const next = tasks.filter(t => String(t.id) !== String(id));
          state.pillars[pillarKey] = next;
          savePillarsForCurrentUser();
          renderPillars();
        } else {
          // API Delete
          await fetch(`${API_BASE}/pillar-suggestions/${id}`, { method: "DELETE" });
          await refreshAllData();
        }

        closePillarModal();
        showToast("Pillar task deleted");
      } catch (e) {
        console.error(e);
        showToast("Error deleting task", true);
      }
    }



    async function loadUsers() {
      const allUsers = await apiGet("/users");
      // Filter to only show core BER staff
      const allowedNames = ["kevin", "meighan", "jenna", "erica", "katie"];
      state.users = allUsers.filter(u =>
        allowedNames.some(name => u.name.toLowerCase() === name)
      );
      populateUserSelects();
    }

    function populateUserSelects() {
      const userSelect = document.getElementById("user-select");
      userSelect.innerHTML = '<option value="">Select your name…</option>';
      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = u.id;
        opt.textContent = u.name;
        userSelect.appendChild(opt);
      });

      const monthlyOwnerFilter = document.getElementById("monthly-owner-filter");
      const annualOwnerFilter = document.getElementById("annual-owner-filter");
      [monthlyOwnerFilter, annualOwnerFilter].forEach(sel => {
        while (sel.options.length > 1) sel.remove(1); // keep "Everyone"
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = String(u.id);
          opt.textContent = u.name;
          sel.appendChild(opt);
        });
      });

      const taskAssignedTo = document.getElementById("task-assigned-to");
      taskAssignedTo.innerHTML = "";

      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = u.id;
        opt.textContent = u.name;
        taskAssignedTo.appendChild(opt);
      });

      // NEW: multi-assignee select
      const taskAssignees = document.getElementById("task-assignees");
      if (taskAssignees) {
        taskAssignees.innerHTML = "";
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = u.id;
          opt.textContent = u.name;
          taskAssignees.appendChild(opt);
        });
      }

    }

    function populateCalendarOwnerSelect() {
      const sel = document.getElementById("calendar-owner-select");
      if (!sel) return;
      sel.innerHTML = "";
      if (!state.currentUser) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Select user…";
        sel.appendChild(opt);
        sel.disabled = true;
        return;
      }
      sel.disabled = false;

      const mine = document.createElement("option");
      mine.value = "me";
      mine.textContent = "My Tasks";
      sel.appendChild(mine);

      const all = document.createElement("option");
      all.value = "all";
      all.textContent = "All Team";
      sel.appendChild(all);

      state.users.forEach(u => {
        const opt = document.createElement("option");
        opt.value = String(u.id);
        opt.textContent = u.name;
        sel.appendChild(opt);
      });

      sel.value = "me";
    }

    function restoreUserFromStorage() {
      const stored = localStorage.getItem("wrapsheet-user");
      if (!stored) return;
      const parsed = JSON.parse(stored);
      const found = state.users.find(u => u.id === parsed.id);
      if (found) setCurrentUser(found);
    }

    function setCurrentUser(user) {
      state.currentUser = user;
      document.getElementById("current-user-label").textContent =
        user ? user.name + " · " + user.email : "Not signed in";
      if (user) {
        localStorage.setItem("wrapsheet-user", JSON.stringify({ id: user.id }));
        document.getElementById("monthly-owner-filter").value = "all";
        document.getElementById("annual-owner-filter").value = "all";
        state.calendarOwnerId = user.id;
        populateCalendarOwnerSelect();
        setActiveUser(user.id);
        loadPillarsForCurrentUser();
      }
    }

    // ===== EVENT HANDLERS =====
    function attachEventHandlers() {
      const themeSelect = document.getElementById("theme-select");
      if (themeSelect) {
        themeSelect.addEventListener("change", () => {
          applyTheme(themeSelect.value);
        });
      }
      // User overlay
      document.getElementById("user-select-confirm").addEventListener("click", async () => {
        const id = parseInt(document.getElementById("user-select").value, 10);
        if (!id) {
          showToast("Please pick your name");
          return;
        }
        const user = state.users.find(u => u.id === id);
        if (!user) return;
        setCurrentUser(user);
        document.getElementById("user-overlay").classList.add("hidden");
        await refreshAllData();
        startLiveSync(); // Start live sync after user login
      });

      document.getElementById("switch-user-btn").addEventListener("click", () => {
        stopLiveSync(); // Stop live sync when switching users
        document.getElementById("user-overlay").classList.remove("hidden");
      });

      // Calendar view switcher
      const calendarViewSelect = document.getElementById("calendar-view-select");
      calendarViewSelect.addEventListener("change", async () => {
        state.calendarView = calendarViewSelect.value;
        saveUserDbPreference("calendar_view", state.calendarView);
        await refreshCalendarAndMonthlyGoals(); // reloads tasks for the visible range
      });


      // Calendar owner (whose calendar you are viewing)
      const calendarOwnerSelect = document.getElementById("calendar-owner-select");

      calendarOwnerSelect.addEventListener("change", async () => {
        const val = calendarOwnerSelect.value;

        if (val === "me") {
          state.calendarOwnerId = state.currentUser?.id ?? null;
          await setActiveUser(state.currentUser?.id ?? null);
        } else if (val === "all") {
          state.calendarOwnerId = null;        // IMPORTANT
          await setActiveUser(null);
        } else {
          const uid = parseInt(val, 10);
          state.calendarOwnerId = Number.isNaN(uid) ? null : uid;   // IMPORTANT
          await setActiveUser(state.calendarOwnerId);
        }

        await loadDailyTasks();
      });



      // Navigation: prev/next
      document.getElementById("month-prev").addEventListener("click", async () => {
        const d = state.currentMonthDate;
        if (state.calendarView === "month") {
          state.currentMonthDate = new Date(d.getFullYear(), d.getMonth() - 1, 1);
        } else {
          state.currentMonthDate = addDays(d, -7);
        }
        await refreshCalendarAndMonthlyGoals();
      });

      document.getElementById("month-next").addEventListener("click", async () => {
        const d = state.currentMonthDate;
        if (state.calendarView === "month") {
          state.currentMonthDate = new Date(d.getFullYear(), d.getMonth() + 1, 1);
        } else {
          state.currentMonthDate = addDays(d, 7);
        }
        await refreshCalendarAndMonthlyGoals();
      });

      // Goals tabs
      document.querySelectorAll(".goals-tab").forEach(btn => {
        btn.addEventListener("click", () => {
          const tab = btn.dataset.tab;
          document.querySelectorAll(".goals-tab").forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          if (tab === "monthly") {
            document.getElementById("monthly-goals-panel").style.display = "";
            document.getElementById("annual-goals-panel").style.display = "none";
          } else {
            document.getElementById("monthly-goals-panel").style.display = "none";
            document.getElementById("annual-goals-panel").style.display = "";
          }
        });
      });

      // Monthly goals: month input
      const monthlyMonthInput = document.getElementById("monthly-month-input");
      monthlyMonthInput.addEventListener("change", async () => {
        if (!monthlyMonthInput.value) return;
        const [year, month] = monthlyMonthInput.value.split("-").map(Number);
        state.currentMonthDate = new Date(year, month - 1, 1);
        await refreshCalendarAndMonthlyGoals();
      });

      // Owner filters (goals)
      document.getElementById("monthly-owner-filter").addEventListener("change", () => {
        state.monthlyOwnerFilter = document.getElementById("monthly-owner-filter").value;
        renderMonthlyGoals();
      });

      document.getElementById("annual-owner-filter").addEventListener("change", () => {
        state.annualOwnerFilter = document.getElementById("annual-owner-filter").value;
        renderAnnualGoals();
      });

      // Annual year input
      const annualYearInput = document.getElementById("annual-year-input");
      const thisYear = new Date().getFullYear();
      for (let y = thisYear - 1; y <= thisYear + 4; y++) {
        const opt = document.createElement("option");
        opt.value = y;
        opt.textContent = y;
        if (y === thisYear) opt.selected = true;
        annualYearInput.appendChild(opt);
      }
      annualYearInput.addEventListener("change", async () => {
        state.annualYear = parseInt(annualYearInput.value, 10);
        await loadAnnualGoals();
      });

      // Task modal controls
      document.getElementById("task-modal-close").addEventListener("click", closeTaskModal);
      document.getElementById("task-modal-cancel").addEventListener("click", closeTaskModal);
      document.getElementById("task-save-btn").addEventListener("click", onTaskSave);
      document.getElementById("task-delete-btn").addEventListener("click", onTaskDelete);

      // Project Step Modal listeners
      document.getElementById("project-step-modal-close").addEventListener("click", () => document.getElementById("project-step-modal").classList.add("hidden"));
      document.getElementById("project-step-modal-cancel").addEventListener("click", () => document.getElementById("project-step-modal").classList.add("hidden"));
      document.getElementById("project-step-save-btn").addEventListener("click", saveProjectStepFromModal);


      // Enter key to save task in modal
      const taskModal = document.getElementById("task-modal");
      taskModal.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          // Don't trigger on textarea (allow Enter for new lines there)
          if (e.target.tagName === "TEXTAREA") return;
          e.preventDefault();
          document.getElementById("task-save-btn").click();
        }
      });

      // Pillar modal controls
      document.getElementById("pillar-modal-close").addEventListener("click", closePillarModal);
      document.getElementById("pillar-modal-cancel").addEventListener("click", closePillarModal);
      document.getElementById("pillar-task-save").addEventListener("click", savePillarTaskFromModal);
      document.getElementById("pillar-task-delete").addEventListener("click", deletePillarTaskFromModal);

      // Joint Projects
      document.getElementById("add-project-btn").addEventListener("click", createNewProject);

      // Suggestion Modal (Board Ideas)
      // Suggestion Modal (Board Ideas)
      document.getElementById("suggestion-modal-close")?.addEventListener("click", () => {
        document.getElementById("suggestion-modal").classList.add("hidden");
      });
      document.getElementById("suggestion-modal-cancel")?.addEventListener("click", () => {
        document.getElementById("suggestion-modal").classList.add("hidden");
      });
      document.getElementById("suggestion-save-btn")?.addEventListener("click", saveSuggestionFromModal);


      // Weekly Tasks (BETA)
      document.getElementById("add-weekly-task-btn").addEventListener("click", () => {
        const input = document.getElementById("new-weekly-task-input");
        const title = input.value.trim();
        if (title) {
          createWeeklyTask(title);
          input.value = "";
        }
      });
      document.getElementById("new-weekly-task-input").addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          document.getElementById("add-weekly-task-btn").click();
        }
      });
      document.getElementById("week-prev").addEventListener("click", async () => {
        state.currentWeekKey = shiftWeek(state.currentWeekKey, -1);
        await loadWeeklyTasks();
      });
      document.getElementById("week-next").addEventListener("click", async () => {
        state.currentWeekKey = shiftWeek(state.currentWeekKey, 1);
        await loadWeeklyTasks();
      });

    }

    // --- Suggestion Modal Logic ---

    function editPromotedTask(task) {
      if (!task) return;

      const modal = document.getElementById("suggestion-modal");
      document.getElementById("suggestion-modal-title").textContent = task.title;
      document.getElementById("suggestion-id").value = task.id;
      document.getElementById("suggestion-status").value = task.status;

      // Parse metadata from notes if present
      // Format: "Real notes... [PROGRESS: 50] [ETA: 2026-01-30]"
      let notes = task.progress_notes || "";
      let percent = 0;
      let eta = "";

      const progMatch = notes.match(/\[PROGRESS:\s*(\d+)\]/);
      if (progMatch) {
        percent = parseInt(progMatch[1], 10);
        notes = notes.replace(progMatch[0], "").trim();
      }

      const etaMatch = notes.match(/\[ETA:\s*([^\]]+)\]/);
      if (etaMatch) {
        eta = etaMatch[1];
        notes = notes.replace(etaMatch[0], "").trim();
      }

      // If we have real DB fields eventually, check them too
      if (task.progress_percent) percent = task.progress_percent;
      if (task.eta_date) eta = task.eta_date;

      document.getElementById("suggestion-notes").value = notes;
      document.getElementById("suggestion-percent").value = percent;
      document.getElementById("suggestion-percent-val").textContent = percent + "%";
      document.getElementById("suggestion-eta").value = eta;

      modal.classList.remove("hidden");
    }

    async function saveSuggestionFromModal() {
      const id = document.getElementById("suggestion-id").value;
      const rawNotes = document.getElementById("suggestion-notes").value.trim();
      const percent = document.getElementById("suggestion-percent").value;
      const eta = document.getElementById("suggestion-eta").value;
      const status = document.getElementById("suggestion-status").value;

      let finalNotes = rawNotes;
      // Append metadata tags
      if (percent > 0) finalNotes += ` [PROGRESS: ${percent}]`;
      if (eta) finalNotes += ` [ETA: ${eta}]`;

      showActionLoader();
      try {
        // Send both the compound notes AND the direct fields (future proofing)
        await apiSend(`/pillar-suggestions/${id}`, "PATCH", {
          progress_notes: finalNotes,
          progress_percent: parseInt(percent, 10), // Send just in case backend supports it
          eta_date: eta, // Send just in case
          status: status,
          assigned_to_id: state.currentUser?.id // Auto-assign to me if editing
        });

        showToast("Board Idea updated");
        document.getElementById("suggestion-modal").classList.add("hidden");
        refreshAllData();
      } catch (err) {
        console.error(err);
        showToast("Error updating idea", true);
      } finally {
        hideActionLoader();
      }
    }

    // ===== DATA REFRESH =====
    async function refreshAllData(silent = false) {
      await refreshCalendarAndMonthlyGoals();
      await loadAnnualGoals();
      await loadProjects();
      await loadUserDbPreferences();
      await loadPromotedSuggestions(); // New
      initWeeklyTasksUI();
      updateLastSyncTime();

      // Initialize coin reward system for eligible users
      if (isRewardEligible()) {
        loadCoinBalance();
      }
    }

    // Fetch top suggestions assigned to current user
    async function loadPromotedSuggestions() {
      if (!state.currentUser) return;
      try {
        // Fetch ALL suggestions (team view) instead of just mine. 
        // passing userId ensures 'vote_count' or 'liked_by_me' logic works if backend supports it.
        // Reverted to fetching ONLY assigned to me, per user request "Each user should see only THEIR assigned item"
        const res = await apiGet(`/pillar-suggestions?assignedTo=${state.currentUser.id}&limit=100&status=all`);

        if (Array.isArray(res)) {
          state.promotedSuggestions = res;
        } else {
          state.promotedSuggestions = [];
        }
        renderPillars(); // Re-render to show suggestions
      } catch (e) {
        console.warn("Failed to load promoted suggestions", e);
        state.promotedSuggestions = [];
        renderPillars();
      }
    }



    // ===== BACKLOG LOGIC =====
    async function loadBacklogTasks() {
      try {
        let targetId = state.calendarOwnerId;
        // If no filter selected (My Tasks), default to current user
        if (!targetId && state.currentUser) {
          targetId = state.currentUser.id;
        }

        let path = "/daily-tasks?month=1900-01"; // Backlog Month

        if (targetId) {
          path += "&assignedToId=" + encodeURIComponent(targetId);
        } else {
          // If we really don't have a user (not logged in?), maybe we fetch nothing? 
          // Or fetch all (unsafe). Let's assume fetch all is fallback but we prefer isolation.
          // The user requested strict isolation.
          if (state.currentUser) {
            path += "&assignedToId=" + encodeURIComponent(state.currentUser.id);
          }
        }

        const tasks = await apiGet(path);
        // Dedupe
        const merged = [];
        const seen = new Set();
        tasks.forEach(t => {
          if (!seen.has(t.id)) { seen.add(t.id); merged.push(t); }
        });

        state.backlogTasks = merged;
        renderBacklog();
      } catch (err) {
        console.warn("Error loading backlog", err);
        state.backlogTasks = [];
        renderBacklog();
      }
    }

    function renderBacklog() {
      const container = document.getElementById("backlog-list");
      const empty = document.getElementById("backlog-empty");
      if (!container) return;
      container.innerHTML = "";

      if (!state.backlogTasks || state.backlogTasks.length === 0) {
        if (empty) empty.style.display = "block";
        return;
      }
      if (empty) empty.style.display = "none";

      state.backlogTasks.forEach(task => {
        const pill = buildTaskPill(task);
        container.appendChild(pill);
      });
    }

    async function checkAndMigrateOverdueTasks() {
      if (state.hasCheckedOverdue) return;
      state.hasCheckedOverdue = true;

      const today = new Date();
      const todayKey = dateKey(today.getFullYear(), today.getMonth(), today.getDate());

      const overdue = state.dailyTasks.filter(t => {
        return t.task_date < todayKey && t.task_date !== BACKLOG_DATE &&
          t.status !== 'done' && t.status !== 'could_not_complete';
      });

      if (overdue.length === 0) return;

      showActionLoader({ main: "Organizing...", sub: `Moving ${overdue.length} overdue tasks to backlog` });

      try {
        await Promise.all(overdue.map(t =>
          apiSend(`/daily-tasks/${t.id}`, "PATCH", { task_date: BACKLOG_DATE })
        ));

        showToast(`Moved ${overdue.length} tasks to backlog`);
        await Promise.all([loadDailyTasks(), loadBacklogTasks()]);
      } catch (err) {
        console.error("Migration failed", err);
      } finally {
        hideActionLoader();
      }
    }

    function initBacklogUI() {
      const section = document.getElementById("section-backlog");
      const container = document.getElementById("backlog-container");
      const addBtn = document.getElementById("add-backlog-btn");
      const input = document.getElementById("new-backlog-input");

      if (container) {
        container.addEventListener("dragover", onDayDragOver);
        container.addEventListener("dragenter", onDayDragEnter);
        container.addEventListener("dragleave", onDayDragLeave);
        container.addEventListener("drop", onBacklogDrop);
      }

      if (addBtn && input) {
        const handler = async () => {
          const val = input.value.trim();
          if (!val) return;
          if (!state.currentUser) {
            showToast("Who are you?", true);
            return;
          }

          try {
            await apiSend("/daily-tasks", "POST", {
              title: val,
              task_date: BACKLOG_DATE,
              assigned_to_id: state.currentUser.id,
              created_by_id: state.currentUser.id,
              assigned_by_id: state.currentUser.id,
              status: "pending"
            });
            input.value = "";
            showToast("Added to backlog");
            await loadBacklogTasks();
          } catch (e) {
            console.error(e);
            showToast("Error adding to backlog", true);
          }
        };

        addBtn.addEventListener("click", handler);
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") handler();
        });
      }
    }

    function onBacklogDrop(e) {
      if (!dragState.taskId) return;
      e.preventDefault();
      const el = document.getElementById("backlog-container");
      if (el) el.classList.remove("drop-target");

      const inBacklog = state.backlogTasks.find(t => String(t.id) === String(dragState.taskId));
      if (inBacklog) return;

      moveTaskToDate(dragState.taskId, BACKLOG_DATE);
    }

    async function refreshCalendarAndMonthlyGoals() {
      updateMonthLabel();
      setMonthInputsFromState();
      await Promise.all([
        loadDailyTasks(),
        loadMonthlyGoals(),
        loadBacklogTasks() // NEW
      ]);
      await checkAndMigrateOverdueTasks(); // Auto-migrate overdue
    }

    function updateMonthLabel() {
      const labelEl = document.getElementById("month-label");
      const d = state.currentMonthDate;
      if (state.calendarView === "month") {
        const monthName = d.toLocaleString("default", { month: "long" });
        labelEl.textContent = monthName + " " + d.getFullYear();
      } else {
        const isWorkweek = state.calendarView === "workweek" || state.calendarView === "jointweek";
        const weekStart = getWeekStart(d, isWorkweek);
        const weekEnd = addDays(weekStart, isWorkweek ? 4 : 6);
        const startLabel = weekStart.toLocaleString("default", {
          month: "short",
          day: "numeric"
        });
        const endLabel = weekEnd.toLocaleString("default", {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
        labelEl.textContent = `${startLabel} – ${endLabel}`;
      }
    }

    function setMonthInputsFromState() {
      const d = state.currentMonthDate;
      const monthVal = d.getFullYear() + "-" + pad2(d.getMonth() + 1);
      document.getElementById("monthly-month-input").value = monthVal;
    }

    async function loadDailyTasks() {
      try {
        const [startKey, endKey] = getVisibleDateRange();

        const startMonth = startKey.slice(0, 7);
        const endMonth = endKey.slice(0, 7);
        const months = startMonth === endMonth ? [startMonth] : [startMonth, endMonth];

        const ownerFilterOn = state.calendarOwnerId !== null && state.calendarOwnerId !== undefined;

        const results = await Promise.all(months.map(mk => {
          let path = "/daily-tasks?month=" + encodeURIComponent(mk);
          if (ownerFilterOn) path += "&assignedToId=" + encodeURIComponent(state.calendarOwnerId);
          return apiGet(path);
        }));

        // merge + dedupe by id
        const merged = [];
        const seen = new Set();
        results.flat().forEach(t => {
          if (!seen.has(t.id)) { seen.add(t.id); merged.push(t); }
        });

        state.dailyTasks = merged;
        renderCalendar();
      } catch (err) {
        console.error(err);
        showToast("Error loading daily tasks", true);
      }
    }



    async function loadMonthlyGoals() {
      const mk = monthKeyFromDate(state.currentMonthDate);
      try {
        const goals = await apiGet("/monthly-goals?month=" + encodeURIComponent(mk));
        state.monthlyGoals = goals;
        renderMonthlyGoals();
      } catch (err) {
        console.error(err);
        showToast("Error loading monthly goals", true);
      }
    }

    async function loadAnnualGoals() {
      try {
        const goals = await apiGet("/annual-goals?year=" + encodeURIComponent(state.annualYear));
        state.annualGoals = goals;
        renderAnnualGoals();
      } catch (err) {
        console.error(err);
        showToast("Error loading annual goals", true);
      }
    }

    function buildDayCell(key, displayDayNumber, todayKey, tasksByDate) {
      const cell = document.createElement("div");
      cell.className = "day-cell";
      cell.dataset.dateKey = key;
      if (key === todayKey) cell.classList.add("is-today");

      // Drop targets for drag & drop
      cell.addEventListener("dragover", onDayDragOver);
      cell.addEventListener("dragenter", onDayDragEnter);
      cell.addEventListener("dragleave", onDayDragLeave);
      cell.addEventListener("drop", onDayDrop);

      const header = document.createElement("div");
      header.className = "day-header";

      const num = document.createElement("div");
      num.className = "day-number";
      num.textContent = displayDayNumber;
      header.appendChild(num);

      const addBtn = document.createElement("button");
      addBtn.className = "add-task-btn";
      addBtn.textContent = "+";
      addBtn.title = "Add task";
      addBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        openTaskModalForDate(key);
      });
      header.appendChild(addBtn);

      cell.appendChild(header);

      const list = document.createElement("div");
      list.className = "tasks-list";
      const tasks = tasksByDate[key] || [];
      tasks.forEach(task => {
        const pill = buildTaskPill(task);
        list.appendChild(pill);
      });

      cell.appendChild(list);
      return cell;
    }



    function renderCalendar() {
      const weekdaysEl = document.getElementById("calendar-weekdays");
      const container = document.getElementById("calendar-days");
      weekdaysEl.innerHTML = "";
      container.innerHTML = "";

      const d = state.currentMonthDate;
      const year = d.getFullYear();
      const monthIndex = d.getMonth();
      const today = new Date();
      const todayKey = dateKey(today.getFullYear(), today.getMonth(), today.getDate());

      const tasksByDate = {};
      state.dailyTasks.forEach(t => {
        const key = t.task_date;
        if (!tasksByDate[key]) tasksByDate[key] = [];
        tasksByDate[key].push(t);
      });

      if (state.calendarView === "month") {
        const weekdayLabels = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        weekdayLabels.forEach(label => {
          const div = document.createElement("div");
          div.textContent = label;
          weekdaysEl.appendChild(div);
        });
        weekdaysEl.style.gridTemplateColumns = "repeat(7, minmax(0, 1fr))";
        container.style.gridTemplateColumns = "repeat(7, minmax(0, 1fr))";

        const firstDay = new Date(year, monthIndex, 1);
        const firstWeekday = firstDay.getDay();
        const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();

        for (let i = 0; i < firstWeekday; i++) {
          const emptyCell = document.createElement("div");
          emptyCell.className = "day-cell day-cell-empty";
          container.appendChild(emptyCell);
        }

        for (let day = 1; day <= daysInMonth; day++) {
          const key = dateKey(year, monthIndex, day);
          const cell = buildDayCell(key, day, todayKey, tasksByDate);
          container.appendChild(cell);
        }
      } else {
        const isWorkweek = state.calendarView === "workweek" || state.calendarView === "jointweek";
        const weekStart = getWeekStart(d, isWorkweek);
        const labels = isWorkweek
          ? ["Mon", "Tue", "Wed", "Thu", "Fri"]
          : ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const daysCount = isWorkweek ? 5 : 7;

        labels.forEach(label => {
          const div = document.createElement("div");
          div.textContent = label;
          weekdaysEl.appendChild(div);
        });
        weekdaysEl.style.gridTemplateColumns = `repeat(${daysCount}, minmax(0, 1fr))`;
        container.style.gridTemplateColumns = `repeat(${daysCount}, minmax(0, 1fr))`;

        for (let i = 0; i < daysCount; i++) {
          const dateObj = addDays(weekStart, i);
          const key = dateKey(
            dateObj.getFullYear(),
            dateObj.getMonth(),
            dateObj.getDate()
          );
          const dayNumber = dateObj.getDate();
          const cell = buildDayCell(key, dayNumber, todayKey, tasksByDate);
          container.appendChild(cell);
        }
      }

      updateStatusChart();
    }

    function buildTaskPill(task) {
      const pill = document.createElement("div");
      pill.className = "task-pill";
      // Identify backlog items specifically or just generic
      if (task.task_date === BACKLOG_DATE) {
        pill.classList.add("backlog-pill");
        // Removed explicit width 100% to let grid handle it
      }

      // DRAGGABLE
      pill.draggable = true;
      pill.dataset.taskId = task.id;
      pill.dataset.date = task.task_date;
      pill.addEventListener("dragstart", onTaskDragStart);
      pill.addEventListener("dragend", onTaskDragEnd);

      const statusVal = task.status || "pending";

      const dot = document.createElement("div");
      dot.className = "task-status-dot";
      dot.classList.add("task-status-" + statusVal);
      pill.appendChild(dot);

      if (statusVal === "done") {
        pill.classList.add("completed");
      } else if (statusVal === "could_not_complete") {
        pill.classList.add("blocked");
      }

      const title = document.createElement("div");
      title.className = "task-title";
      title.textContent = task.title;
      pill.appendChild(title);

      const assignee = document.createElement("div");
      assignee.className = "task-assignee";

      // Multi-assignee label: "Name" or "Name +2"
      let assigneeLabel = "";
      if (Array.isArray(task.assignees) && task.assignees.length) {
        const names = task.assignees.map(a => a.name).filter(Boolean);
        if (names.length === 1) {
          assigneeLabel = names[0];
        } else if (names.length > 1) {
          assigneeLabel = names[0] + " +" + (names.length - 1);
        }
      } else {
        const assignedUser = state.users.find(u => u.id === task.assigned_to_id);
        assigneeLabel = assignedUser ? assignedUser.name : "";
      }
      assignee.textContent = assigneeLabel;
      pill.appendChild(assignee);

      // Quick actions
      const quick = document.createElement("div");
      quick.className = "task-quick-actions";

      const quickDone = document.createElement("input");
      quickDone.type = "checkbox";
      quickDone.title = "Mark complete";
      quickDone.checked = statusVal === "done";
      quickDone.addEventListener("click", async (e) => {
        e.stopPropagation();
        const newStatus = quickDone.checked ? "done" : "pending";
        // If in backlog, updating status keeps it in backlog unless it's marked done (maybe we move done items to today? No, stays in backlog)
        await quickUpdateTaskStatus(task, newStatus);
      });

      const quickBlocked = document.createElement("button");
      quickBlocked.type = "button";
      quickBlocked.textContent = "X";
      quickBlocked.title = "Could not complete";
      if (statusVal === "could_not_complete") {
        quickBlocked.classList.add("active");
      }
      quickBlocked.addEventListener("click", async (e) => {
        e.stopPropagation();
        await quickUpdateTaskStatus(task, "could_not_complete");
      });

      quick.appendChild(quickDone);
      quick.appendChild(quickBlocked);
      pill.appendChild(quick);

      pill.addEventListener("click", (e) => {
        e.stopPropagation();
        openTaskModalForExistingTask(task);
      });

      return pill;
    }

    function updateStatusChart() {
      const canvas = document.getElementById("status-pie");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const [startKey, endKey] = getVisibleDateRange();

      let pending = 0;
      let inProgress = 0;
      let done = 0;
      let blocked = 0;

      state.dailyTasks.forEach(t => {
        const date = t.task_date;
        if (!date || date < startKey || date > endKey) return;
        const status = t.status || "pending";
        if (status === "done") done++;
        else if (status === "in_progress") inProgress++;
        else if (status === "could_not_complete") blocked++;
        else pending++;
      });

      const total = pending + inProgress + done + blocked;
      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) / 2 - 4;

      if (!total) {
        ctx.fillStyle = "#6b7280";
        ctx.font = "12px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("No tasks", cx, cy);
        return;
      }

      const segments = [
        { value: pending, color: "rgba(248,250,252,0.3)" },
        { value: inProgress, color: "#12d0c9" },
        { value: done, color: "#22c55e" },
        { value: blocked, color: "#ef4444" }
      ];

      let startAngle = -Math.PI / 2;
      segments.forEach(seg => {
        if (!seg.value) return;
        const sliceAngle = (seg.value / total) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, radius, startAngle, startAngle + sliceAngle);
        ctx.closePath();
        ctx.fillStyle = seg.color;
        ctx.fill();
        startAngle += sliceAngle;
      });

      // Inner circle for donut effect
      ctx.beginPath();
      ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2);
      ctx.closePath();
      const panelBg = getComputedStyle(document.body).getPropertyValue("--panel").trim() || "#ffffff";
      ctx.fillStyle = panelBg;
      ctx.fill();
    }


    function openTaskModalForDate(dateStr) {
      const modal = document.getElementById("task-modal");
      document.getElementById("task-id").value = "";
      document.getElementById("task-title-input").value = "";
      document.getElementById("task-notes-input").value = "";
      document.getElementById("task-status-input").value = "pending";
      document.getElementById("task-time-input").value = ""; // clear scheduled time
      document.getElementById("task-modal-title").textContent = "New Task";
      document.getElementById("task-modal-date").textContent = dateStr;
      document.getElementById("task-delete-btn").style.display = "none";

      const taskAssignedTo = document.getElementById("task-assigned-to");
      const defaultAssigneeId =
        state.calendarOwnerId || (state.currentUser && state.currentUser.id);
      if (defaultAssigneeId) {
        taskAssignedTo.value = String(defaultAssigneeId);
      }

      // NEW: Clear multi-assignee checkboxes
      const container = document.getElementById("task-assignees-container");
      if (container) {
        container.innerHTML = "";
        (state.users || []).forEach(u => {
          const lbl = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.value = u.id;
          lbl.appendChild(cb);
          lbl.appendChild(document.createTextNode(u.name));
          container.appendChild(lbl);
        });
      }

      // NEW: reset repeat fields
      const rt = document.getElementById("task-repeat-type");
      const rs = document.getElementById("task-repeat-start");
      const re = document.getElementById("task-repeat-end");
      if (rt) rt.value = "none";
      if (rs) rs.value = dateStr;   // default series start = this date
      if (re) re.value = "";        // no end set yet

      modal.dataset.date = dateStr;
      modal.classList.remove("hidden");
    }





    function openTaskModalForExistingTask(task) {
      const modal = document.getElementById("task-modal");
      document.getElementById("task-id").value = task.id;
      document.getElementById("task-title-input").value = task.title || "";
      document.getElementById("task-notes-input").value = task.notes || "";
      document.getElementById("task-status-input").value = task.status || "pending";
      document.getElementById("task-time-input").value = task.task_time || ""; // scheduled time
      document.getElementById("task-modal-title").textContent = "Edit Task";
      document.getElementById("task-modal-date").textContent = task.task_date || "";
      const taskAssignedTo = document.getElementById("task-assigned-to");
      taskAssignedTo.value = String(task.assigned_to_id);

      // NEW: preselect multi-assignees checkboxes
      const container = document.getElementById("task-assignees-container");
      if (container) {
        container.innerHTML = "";

        let selectedIds = [];
        if (Array.isArray(task.assignees) && task.assignees.length) {
          selectedIds = task.assignees.map(a => String(a.id));
        } else if (task.assigned_to_id != null) {
          selectedIds = [String(task.assigned_to_id)];
        }

        (state.users || []).forEach(u => {
          const lbl = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.value = u.id;
          if (selectedIds.includes(String(u.id))) {
            cb.checked = true;
          }
          lbl.appendChild(cb);
          lbl.appendChild(document.createTextNode(u.name));
          container.appendChild(lbl);
        });
      }


      document.getElementById("task-delete-btn").style.display = "inline-flex";

      // Existing tasks don’t carry a “series” yet – but you can spin off a new one
      const rt = document.getElementById("task-repeat-type");
      const rs = document.getElementById("task-repeat-start");
      const re = document.getElementById("task-repeat-end");
      if (rt) rt.value = "none";
      if (rs) rs.value = task.task_date || "";
      if (re) re.value = "";

      modal.dataset.date = task.task_date || "";
      modal.classList.remove("hidden");
    }


    function closeTaskModal() {
      document.getElementById("task-modal").classList.add("hidden");
    }

    async function onTaskSave() {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return;
      }
      const id = document.getElementById("task-id").value;
      const title = document.getElementById("task-title-input").value.trim();
      const notes = document.getElementById("task-notes-input").value.trim();
      const status = document.getElementById("task-status-input").value;
      const taskTime = document.getElementById("task-time-input").value || null; // "HH:MM" or null
      const assignedToId = parseInt(document.getElementById("task-assigned-to").value, 10);
      const dateStr = document.getElementById("task-modal").dataset.date;

      const repeatTypeEl = document.getElementById("task-repeat-type");
      const repeatStartEl = document.getElementById("task-repeat-start");
      const repeatEndEl = document.getElementById("task-repeat-end");

      const repeatType = repeatTypeEl ? repeatTypeEl.value : "none";
      const repeatStartStr = repeatStartEl ? repeatStartEl.value : "";
      const repeatEndStr = repeatEndEl ? repeatEndEl.value : "";

      const shouldRepeat =
        repeatType && repeatType !== "none" && repeatEndStr;

      if (!title) {
        showToast("Task title is required", true);
        return;
      }

      if (!assignedToId) {
        showToast("Assigned To is required", true);
        return;
      }

      // NEW: collect multi-assignees
      const container = document.getElementById("task-assignees-container");
      let assigneeIds = [];
      if (container) {
        const checked = container.querySelectorAll("input[type='checkbox']:checked");
        assigneeIds = Array.from(checked).map(cb => parseInt(cb.value, 10));
      }

      console.log("Saving task with status:", status); // Debug log for auto-complete issue

      // Always ensure primary assignee is included
      if (assignedToId && !assigneeIds.includes(assignedToId)) {
        assigneeIds.push(assignedToId);
      }

      const basePayload = {
        title,
        notes,
        status,
        task_time: taskTime, // scheduled time for reminders
        assigned_to_id: assignedToId,
        assignee_ids: assigneeIds
      };

      try {
        if (id) {
          // Editing an existing single task
          await apiSend("/daily-tasks/" + id, "PATCH", basePayload);

          if (shouldRepeat) {
            // Spin off new future tasks based on this date and the series end
            const extraDates = computeRecurringDatesBetween(
              dateStr,
              repeatType,
              repeatStartStr || dateStr,
              repeatEndStr
            );
            if (extraDates.length) {
              const payloads = extraDates.map(d => ({
                ...basePayload,
                task_date: d,
                created_by_id: state.currentUser.id,
                assigned_by_id: state.currentUser.id
              }));
              await createMultipleTasks(payloads, {
                main: "Adding repeated tasks…",
                sub: "Cloning this task into the future"
              });
            }
          }
        } else {
          // Creating new task
          if (!shouldRepeat) {
            await apiSend("/daily-tasks", "POST", {
              ...basePayload,
              task_date: dateStr,
              created_by_id: state.currentUser.id,
              assigned_by_id: state.currentUser.id
            });
          } else {
            const extraDates = computeRecurringDatesBetween(
              dateStr,
              repeatType,
              repeatStartStr || dateStr,
              repeatEndStr
            );
            const allDates = [dateStr, ...extraDates];

            const payloads = allDates.map(d => ({
              ...basePayload,
              task_date: d,
              created_by_id: state.currentUser.id,
              assigned_by_id: state.currentUser.id
            }));

            await createMultipleTasks(payloads, {
              main: "Creating repeated tasks…",
              sub: "Dropping your series onto the Wrap Sheet"
            });
          }
        }

        closeTaskModal();
        await loadDailyTasks();
        showToast(shouldRepeat ? "Task series added" : "Task saved");
      } catch (err) {
        console.error(err);
        showToast("Error saving task", true);
      }
    }




    async function onTaskDelete() {
      const id = document.getElementById("task-id").value;
      if (!id) return;
      if (!confirm("Delete this task?")) return;

      // random delay between 500ms and 2000ms
      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        showActionLoader({
          main: "Deleting…",
          sub: "Cleaning up this task"
        });

        const fetchPromise = fetch(API_BASE + "/daily-tasks/" + id, {
          method: "DELETE"
        });

        const res = await Promise.all([fetchPromise, delayPromise]).then(
          ([res]) => res
        );

        if (!res.ok) throw new Error("Delete failed");

        closeTaskModal();
        await loadDailyTasks();
        showToast("Task deleted");
      } catch (err) {
        console.error(err);
        showToast("Error deleting task (check Worker)", true);
      } finally {
        hideActionLoader();
      }
    }



    // ===== GOALS RENDERING & CRUD =====
    function renderMonthlyGoals() {
      const grid = document.getElementById("monthly-goals-grid");
      grid.innerHTML = "";

      const ownerFilter = state.monthlyOwnerFilter;
      const goals = state.monthlyGoals.filter(g => {
        if (ownerFilter === "all") return true;
        return String(g.owner_id) === ownerFilter;
      });

      const goalsByCategory = {};
      MONTHLY_CATEGORIES.forEach(cat => goalsByCategory[cat] = []);
      goals.forEach(g => {
        if (!goalsByCategory[g.category]) goalsByCategory[g.category] = [];
        goalsByCategory[g.category].push(g);
      });

      MONTHLY_CATEGORIES.forEach(category => {
        const col = document.createElement("div");
        col.className = "goal-column";

        // Editable category title
        const titleInput = document.createElement("input");
        titleInput.type = "text";
        titleInput.className = "goal-column-title-input";
        titleInput.value = getCustomCategoryName("monthly", category);
        titleInput.dataset.originalCategory = category;
        titleInput.dataset.goalType = "monthly";
        titleInput.addEventListener("blur", () => {
          saveCustomCategoryName("monthly", category, titleInput.value.trim());
        });
        titleInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            titleInput.blur();
          }
        });
        col.appendChild(titleInput);

        const list = document.createElement("div");
        const items = goalsByCategory[category] || [];
        items.forEach(goal => {
          const card = document.createElement("div");
          card.className = "goal-card";
          if (goal.is_complete) card.classList.add("completed");

          const topRow = document.createElement("div");
          topRow.className = "goal-row-top";

          const titleInput = document.createElement("input");
          titleInput.className = "goal-title-input";
          titleInput.value = goal.title || "";
          titleInput.placeholder = "Goal title…";
          titleInput.addEventListener("change", () => {
            updateMonthlyGoal(goal.id, { title: titleInput.value.trim() });
          });
          topRow.appendChild(titleInput);

          const ownerTag = document.createElement("div");
          ownerTag.className = "goal-owner-tag";
          const owner = state.users.find(u => u.id === goal.owner_id);
          ownerTag.textContent = owner ? owner.name : "";
          topRow.appendChild(ownerTag);

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.className = "goal-delete-btn";
          deleteBtn.textContent = "Remove";
          deleteBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            await deleteMonthlyGoal(goal.id);
          });
          topRow.appendChild(deleteBtn);

          card.appendChild(topRow);

          const midRow = document.createElement("div");
          midRow.className = "goal-row-middle";

          const progressWrap = document.createElement("div");
          progressWrap.className = "goal-progress";
          const progressLabel = document.createElement("span");
          progressLabel.textContent = "Progress";
          const progressInput = document.createElement("input");
          progressInput.type = "number";
          progressInput.min = "0";
          progressInput.max = "100";
          progressInput.value = goal.progress_percent ?? 0;
          progressInput.addEventListener("change", () => {
            let val = parseFloat(progressInput.value);
            if (isNaN(val)) val = 0;
            if (val < 0) val = 0;
            if (val > 100) val = 100;
            progressInput.value = val;
            updateMonthlyGoal(goal.id, { progress_percent: val });
          });
          const percentSymbol = document.createElement("span");
          percentSymbol.textContent = "%";
          progressWrap.appendChild(progressLabel);
          progressWrap.appendChild(progressInput);
          progressWrap.appendChild(percentSymbol);

          midRow.appendChild(progressWrap);

          const doneLabel = document.createElement("label");
          doneLabel.className = "goal-done-toggle";
          const doneCheckbox = document.createElement("input");
          doneCheckbox.type = "checkbox";
          doneCheckbox.checked = !!goal.is_complete;
          doneCheckbox.addEventListener("change", () => {
            updateMonthlyGoal(goal.id, { is_complete: doneCheckbox.checked ? 1 : 0 });
            if (doneCheckbox.checked) {
              card.classList.add("completed");
            } else {
              card.classList.remove("completed");
            }
          });
          const doneText = document.createElement("span");
          doneText.textContent = "Done";
          doneLabel.appendChild(doneCheckbox);
          doneLabel.appendChild(doneText);
          midRow.appendChild(doneLabel);

          card.appendChild(midRow);

          const noteRow = document.createElement("div");
          noteRow.className = "goal-row-note";
          const noteArea = document.createElement("textarea");
          noteArea.value = goal.progress_note || goal.description || "";
          noteArea.placeholder = "Description / notes…";
          let noteDebounceTimer = null;
          noteArea.addEventListener("input", () => {
            clearTimeout(noteDebounceTimer);
            noteDebounceTimer = setTimeout(() => {
              updateMonthlyGoal(goal.id, { progress_note: noteArea.value.trim() });
            }, 3000); // Save after 3 seconds of no typing
          });
          noteRow.appendChild(noteArea);
          card.appendChild(noteRow);

          // Add subtasks section
          const subtasksSection = buildGoalSubtasksSection("monthly", goal.id, card);
          card.appendChild(subtasksSection);

          list.appendChild(card);
        });

        col.appendChild(list);

        // Add form for new goals in this category
        const addForm = document.createElement("div");
        addForm.className = "goal-add-form";

        const addTitleInput = document.createElement("input");
        addTitleInput.type = "text";
        addTitleInput.placeholder = "Add new goal…";
        addForm.appendChild(addTitleInput);

        const addOwnerSelect = document.createElement("select");
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = u.id;
          opt.textContent = u.name;
          addOwnerSelect.appendChild(opt);
        });
        if (state.currentUser) {
          addOwnerSelect.value = String(state.currentUser.id);
        }
        addForm.appendChild(addOwnerSelect);

        const addButton = document.createElement("button");
        addButton.textContent = "Add Goal";
        addButton.addEventListener("click", async () => {
          const title = addTitleInput.value.trim();
          const ownerId = parseInt(addOwnerSelect.value, 10);
          if (!title) {
            showToast("Enter a goal title", true);
            return;
          }
          if (!ownerId) {
            showToast("Pick an owner", true);
            return;
          }
          try {
            await createMonthlyGoal({
              owner_id: ownerId,
              month_key: monthKeyFromDate(state.currentMonthDate),
              category,
              title,
              description: ""
            });
            addTitleInput.value = "";
            showToast("Monthly goal added");
          } catch (err) {
            console.error(err);
            showToast("Error adding monthly goal", true);
          }
        });
        addForm.appendChild(addButton);

        col.appendChild(addForm);

        grid.appendChild(col);
      });
    }

    async function updateMonthlyGoal(id, patch) {
      try {
        await apiSend("/monthly-goals/" + id, "PATCH", patch);
      } catch (err) {
        console.error(err);
        showToast("Error updating monthly goal", true);
      }
    }

    // ===== GOAL SUBTASKS =====
    async function loadGoalSubtasks(goalType, goalId) {
      try {
        return await apiGet(`/goals/${goalType}/${goalId}/subtasks`);
      } catch (err) {
        console.error("Error loading goal subtasks:", err);
        return [];
      }
    }

    async function createGoalSubtask(goalType, goalId, title) {
      try {
        const subtask = await apiSend(`/goals/${goalType}/${goalId}/subtasks`, "POST", { title });
        return subtask;
      } catch (err) {
        console.error("Error creating goal subtask:", err);
        showToast("Error adding subtask", true);
        return null;
      }
    }

    async function updateGoalSubtask(subtaskId, patch) {
      try {
        await apiSend(`/goal-subtasks/${subtaskId}`, "PATCH", patch);
      } catch (err) {
        console.error("Error updating goal subtask:", err);
        showToast("Error updating subtask", true);
      }
    }

    async function deleteGoalSubtask(subtaskId) {
      try {
        await fetch(API_BASE + `/goal-subtasks/${subtaskId}`, { method: "DELETE" });
      } catch (err) {
        console.error("Error deleting goal subtask:", err);
        showToast("Error deleting subtask", true);
      }
    }

    async function addSubtaskToCalendar(subtaskId, taskDate) {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return null;
      }
      try {
        const result = await apiSend(`/goal-subtasks/${subtaskId}/add-to-calendar`, "POST", {
          task_date: taskDate,
          assigned_to_id: state.currentUser.id,
          assigned_by_id: state.currentUser.id,
          created_by_id: state.currentUser.id
        });
        showToast("Added to calendar!");
        await loadDailyTasks();
        return result;
      } catch (err) {
        console.error("Error adding subtask to calendar:", err);
        showToast("Error adding to calendar", true);
        return null;
      }
    }

    function openAddToCalendarModal(subtaskId, subtaskTitle) {
      // Simple prompt for date
      const today = new Date().toISOString().split('T')[0];
      const dateStr = prompt(`Add "${subtaskTitle}" to calendar.\n\nEnter date (YYYY-MM-DD):`, today);
      if (!dateStr) return;

      // Validate date format
      if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
        showToast("Invalid date format. Use YYYY-MM-DD", true);
        return;
      }

      addSubtaskToCalendar(subtaskId, dateStr);
    }

    function buildGoalSubtasksSection(goalType, goalId, cardElement) {
      const section = document.createElement("div");
      section.className = "goal-subtasks";
      section.dataset.goalType = goalType;
      section.dataset.goalId = goalId;

      // Toggle to expand/collapse
      const toggle = document.createElement("div");
      toggle.className = "goal-subtasks-toggle";
      toggle.innerHTML = "▾ Loading..."; // Initial state

      toggle.addEventListener("click", () => {
        // Toggle visibility if loaded
        if (section.dataset.loaded === "true") {
          const list = section.querySelector(".subtasks-list");
          if (list) {
            const isHidden = list.style.display === "none";
            list.style.display = isHidden ? "block" : "none";
            toggle.innerHTML = isHidden
              ? `▾ Subtasks (${section.dataset.count || 0})`
              : "▸ Subtasks";
          }
        }
      });

      section.appendChild(toggle);

      // Auto-load subtasks immediately
      (async () => {
        try {
          const subtasks = await loadGoalSubtasks(goalType, goalId);
          section.dataset.loaded = "true";
          section.dataset.count = subtasks.length;
          renderGoalSubtasks(section, goalType, goalId, subtasks);
          // Update toggle text to show count and indicate expanded state
          toggle.innerHTML = `▾ Subtasks (${subtasks.length})`;
        } catch (err) {
          console.error("Auto-load subtasks failed", err);
          toggle.innerHTML = "▸ Subtasks (Error)";
        }
      })();

      return section;
    }

    function renderGoalSubtasks(container, goalType, goalId, subtasks) {
      // Remove old list if exists
      let list = container.querySelector(".subtasks-list");
      if (list) list.remove();

      list = document.createElement("div");
      list.className = "subtasks-list";

      subtasks.forEach(sub => {
        const row = document.createElement("div");
        row.className = "goal-subtask";
        if (sub.status === "done") row.classList.add("completed");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = sub.status === "done";
        checkbox.addEventListener("change", async () => {
          const newStatus = checkbox.checked ? "done" : "pending";
          await updateGoalSubtask(sub.id, { status: newStatus });
          if (checkbox.checked) {
            row.classList.add("completed");
          } else {
            row.classList.remove("completed");
          }
          // Refresh goals to update progress
          if (goalType === "monthly") {
            await loadMonthlyGoals();
          } else {
            await loadAnnualGoals();
          }
        });

        const titleSpan = document.createElement("span");
        titleSpan.className = "goal-subtask-title";
        titleSpan.textContent = sub.title;

        const calBtn = document.createElement("button");
        calBtn.className = "goal-subtask-calendar-btn";
        calBtn.title = sub.linked_task_id ? "Already on calendar" : "Add to calendar";
        calBtn.textContent = "📅";
        if (sub.linked_task_id) {
          calBtn.classList.add("linked");
        }
        calBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          if (sub.linked_task_id) {
            showToast("Already on calendar");
          } else {
            openAddToCalendarModal(sub.id, sub.title);
          }
        });

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "goal-subtask-delete-btn";
        deleteBtn.textContent = "×";
        deleteBtn.title = "Delete subtask";
        deleteBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          if (confirm(`Delete subtask "${sub.title}"?`)) {
            await deleteGoalSubtask(sub.id);
            row.remove();
            // Refresh to update progress
            if (goalType === "monthly") {
              await loadMonthlyGoals();
            } else {
              await loadAnnualGoals();
            }
          }
        });

        row.appendChild(checkbox);
        row.appendChild(titleSpan);
        row.appendChild(calBtn);
        row.appendChild(deleteBtn);
        list.appendChild(row);
      });

      // Add subtask form
      const addForm = document.createElement("div");
      addForm.className = "add-subtask-form";

      const addInput = document.createElement("input");
      addInput.type = "text";
      addInput.placeholder = "New subtask...";

      const addBtn = document.createElement("button");
      addBtn.textContent = "+";
      addBtn.addEventListener("click", async () => {
        const title = addInput.value.trim();
        if (!title) return;
        const newSub = await createGoalSubtask(goalType, goalId, title);
        if (newSub) {
          addInput.value = "";
          // Reload subtasks
          const subtasks = await loadGoalSubtasks(goalType, goalId);
          renderGoalSubtasks(container, goalType, goalId, subtasks);
          // Update toggle count
          const toggle = container.querySelector(".goal-subtasks-toggle");
          if (toggle) toggle.innerHTML = `▾ Subtasks (${subtasks.length})`;
        }
      });

      addInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          addBtn.click();
        }
      });

      addForm.appendChild(addInput);
      addForm.appendChild(addBtn);
      list.appendChild(addForm);

      container.appendChild(list);
    }


    // ===== JOINT PROJECTS =====
    async function loadProjects() {
      try {
        const projects = await apiGet("/projects");
        state.projects = projects;
        renderProjects();
      } catch (err) {
        console.error("Error loading projects:", err);
      }
    }

    function renderProjects() {
      const grid = document.getElementById("projects-grid");
      if (!grid) return;
      grid.innerHTML = "";

      const projects = state.projects || [];

      if (projects.length === 0) {
        grid.innerHTML = '<div style="font-size:11px;color:var(--ink-soft);padding:10px;">No projects yet. Click "+ New Project" to create one.</div>';
        return;
      }

      projects.forEach(project => {
        const card = buildProjectCard(project);
        grid.appendChild(card);
      });
    }

    function buildProjectCard(project) {
      const card = document.createElement("div");
      card.className = "project-card";
      if (project.status === "completed") card.classList.add("completed");
      card.dataset.projectId = project.id;

      // Header
      const header = document.createElement("div");
      header.className = "project-header";

      const titleDiv = document.createElement("div");
      const title = document.createElement("div");
      title.className = "project-title";
      title.textContent = project.title;
      titleDiv.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "project-meta";
      meta.textContent = `by ${project.created_by_name || "Unknown"}`;
      titleDiv.appendChild(meta);

      // Waiting On / Blocking info
      if (project.waiting_on || project.blocking_task) {
        const waitingDiv = document.createElement("div");
        waitingDiv.style.marginTop = "6px";
        waitingDiv.style.fontSize = "11px";
        waitingDiv.style.color = "var(--ink-soft)";

        if (project.waiting_on) {
          const w = document.createElement("div");
          w.innerHTML = `<strong>Waiting On:</strong> ${project.waiting_on}`;
          w.style.color = "#e11d48"; // Danger color for visibility
          waitingDiv.appendChild(w);
        }
        if (project.blocking_task) {
          const b = document.createElement("div");
          b.innerHTML = `<strong>Details:</strong> ${project.blocking_task}`;
          b.style.marginTop = "2px";
          waitingDiv.appendChild(b);
        }
        titleDiv.appendChild(waitingDiv);
      }

      // Edit Button
      const editBtn = document.createElement("button");
      editBtn.textContent = "✎";
      editBtn.title = "Edit Project Details";
      editBtn.style.background = "none";
      editBtn.style.border = "none";
      editBtn.style.cursor = "pointer";
      editBtn.style.fontSize = "12px";
      editBtn.style.marginLeft = "6px";
      editBtn.style.opacity = "0.5";
      editBtn.onclick = (e) => {
        e.stopPropagation();
        editProjectDetails(project);
      };
      title.appendChild(editBtn);

      // Duplicate Button
      const copyBtn = document.createElement("button");
      copyBtn.textContent = "❐";
      copyBtn.title = "Duplicate Project (and reset steps)";
      copyBtn.style.background = "none";
      copyBtn.style.border = "none";
      copyBtn.style.cursor = "pointer";
      copyBtn.style.fontSize = "12px";
      copyBtn.style.marginLeft = "4px";
      copyBtn.style.opacity = "0.5";
      copyBtn.onclick = (e) => {
        e.stopPropagation();
        duplicateProject(project);
      };
      title.appendChild(copyBtn);

      // Delete Project Button
      const deleteProjBtn = document.createElement("button");
      deleteProjBtn.textContent = "🗑";
      deleteProjBtn.title = "Delete Entire Project";
      deleteProjBtn.style.background = "none";
      deleteProjBtn.style.border = "none";
      deleteProjBtn.style.cursor = "pointer";
      deleteProjBtn.style.fontSize = "12px";
      deleteProjBtn.style.marginLeft = "4px";
      deleteProjBtn.style.opacity = "0.5";
      deleteProjBtn.style.color = "var(--danger)";
      deleteProjBtn.onclick = (e) => {
        e.stopPropagation();
        deleteProject(project);
      };
      title.appendChild(deleteProjBtn);

      const progressLabel = document.createElement("div");
      progressLabel.className = "project-progress-label";
      progressLabel.textContent = `${project.progress_percent || 0}%`;

      header.appendChild(titleDiv);
      header.appendChild(progressLabel);
      card.appendChild(header);

      // Progress bar
      const progressBar = document.createElement("div");
      progressBar.className = "project-progress-bar";

      const progressFill = document.createElement("div");
      progressFill.className = "project-progress-fill";
      if (project.progress_percent >= 100) progressFill.classList.add("complete");
      progressFill.style.width = `${project.progress_percent || 0}%`;
      progressBar.appendChild(progressFill);
      card.appendChild(progressBar);

      // Steps count
      const stepsInfo = document.createElement("div");
      stepsInfo.className = "project-meta";
      stepsInfo.textContent = `${project.completed_steps || 0}/${project.total_steps || 0} steps completed`;
      card.appendChild(stepsInfo);

      // Expandable steps toggle
      const toggle = document.createElement("div");
      toggle.className = "goal-subtasks-toggle";
      // Auto-expanded by default now
      toggle.innerHTML = "▾ Hide Steps";
      toggle.style.marginTop = "6px";

      // Render steps immediately if available
      const stepsDiv = document.createElement("div");
      stepsDiv.className = "project-steps";
      // Start visible
      stepsDiv.style.display = "block";
      card.appendChild(stepsDiv);
      renderProjectSteps(card, project);

      toggle.addEventListener("click", () => {
        const sDiv = card.querySelector(".project-steps");
        if (sDiv) {
          const isHidden = sDiv.style.display === "none";
          sDiv.style.display = isHidden ? "block" : "none";
          toggle.innerHTML = isHidden ? "▾ Hide Steps" : "▸ View Steps";
        }
      });
      card.appendChild(toggle);

      return card;
    }

    function renderProjectSteps(cardElement, project) {
      // Find existing or create new steps container
      let stepsDiv = cardElement.querySelector(".project-steps");
      if (!stepsDiv) {
        stepsDiv = document.createElement("div");
        stepsDiv.className = "project-steps";
        cardElement.appendChild(stepsDiv);
      } else {
        stepsDiv.innerHTML = "";
      }

      const currentUserId = state.currentUser?.id;
      const currentUserName = (state.currentUser?.name || "").toLowerCase();

      // Permission check: Kevin or Meighan or Project Owner
      const isSuperUser = currentUserName.includes("kevin") || currentUserName.includes("meighan");
      const isProjectOwner = project.created_by_id === currentUserId;

      (project.steps || []).forEach(step => {
        const row = document.createElement("div");
        row.className = "project-step";
        if (step.status === "done") row.classList.add("done");

        // Check if user is ONE OF the assignees
        const assignees = step.assignees || [];
        // Fallback for older API responses
        if (assignees.length === 0 && step.assigned_to_id) {
          assignees.push({ id: step.assigned_to_id, name: step.assigned_to_name });
        }

        const isAssigned = assignees.some(a => a.id === currentUserId);

        if (isAssigned && step.status !== "done") {
          row.classList.add("current-assignee");
        }

        // Status icon
        const icon = document.createElement("span");
        icon.className = "step-status-icon";
        if (step.status === "done") {
          icon.textContent = "✓";
          icon.style.color = "var(--success)";
        } else if (isAssigned) {
          icon.textContent = "●";
          icon.style.color = "var(--accent)";
        } else {
          icon.textContent = "○";
        }
        row.appendChild(icon);

        // Title & Metadata
        const contentDiv = document.createElement("div");
        contentDiv.style.flex = "1";
        contentDiv.style.display = "flex";
        contentDiv.style.flexDirection = "column";
        contentDiv.style.justifyContent = "center";

        const titleSpan = document.createElement("span");
        titleSpan.className = "step-title";
        titleSpan.textContent = step.title;
        contentDiv.appendChild(titleSpan);

        if (step.status === "done" && step.completed_at) {
          const metaSpan = document.createElement("span");
          metaSpan.style.fontSize = "10px";
          metaSpan.style.color = "#9ca3af"; // var(--ink-soft) approx
          metaSpan.style.marginTop = "1px";

          const d = new Date(step.completed_at);
          // Short date format: Jan 16, 2:30 PM
          const dateStr = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ", " + d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
          const who = step.completed_by_name ? ` by ${step.completed_by_name.split(' ')[0]}` : "";

          metaSpan.textContent = `✓ ${dateStr}${who}`;
          contentDiv.appendChild(metaSpan);
        }

        row.appendChild(contentDiv);

        // Assignees Display
        const assigneeSpan = document.createElement("span");
        assigneeSpan.className = "step-assignee";
        if (assignees.length > 0) {
          assigneeSpan.textContent = assignees.map(a => a.name.split(" ")[0]).join(", ");
        } else {
          assigneeSpan.textContent = "Unassigned";
        }
        row.appendChild(assigneeSpan);

        // Action buttons
        const actionsDiv = document.createElement("div");
        actionsDiv.style.display = "flex";
        actionsDiv.style.gap = "4px";
        actionsDiv.style.marginLeft = "auto";

        // Complete Button (if assigned or super/owner)
        // Complete/Uncomplete Toggle (if assigned or super/owner)
        if (isAssigned || isSuperUser || isProjectOwner) {
          const actionBtn = document.createElement("button");
          actionBtn.className = "step-action-btn";

          if (step.status === "done") {
            actionBtn.textContent = "✖"; // Or undo icon
            actionBtn.title = "Mark Incomplete";
            actionBtn.style.opacity = "0.6";
          } else {
            actionBtn.textContent = "✓";
            actionBtn.title = "Mark Complete";
            actionBtn.style.fontWeight = "bold";
          }

          actionBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            const newStatus = step.status === "done" ? "pending" : "done";
            await toggleProjectStepStatus(step.id, project.id, newStatus);
          });
          actionsDiv.appendChild(actionBtn);
        }

        // Delete/Edit Button (SuperUser or Owner)
        if (isSuperUser || isProjectOwner) {
          const editBtn = document.createElement("button");
          editBtn.textContent = "✎";
          editBtn.style.color = "var(--accent)";
          editBtn.style.background = "none";
          editBtn.style.border = "none";
          editBtn.style.cursor = "pointer";
          editBtn.style.fontSize = "14px";
          editBtn.title = "Edit Step Title";
          editBtn.onclick = async (e) => {
            e.stopPropagation();
            await editProjectStep(step, project.id);
          };
          actionsDiv.appendChild(editBtn);

          const delBtn = document.createElement("button");
          delBtn.textContent = "×";
          delBtn.style.color = "var(--danger)";
          delBtn.style.background = "none";
          delBtn.style.border = "none";
          delBtn.style.cursor = "pointer";
          delBtn.style.fontSize = "14px";
          delBtn.title = "Delete Step";
          delBtn.onclick = async (e) => {
            e.stopPropagation();
            if (confirm("Delete this step?")) {
              await deleteProjectStep(step.id);
            }
          };
          actionsDiv.appendChild(delBtn);
        }

        row.appendChild(actionsDiv);
        stepsDiv.appendChild(row);
      });

      // Add step form (Multi-assign)
      const addForm = document.createElement("div");
      addForm.className = "add-step-form";
      addForm.style.flexDirection = "column";
      addForm.style.alignItems = "stretch";

      const topRow = document.createElement("div");
      topRow.style.display = "flex";
      topRow.style.gap = "6px";

      const stepInput = document.createElement("input");
      stepInput.type = "text";
      stepInput.placeholder = "New step...";
      stepInput.style.flex = "1";

      const toggleAssigneesBtn = document.createElement("button");
      toggleAssigneesBtn.textContent = "Engage Team";
      toggleAssigneesBtn.className = "button-secondary";
      toggleAssigneesBtn.style.fontSize = "11px";
      toggleAssigneesBtn.style.padding = "4px 8px";

      const assigneesContainer = document.createElement("div");
      assigneesContainer.className = "checkbox-list";
      assigneesContainer.style.display = "none"; // hidden by default
      assigneesContainer.style.marginTop = "6px";

      // Populate checkboxes
      (state.users || []).forEach(u => {
        const lbl = document.createElement("label");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = u.id;
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(u.name));
        assigneesContainer.appendChild(lbl);
      });

      toggleAssigneesBtn.onclick = () => {
        assigneesContainer.style.display = assigneesContainer.style.display === "none" ? "flex" : "none";
      };

      const addBtn = document.createElement("button");
      addBtn.textContent = "+ Add";
      addBtn.className = "button-primary";
      addBtn.style.fontSize = "11px";
      addBtn.addEventListener("click", async () => {
        const title = stepInput.value.trim();
        // Collect checked ids
        const checked = assigneesContainer.querySelectorAll("input:checked");
        const assigneeIds = Array.from(checked).map(c => parseInt(c.value));
        const primaryId = assigneeIds.length > 0 ? assigneeIds[0] : null;

        if (!title) return;

        try {
          await apiSend(`/projects/${project.id}/steps`, "POST", {
            title,
            assigned_to_id: primaryId, // backward compat
            assignee_ids: assigneeIds,
            step_order: (project.steps?.length || 0) + 1
          });
          stepInput.value = "";
          // clear checks
          checked.forEach(c => c.checked = false);
          assigneesContainer.style.display = "none";

          await loadProjects();
          showToast("Step added!");
        } catch (err) {
          console.error(err);
          showToast("Error adding step", true);
        }
      });

      topRow.appendChild(stepInput);
      topRow.appendChild(toggleAssigneesBtn);
      topRow.appendChild(addBtn);

      addForm.appendChild(topRow);
      addForm.appendChild(assigneesContainer);
      stepsDiv.appendChild(addForm);
    }

    async function deleteProjectStep(stepId) {
      try {
        await apiSend(`/project-steps/${stepId}`, "DELETE");
        await loadProjects();
        showToast("Step deleted");
      } catch (err) {
        console.error(err);
        showToast("Error deleting step", true);
      }
    }

    async function editProjectStep(step, projectId) {
      const modal = document.getElementById("project-step-modal");
      document.getElementById("edit-project-step-id").value = step.id;
      document.getElementById("edit-project-step-title-input").value = step.title;

      const container = document.getElementById("edit-project-step-assignees-container");
      container.innerHTML = "";

      const selectedIds = (step.assignees || []).map(a => String(a.id));
      if (selectedIds.length === 0 && step.assigned_to_id) {
        selectedIds.push(String(step.assigned_to_id));
      }

      (state.users || []).forEach(u => {
        const lbl = document.createElement("label");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = u.id;
        if (selectedIds.includes(String(u.id))) cb.checked = true;
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(u.name));
        container.appendChild(lbl);
      });

      modal.classList.remove("hidden");
    }

    async function saveProjectStepFromModal() {
      const stepId = document.getElementById("edit-project-step-id").value;
      const title = document.getElementById("edit-project-step-title-input").value.trim();
      const checkboxes = document.querySelectorAll("#edit-project-step-assignees-container input:checked");
      const assigneeIds = Array.from(checkboxes).map(cb => parseInt(cb.value, 10));

      if (!title) {
        showToast("Title is required", true);
        return;
      }

      try {
        await apiSend(`/project-steps/${stepId}`, "PATCH", {
          title: title,
          assignee_ids: assigneeIds,
          assigned_to_id: assigneeIds[0] || null
        });
        document.getElementById("project-step-modal").classList.add("hidden");
        await loadProjects();
        showToast("Step updated");
      } catch (err) {
        console.error(err);
        showToast("Error updating step", true);
      }
    }

    async function deleteProject(project) {
      if (!confirm(`Are you SURE you want to delete the entire project "${project.title}"? This cannot be undone.`)) return;

      try {
        await apiSend(`/projects/${project.id}`, "DELETE");
        await loadProjects();
        showToast("Project deleted");
      } catch (err) {
        console.error(err);
        showToast("Error deleting project", true);
      }
    }

    async function toggleProjectStepStatus(stepId, projectId, newStatus) {
      try {
        const body = { status: newStatus };
        if (newStatus === "done") {
          body.completed_by_id = state.currentUser.id;
        }

        await apiSend(`/project-steps/${stepId}`, "PATCH", body);
        await loadProjects();

        if (newStatus === "done") showToast("Step completed!");
        else showToast("Step unchecked");
      } catch (err) {
        console.error(err);
        showToast("Error updating step", true);
      }
    }

    async function createNewProject() {
      if (!state.currentUser) {
        showToast("Pick your user first", true);
        return;
      }

      const title = prompt("Enter project name:");
      if (!title || !title.trim()) return;

      try {
        await apiSend("/projects", "POST", {
          title: title.trim(),
          created_by_id: state.currentUser.id
        });
        await loadProjects();
        showToast("Project created!");
      } catch (err) {
        console.error(err);
        showToast("Error creating project", true);
      }
    }

    async function editProjectDetails(project) {
      const waitingOn = prompt("Who are we waiting on? (Leave empty to clear)", project.waiting_on || "");
      if (waitingOn === null) return; // Cancelled

      const details = prompt("What are the details/blocking task? (Leave empty to clear)", project.blocking_task || "");
      if (details === null) return;

      try {
        await apiSend(`/projects/${project.id}`, "PATCH", {
          waiting_on: waitingOn.trim(),
          blocking_task: details.trim()
        });
        await loadProjects();
        showToast("Project details updated");
      } catch (err) {
        console.error(err);
        showToast("Error updating details", true);
      }
    }


    async function duplicateProject(project) {
      const customTitle = prompt(`Duplicate "${project.title}"? Adjust title if needed:`, `${project.title} (Copy)`);
      if (customTitle === null) return;

      try {
        showToast("Duplicating...");
        await apiSend(`/projects/${project.id}/duplicate`, "POST", { title: customTitle.trim() });
        await loadProjects();
        showToast("Project duplicated!");
      } catch (err) {
        console.error(err);
        showToast("Error duplicating project", true);
      }
    }


    // ===== WEEKLY TASKS (BETA) =====
    function getWeekKey(date = new Date()) {
      const d = new Date(date);
      d.setHours(0, 0, 0, 0);
      // ISO week number calculation
      const thursday = new Date(d.valueOf());
      thursday.setDate(d.getDate() - ((d.getDay() + 6) % 7) + 3);
      const firstThursday = new Date(thursday.getFullYear(), 0, 4);
      const weekNum = 1 + Math.round(
        ((thursday.valueOf() - firstThursday.valueOf()) / 86400000 - 3 +
          ((firstThursday.getDay() + 6) % 7)) / 7
      );
      return `${thursday.getFullYear()}-W${String(weekNum).padStart(2, "0")}`;
    }

    function parseWeekKey(weekKey) {
      const [yearStr, weekPart] = weekKey.split("-W");
      return { year: parseInt(yearStr, 10), week: parseInt(weekPart, 10) };
    }

    function formatWeekLabel(weekKey) {
      const { year, week } = parseWeekKey(weekKey);
      return `Week ${week}, ${year}`;
    }

    function shiftWeek(weekKey, delta) {
      const { year, week } = parseWeekKey(weekKey);
      let newWeek = week + delta;
      let newYear = year;
      if (newWeek < 1) {
        newYear--;
        newWeek = 52; // Approximate, some years have 53 weeks
      } else if (newWeek > 52) {
        newYear++;
        newWeek = 1;
      }
      return `${newYear}-W${String(newWeek).padStart(2, "0")}`;
    }

    async function loadWeeklyTasks() {
      if (!state.currentWeekKey) {
        state.currentWeekKey = getWeekKey();
      }

      try {
        const data = await apiGet(`/weekly-tasks?week=${state.currentWeekKey}&userId=${state.currentUser?.id || ""}`);
        state.weeklyTasks = data.tasks || [];
        renderWeeklyTasks();
      } catch (err) {
        // Silently fail for 404 or other errors to avoid disturbing user
        // console.warn("Error loading weekly tasks:", err); 
        state.weeklyTasks = [];
        renderWeeklyTasks();
      }
    }

    function renderWeeklyTasks() {
      const list = document.getElementById("weekly-tasks-list");
      const weekLabel = document.getElementById("week-label");

      if (!list) return;
      list.innerHTML = "";

      if (weekLabel && state.currentWeekKey) {
        weekLabel.textContent = formatWeekLabel(state.currentWeekKey);
      }

      if (state.weeklyTasks.length === 0) {
        list.innerHTML = '<div style="font-size:11px;color:var(--ink-soft);padding:8px;">No tasks for this week.</div>';
        return;
      }

      state.weeklyTasks.forEach(task => {
        const item = document.createElement("div");
        item.className = "weekly-task-item";
        if (task.status === "done") item.classList.add("done");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "weekly-task-checkbox";
        checkbox.checked = task.status === "done";
        checkbox.addEventListener("change", async () => {
          await toggleWeeklyTask(task.id, checkbox.checked);
        });
        item.appendChild(checkbox);

        const title = document.createElement("span");
        title.className = "weekly-task-title";
        title.textContent = task.title;
        item.appendChild(title);

        const deleteBtn = document.createElement("button");
        deleteBtn.style = "border:none;background:transparent;color:var(--danger);cursor:pointer;font-size:12px;padding:2px 4px;";
        deleteBtn.textContent = "×";
        deleteBtn.addEventListener("click", async () => {
          await deleteWeeklyTask(task.id);
        });
        item.appendChild(deleteBtn);

        list.appendChild(item);
      });
    }

    async function toggleWeeklyTask(taskId, done) {
      try {
        await apiSend(`/weekly-tasks/${taskId}`, "PATCH", { status: done ? "done" : "pending" });
        await loadWeeklyTasks();
        if (done) checkWeeklyCompletion();
      } catch (err) {
        console.error(err);
        showToast("Error updating task", true);
      }
    }

    async function createWeeklyTask(title) {
      if (!title || !state.currentUser) return;

      try {
        await apiSend("/weekly-tasks", "POST", {
          title,
          week_key: state.currentWeekKey,
          assigned_to_id: state.currentUser.id,
          assigned_by_id: state.currentUser.id
        });
        await loadWeeklyTasks();
        showToast("Weekly task added!");
      } catch (err) {
        console.error(err);
        showToast("Error adding weekly task", true);
      }
    }

    async function deleteWeeklyTask(taskId) {
      try {
        await fetch(`${API_BASE}/weekly-tasks/${taskId}`, { method: "DELETE" });
        await loadWeeklyTasks();
        showToast("Task deleted");
      } catch (err) {
        console.error(err);
      }
    }

    function isWeeklyTasksUser() {
      // Show weekly tasks for users with "jenna" in their name or email (case-insensitive)
      if (!state.currentUser) return false;
      const name = (state.currentUser.name || "").toLowerCase();
      const email = (state.currentUser.email || "").toLowerCase();
      return name.includes("jenna") || email.includes("jenna");
    }

    function initWeeklyTasksUI() {
      const section = document.getElementById("section-weekly-tasks");
      if (!section) return;

      // Show only if user qualifies
      if (isWeeklyTasksUser()) {
        section.style.display = "block";
        state.currentWeekKey = getWeekKey();
        loadWeeklyTasks();
      } else {
        section.style.display = "none";
      }
    }

    // ===== USER PREFERENCES D1 SYNC =====
    async function loadUserDbPreferences() {
      if (!state.currentUser) return;

      try {
        const prefs = await apiGet(`/user-preferences/${state.currentUser.id}`);
        state.userDbPrefs = prefs;

        // Apply theme
        if (prefs.theme && prefs.theme !== state.theme) {
          applyTheme(prefs.theme);
        }

        // Apply calendar view
        if (prefs.calendar_view && prefs.calendar_view !== state.calendarView) {
          state.calendarView = prefs.calendar_view;

          // Update selector UI
          const viewSelect = document.getElementById("calendar-view-select");
          if (viewSelect) viewSelect.value = state.calendarView;

          // Update view buttons if needed (legacy support)
          document.querySelectorAll(".view-btn").forEach(btn => {
            btn.classList.toggle("active", btn.dataset.view === state.calendarView);
          });

          // Re-render calendar with new view
          await refreshCalendarAndMonthlyGoals();
        }

        // Apply saved section order
        if (prefs.section_order) {
          applySavedSectionOrder();
        }
      } catch (err) {
        console.warn("Could not load user preferences:", err);
      }
    }

    async function saveUserDbPreference(key, value) {
      if (!state.currentUser) return;

      try {
        const body = { [key]: value };
        await apiSend(`/user-preferences/${state.currentUser.id}`, "PUT", body);
      } catch (err) {
        console.warn("Could not save user preference:", err);
      }
    }


    // ===== DRAGGABLE SECTIONS =====
    let draggedSection = null;

    function initDraggableSections() {
      const container = document.getElementById("sections-container");
      if (!container) return;

      const sections = container.querySelectorAll(".draggable-section");

      sections.forEach(section => {
        // Drag start
        // Drag start
        // Drag start
        section.addEventListener("dragstart", (e) => {
          // If dragging from an interactive element, blocking section drag
          if (e.target.closest('.task-pill') || e.target.closest('input') || e.target.closest('button') || e.target.closest('.weekly-task-item') || e.target.closest('.goal-card')) {
            return;
          }
          // Note: We removed the strict handle check so user can drag by header/body if empty.

          draggedSection = section;
          section.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", section.id);
        });

        // Drag end
        section.addEventListener("dragend", () => {
          draggedSection = null;
          section.classList.remove("dragging");
          container.querySelectorAll(".draggable-section").forEach(s => {
            s.classList.remove("drop-target");
          });
        });

        // Drag over
        section.addEventListener("dragover", (e) => {
          e.preventDefault();
          if (draggedSection && draggedSection !== section) {
            section.classList.add("drop-target");
          }
        });

        // Drag leave
        section.addEventListener("dragleave", () => {
          section.classList.remove("drop-target");
        });

        // Drop
        section.addEventListener("drop", (e) => {
          e.preventDefault();
          section.classList.remove("drop-target");

          if (draggedSection && draggedSection !== section) {
            // Determine insert position
            const bounding = section.getBoundingClientRect();
            const offset = e.clientY - bounding.top;

            if (offset > bounding.height / 2) {
              // Insert after
              section.parentNode.insertBefore(draggedSection, section.nextSibling);
            } else {
              // Insert before
              section.parentNode.insertBefore(draggedSection, section);
            }

            // Save the new order
            saveSectionOrder();
            showToast("Layout saved!");
          }
        });
      });

      // Apply saved order on load
      applySavedSectionOrder();
    }

    function saveSectionOrder() {
      const container = document.getElementById("sections-container");
      if (!container) return;

      const sections = container.querySelectorAll(".draggable-section");
      const order = Array.from(sections).map(s => s.id);

      // Save to D1
      saveUserDbPreference("section_order", order);

      // Also save to localStorage as fallback
      if (state.currentUser) {
        localStorage.setItem(`section-order-${state.currentUser.id}`, JSON.stringify(order));
      }
    }

    function applySavedSectionOrder() {
      const container = document.getElementById("sections-container");
      if (!container || !state.currentUser) return;

      // Try D1 first, then localStorage
      let savedOrder = null;

      if (state.userDbPrefs && state.userDbPrefs.section_order) {
        try {
          savedOrder = typeof state.userDbPrefs.section_order === "string"
            ? JSON.parse(state.userDbPrefs.section_order)
            : state.userDbPrefs.section_order;
        } catch (e) {
          console.warn("Could not parse section order from D1");
        }
      }

      if (!savedOrder) {
        const localOrder = localStorage.getItem(`section-order-${state.currentUser.id}`);
        if (localOrder) {
          try {
            savedOrder = JSON.parse(localOrder);
          } catch (e) {
            console.warn("Could not parse section order from localStorage");
          }
        }
      }

      if (!savedOrder || !Array.isArray(savedOrder)) return;

      // Reorder sections
      savedOrder.forEach(id => {
        const section = document.getElementById(id);
        if (section) {
          container.appendChild(section);
        }
      });
    }

    function initInstructionsHide() {
      const hideBtn = document.getElementById("hide-instructions-btn");
      const instructions = document.getElementById("customize-instructions");

      if (!hideBtn || !instructions) return;

      // Check if already hidden
      const hidden = localStorage.getItem("hide-customize-instructions");
      if (hidden === "true") {
        instructions.style.display = "none";
      }

      hideBtn.addEventListener("click", () => {
        instructions.style.display = "none";
        localStorage.setItem("hide-customize-instructions", "true");
      });
    }


    async function createMonthlyGoal(payload) {
      try {
        await apiSend("/monthly-goals", "POST", payload);
        await loadMonthlyGoals();
      } catch (err) {
        console.error(err);
        throw err;
      }
    }

    function renderAnnualGoals() {
      const grid = document.getElementById("annual-goals-grid");
      grid.innerHTML = "";

      const ownerFilter = state.annualOwnerFilter;
      const goals = state.annualGoals.filter(g => {
        if (ownerFilter === "all") return true;
        return String(g.owner_id) === ownerFilter;
      });

      const goalsByCategory = {};
      ANNUAL_CATEGORIES.forEach(cat => goalsByCategory[cat] = []);
      goals.forEach(g => {
        if (!goalsByCategory[g.category]) goalsByCategory[g.category] = [];
        goalsByCategory[g.category].push(g);
      });

      ANNUAL_CATEGORIES.forEach(category => {
        const col = document.createElement("div");
        col.className = "goal-column";

        // Editable category title
        const titleInput = document.createElement("input");
        titleInput.type = "text";
        titleInput.className = "goal-column-title-input";
        titleInput.value = getCustomCategoryName("annual", category);
        titleInput.dataset.originalCategory = category;
        titleInput.dataset.goalType = "annual";
        titleInput.addEventListener("blur", () => {
          saveCustomCategoryName("annual", category, titleInput.value.trim());
        });
        titleInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            titleInput.blur();
          }
        });
        col.appendChild(titleInput);

        const list = document.createElement("div");
        const items = goalsByCategory[category] || [];

        items.forEach(goal => {
          const card = document.createElement("div");
          card.className = "goal-card";
          if (goal.is_complete) card.classList.add("completed");

          const topRow = document.createElement("div");
          topRow.className = "goal-row-top";

          const titleInput = document.createElement("input");
          titleInput.className = "goal-title-input";
          titleInput.value = goal.title || "";
          titleInput.placeholder = "Goal title…";
          titleInput.addEventListener("change", () => {
            updateAnnualGoal(goal.id, { title: titleInput.value.trim() });
          });
          topRow.appendChild(titleInput);

          const ownerTag = document.createElement("div");
          ownerTag.className = "goal-owner-tag";
          const owner = state.users.find(u => u.id === goal.owner_id);
          ownerTag.textContent = owner ? owner.name : "";
          topRow.appendChild(ownerTag);

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.className = "goal-delete-btn";
          deleteBtn.textContent = "Remove";
          deleteBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            await deleteAnnualGoal(goal.id);
          });
          topRow.appendChild(deleteBtn);

          card.appendChild(topRow);

          const midRow = document.createElement("div");
          midRow.className = "goal-row-middle";

          const progressWrap = document.createElement("div");
          progressWrap.className = "goal-progress";
          const progressLabel = document.createElement("span");
          progressLabel.textContent = "Progress";
          const progressInput = document.createElement("input");
          progressInput.type = "number";
          progressInput.min = "0";
          progressInput.max = "100";
          progressInput.value = goal.progress_percent ?? 0;
          progressInput.addEventListener("change", () => {
            let val = parseFloat(progressInput.value);
            if (isNaN(val)) val = 0;
            if (val < 0) val = 0;
            if (val > 100) val = 100;
            progressInput.value = val;
            updateAnnualGoal(goal.id, { progress_percent: val });
          });
          const percentSymbol = document.createElement("span");
          percentSymbol.textContent = "%";
          progressWrap.appendChild(progressLabel);
          progressWrap.appendChild(progressInput);
          progressWrap.appendChild(percentSymbol);

          midRow.appendChild(progressWrap);

          const doneLabel = document.createElement("label");
          doneLabel.className = "goal-done-toggle";
          const doneCheckbox = document.createElement("input");
          doneCheckbox.type = "checkbox";
          doneCheckbox.checked = !!goal.is_complete;
          doneCheckbox.addEventListener("change", () => {
            updateAnnualGoal(goal.id, { is_complete: doneCheckbox.checked ? 1 : 0 });
            if (doneCheckbox.checked) {
              card.classList.add("completed");
            } else {
              card.classList.remove("completed");
            }
          });
          const doneText = document.createElement("span");
          doneText.textContent = "Done";
          doneLabel.appendChild(doneCheckbox);
          doneLabel.appendChild(doneText);
          midRow.appendChild(doneLabel);

          card.appendChild(midRow);

          const noteRow = document.createElement("div");
          noteRow.className = "goal-row-note";
          const noteArea = document.createElement("textarea");
          noteArea.value = goal.progress_note || goal.description || "";
          noteArea.placeholder = "Description / notes…";
          let noteDebounceTimer = null;
          noteArea.addEventListener("input", () => {
            clearTimeout(noteDebounceTimer);
            noteDebounceTimer = setTimeout(() => {
              updateAnnualGoal(goal.id, { progress_note: noteArea.value.trim() });
            }, 3000); // Save after 3 seconds of no typing
          });
          noteRow.appendChild(noteArea);
          card.appendChild(noteRow);

          // Add subtasks section
          const subtasksSection = buildGoalSubtasksSection("annual", goal.id, card);
          card.appendChild(subtasksSection);

          list.appendChild(card);
        });

        col.appendChild(list);

        const addForm = document.createElement("div");
        addForm.className = "goal-add-form";

        const addTitleInput = document.createElement("input");
        addTitleInput.type = "text";
        addTitleInput.placeholder = "Add new annual goal…";
        addForm.appendChild(addTitleInput);

        const addOwnerSelect = document.createElement("select");
        state.users.forEach(u => {
          const opt = document.createElement("option");
          opt.value = u.id;
          opt.textContent = u.name;
          addOwnerSelect.appendChild(opt);
        });
        if (state.currentUser) {
          addOwnerSelect.value = String(state.currentUser.id);
        }
        addForm.appendChild(addOwnerSelect);

        const addButton = document.createElement("button");
        addButton.textContent = "Add Goal";
        addButton.addEventListener("click", async () => {
          const title = addTitleInput.value.trim();
          const ownerId = parseInt(addOwnerSelect.value, 10);
          if (!title) {
            showToast("Enter a goal title", true);
            return;
          }
          if (!ownerId) {
            showToast("Pick an owner", true);
            return;
          }
          try {
            await createAnnualGoal({
              owner_id: ownerId,
              year: state.annualYear,
              category,
              title,
              description: ""
            });
            addTitleInput.value = "";
            showToast("Annual goal added");
          } catch (err) {
            console.error(err);
            showToast("Error adding annual goal", true);
          }
        });
        addForm.appendChild(addButton);

        col.appendChild(addForm);

        grid.appendChild(col);
      });
    }

    async function deleteAnnualGoal(id) {
      if (!id) return;
      if (!confirm("Remove this annual goal?")) return;

      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        showActionLoader({
          main: "Removing goal…",
          sub: "Updating your annual plan"
        });

        const fetchPromise = fetch(API_BASE + "/annual-goals/" + id, {
          method: "DELETE",
          headers: { "Accept": "application/json" }
        });

        const res = await Promise.all([fetchPromise, delayPromise]).then(
          ([res]) => res
        );

        if (!res.ok && res.status !== 204) {
          throw new Error("Delete failed");
        }

        await loadAnnualGoals();
        showToast("Annual goal removed");
      } catch (err) {
        console.error(err);
        showToast("Error removing annual goal", true);
      } finally {
        hideActionLoader();
      }
    }


    async function deleteMonthlyGoal(id) {
      if (!id) return;
      if (!confirm("Remove this monthly goal?")) return;

      // random delay between 500ms and 2000ms, plus action loader
      const delayMs = 500 + Math.random() * 1500;
      const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

      try {
        showActionLoader({
          main: "Removing goal…",
          sub: "Updating your monthly focuses"
        });

        const fetchPromise = fetch(API_BASE + "/monthly-goals/" + id, {
          method: "DELETE",
          headers: { "Accept": "application/json" }
        });

        const res = await Promise.all([fetchPromise, delayPromise]).then(
          ([res]) => res
        );

        if (!res.ok && res.status !== 204) {
          throw new Error("Delete failed");
        }

        await loadMonthlyGoals();
        showToast("Monthly goal removed");
      } catch (err) {
        console.error(err);
        showToast("Error removing monthly goal", true);
      } finally {
        hideActionLoader();
      }
    }


    async function updateAnnualGoal(id, patch) {
      try {
        await apiSend("/annual-goals/" + id, "PATCH", patch);
      } catch (err) {
        console.error(err);
        showToast("Error updating annual goal", true);
      }
    }

    async function createAnnualGoal(payload) {
      try {
        await apiSend("/annual-goals", "POST", payload);
        await loadAnnualGoals();
      } catch (err) {
        console.error(err);
        throw err;
      }
    }

    // [Fix] User Switcher Logic for Isolation
    function initUserSwitcher() {
      const confirmBtn = document.getElementById("user-select-confirm");
      const select = document.getElementById("user-select");
      const switchBtn = document.getElementById("switch-user-btn");
      const overlay = document.getElementById("user-overlay");

      if (confirmBtn && select) {
        confirmBtn.addEventListener("click", async () => {
          const val = select.value;
          if (!val) return;

          const user = state.users.find(u => String(u.id) === String(val));
          if (!user) return;

          // Force update state
          state.currentUser = user;
          state.activeUser = user;
          state.activeUserId = user.id;

          localStorage.setItem("wrapsheet-user-id", user.id);

          // Reset UI
          document.getElementById("current-user-label").textContent = user.name;
          if (overlay) overlay.style.display = "none";

          // RELOAD ALL DATA
          showActionLoader({ main: "Switching User…", sub: "Loading your coins & bird" });

          try {
            // 1. Load Coins (Local + Server)
            await loadCoinBalance();

            // 2. Load Prefs (Bird Colors, etc.)
            await loadUserDbPreferences();

            // 3. Load Pillars & Goals
            await setActiveUser(user.id);

            // 4. Init Bird (Redraw)
            if (typeof initBirdSystem === "function") initBirdSystem();

            // 4b. Load saved bird colors and name from API
            if (typeof loadBirdPreferences === "function") await loadBirdPreferences();

            // 5. Refresh Weekly Tasks
            if (typeof initWeeklyTasksUI === "function") initWeeklyTasksUI();

            showToast(`Welcome, ${user.name.split(" ")[0]}!`);

          } catch (e) {
            console.error("Switch User Error", e);
          } finally {
            hideActionLoader();
          }
        });
      }

      if (switchBtn) {
        switchBtn.addEventListener("click", () => {
          if (overlay) overlay.style.display = "flex";
        });
      }
    }

    // Initialize draggable sections
    document.addEventListener("DOMContentLoaded", () => {
      initDraggableSections();
      initInstructionsHide();
      initTaskReminders(); // Start reminder check loop
      if (typeof initUserSwitcher === "function") initUserSwitcher();
    });

    // ===== TASK REMINDERS SYSTEM =====
    let reminderChimeInterval = null;
    let audioContext = null;

    function initTaskReminders() {
      // Event listeners are attached dynamically in renderReminders()
      // Check for reminders every 60 seconds
      checkUpcomingReminders();
      setInterval(checkUpcomingReminders, 60000);
    }

    function checkUpcomingReminders() {
      if (!state.currentUser) return;

      // Check if chimes are enabled (defaults to true if not set)
      const chimesEnabled = localStorage.getItem("wrapsheet-reminder-chimes") !== "false";

      const now = new Date();
      const todayStr = now.toISOString().split("T")[0];
      const currentMinutes = now.getHours() * 60 + now.getMinutes();

      // Find tasks for current user with task_time set today
      const myTodayTasks = state.dailyTasks.filter(t =>
        t.task_date === todayStr &&
        t.task_time &&
        t.status !== "done" &&
        t.status !== "could_not_complete" &&
        (t.assigned_to_id === state.currentUser.id ||
          (t.assignees && t.assignees.some(a => a.id === state.currentUser.id)))
      );

      // Check dismissed reminders in localStorage (keyed by date so they reset each day)
      const dismissedKey = `dismissed-reminders-${todayStr}`;
      const dismissed = JSON.parse(localStorage.getItem(dismissedKey) || "[]");
      // Snoozed reminders (temporary hide until next cycle)
      const snoozedKey = `snoozed-reminders-${todayStr}`;
      const snoozed = JSON.parse(sessionStorage.getItem(snoozedKey) || "[]");

      // Collect all tasks within 30 minutes OR overdue that haven't been dismissed
      const upcomingTasks = [];
      for (const task of myTodayTasks) {
        const [h, m] = task.task_time.split(":").map(Number);
        const taskMinutes = h * 60 + m;
        const minutesUntil = taskMinutes - currentMinutes;

        // Show if within 30 minutes upcoming, OR overdue (negative), not dismissed, and not snoozed
        // Cap overdue display at 120 minutes (2 hours) to avoid showing ancient reminders
        if (minutesUntil <= 30 && minutesUntil >= -120 && !dismissed.includes(task.id) && !snoozed.includes(task.id)) {
          upcomingTasks.push({ task, minutesUntil });
        }
      }

      // Render all reminders
      renderReminders(upcomingTasks, chimesEnabled);
    }

    function renderReminders(upcomingTasks, chimesEnabled) {
      const container = document.getElementById("reminder-container");
      if (!container) return;

      // Clear existing reminders
      container.innerHTML = "";

      if (upcomingTasks.length === 0) {
        // Stop chime if no reminders
        if (reminderChimeInterval) {
          clearInterval(reminderChimeInterval);
          reminderChimeInterval = null;
        }
        return;
      }

      // Create a banner for each upcoming task
      upcomingTasks.forEach(({ task, minutesUntil }) => {
        const banner = document.createElement("div");
        banner.className = "reminder-banner";
        if (minutesUntil <= 0) {
          banner.classList.add("overdue"); // Add overdue styling
        }
        banner.dataset.taskId = task.id;

        // Determine the time message
        let timeMessage;
        let icon = "🔔";
        if (minutesUntil > 0) {
          timeMessage = `starts in ${minutesUntil} minute${minutesUntil !== 1 ? "s" : ""}`;
        } else if (minutesUntil === 0) {
          timeMessage = `starting NOW!`;
          icon = "⏰";
        } else {
          const lateMinutes = Math.abs(minutesUntil);
          timeMessage = `${lateMinutes} minute${lateMinutes !== 1 ? "s" : ""} LATE!`;
          icon = "⚠️";
        }

        banner.innerHTML = `
          <div class="reminder-content">
            <span class="reminder-icon">${icon}</span>
            <div class="reminder-text">
              <div class="reminder-title">${escapeHtml(task.title)}</div>
              <div class="reminder-time">${timeMessage}</div>
            </div>
            <div class="reminder-buttons">
              <button class="reminder-snooze" data-task-id="${task.id}">Snooze</button>
              <button class="reminder-dismiss" data-task-id="${task.id}">Dismiss</button>
            </div>
          </div>
        `;
        container.appendChild(banner);
      });

      // Attach event listeners
      container.querySelectorAll(".reminder-snooze").forEach(btn => {
        btn.addEventListener("click", (e) => snoozeReminder(e.target.dataset.taskId));
      });
      container.querySelectorAll(".reminder-dismiss").forEach(btn => {
        btn.addEventListener("click", (e) => dismissReminder(e.target.dataset.taskId));
      });

      // Determine chime interval based on most urgent task
      // Under 2 min: every 10 seconds | Under 5 min: every 30 seconds | Otherwise: every 5 minutes
      const mostUrgent = Math.min(...upcomingTasks.map(t => t.minutesUntil));
      let chimeIntervalMs;
      if (mostUrgent <= 2) {
        chimeIntervalMs = 10 * 1000; // 10 seconds
      } else if (mostUrgent <= 5) {
        chimeIntervalMs = 30 * 1000; // 30 seconds
      } else {
        chimeIntervalMs = 5 * 60 * 1000; // 5 minutes
      }

      // Play chime if enabled, and restart interval if urgency level changed
      if (chimesEnabled) {
        // Clear old interval if urgency changed
        if (reminderChimeInterval && window.currentChimeIntervalMs !== chimeIntervalMs) {
          clearInterval(reminderChimeInterval);
          reminderChimeInterval = null;
        }

        if (!reminderChimeInterval) {
          playReminderChime();
          reminderChimeInterval = setInterval(playReminderChime, chimeIntervalMs);
          window.currentChimeIntervalMs = chimeIntervalMs;
        }
      }
    }

    // Helper to escape HTML
    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    function dismissReminder(taskId) {
      if (!taskId) return;

      // Add to dismissed list in localStorage (keyed by today's date)
      const todayStr = new Date().toISOString().split("T")[0];
      const dismissedKey = `dismissed-reminders-${todayStr}`;
      const dismissed = JSON.parse(localStorage.getItem(dismissedKey) || "[]");
      dismissed.push(parseInt(taskId, 10));
      localStorage.setItem(dismissedKey, JSON.stringify(dismissed));

      // Re-render to remove this banner
      checkUpcomingReminders();
    }

    function snoozeReminder(taskId) {
      if (!taskId) return;

      // Add to snoozed list in sessionStorage (temporary until next check cycle)
      const todayStr = new Date().toISOString().split("T")[0];
      const snoozedKey = `snoozed-reminders-${todayStr}`;
      const snoozed = JSON.parse(sessionStorage.getItem(snoozedKey) || "[]");
      snoozed.push(parseInt(taskId, 10));
      sessionStorage.setItem(snoozedKey, JSON.stringify(snoozed));

      // Clear snooze after 60 seconds (next check cycle)
      setTimeout(() => {
        const current = JSON.parse(sessionStorage.getItem(snoozedKey) || "[]");
        const filtered = current.filter(id => id !== parseInt(taskId, 10));
        sessionStorage.setItem(snoozedKey, JSON.stringify(filtered));
      }, 60000);

      // Re-render to remove this banner temporarily
      checkUpcomingReminders();
    }

    function playReminderChime() {
      try {
        // Create audio context if not exists
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Simple pleasant chime using oscillators
        const now = audioContext.currentTime;

        // Play two notes for a pleasant notification sound
        [523.25, 659.25].forEach((freq, i) => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();

          osc.type = "sine";
          osc.frequency.value = freq;

          gain.gain.setValueAtTime(0, now + i * 0.15);
          gain.gain.linearRampToValueAtTime(0.3, now + i * 0.15 + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.5);

          osc.connect(gain);
          gain.connect(audioContext.destination);

          osc.start(now + i * 0.15);
          osc.stop(now + i * 0.15 + 0.5);
        });
      } catch (e) {
        console.warn("Could not play reminder chime:", e);
      }
    }

    // Toggle reminder chimes (for user preference)
    function toggleReminderChimes(enabled) {
      localStorage.setItem("wrapsheet-reminder-chimes", enabled ? "true" : "false");
    }
  </script>
</body>

</html>